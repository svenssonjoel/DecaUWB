
build/TEST.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	08000321 	.word	0x08000321
 8000008:	08000323 	.word	0x08000323
 800000c:	08000323 	.word	0x08000323
 8000010:	08000323 	.word	0x08000323
 8000014:	08000323 	.word	0x08000323
 8000018:	08000323 	.word	0x08000323
 800001c:	08000323 	.word	0x08000323
 8000020:	08000323 	.word	0x08000323
 8000024:	08000323 	.word	0x08000323
 8000028:	08000323 	.word	0x08000323
 800002c:	08002811 	.word	0x08002811
 8000030:	08000323 	.word	0x08000323
 8000034:	08000323 	.word	0x08000323
 8000038:	08000323 	.word	0x08000323
 800003c:	08000323 	.word	0x08000323
 8000040:	08000323 	.word	0x08000323
 8000044:	08000323 	.word	0x08000323
 8000048:	08000323 	.word	0x08000323
 800004c:	08000323 	.word	0x08000323
 8000050:	08000323 	.word	0x08000323
 8000054:	08000323 	.word	0x08000323
 8000058:	08000323 	.word	0x08000323
 800005c:	08000323 	.word	0x08000323
 8000060:	08000323 	.word	0x08000323
 8000064:	08000323 	.word	0x08000323
 8000068:	08000323 	.word	0x08000323
 800006c:	08004bd1 	.word	0x08004bd1
 8000070:	08004b81 	.word	0x08004b81
 8000074:	08004b31 	.word	0x08004b31
 8000078:	08004ae1 	.word	0x08004ae1
 800007c:	08004aa1 	.word	0x08004aa1
 8000080:	08004a51 	.word	0x08004a51
 8000084:	08004a01 	.word	0x08004a01
 8000088:	08000323 	.word	0x08000323
 800008c:	08000323 	.word	0x08000323
 8000090:	08000323 	.word	0x08000323
 8000094:	08000323 	.word	0x08000323
 8000098:	08000323 	.word	0x08000323
 800009c:	08000323 	.word	0x08000323
 80000a0:	08000323 	.word	0x08000323
 80000a4:	08000323 	.word	0x08000323
 80000a8:	08000323 	.word	0x08000323
 80000ac:	08000323 	.word	0x08000323
 80000b0:	080045f1 	.word	0x080045f1
 80000b4:	08000323 	.word	0x08000323
 80000b8:	08000323 	.word	0x08000323
 80000bc:	08000323 	.word	0x08000323
 80000c0:	08000323 	.word	0x08000323
 80000c4:	08000323 	.word	0x08000323
 80000c8:	08000323 	.word	0x08000323
 80000cc:	08000323 	.word	0x08000323
 80000d0:	08000323 	.word	0x08000323
 80000d4:	08000323 	.word	0x08000323
 80000d8:	08000323 	.word	0x08000323
 80000dc:	08000323 	.word	0x08000323
 80000e0:	08000323 	.word	0x08000323
 80000e4:	08000323 	.word	0x08000323
 80000e8:	08000323 	.word	0x08000323
 80000ec:	08000323 	.word	0x08000323
 80000f0:	08000323 	.word	0x08000323
 80000f4:	08000323 	.word	0x08000323
 80000f8:	08000323 	.word	0x08000323
 80000fc:	080049b1 	.word	0x080049b1
 8000100:	08000323 	.word	0x08000323
 8000104:	08000323 	.word	0x08000323
 8000108:	08000323 	.word	0x08000323
 800010c:	08000323 	.word	0x08000323
 8000110:	08004391 	.word	0x08004391
 8000114:	08000323 	.word	0x08000323
 8000118:	08004581 	.word	0x08004581
 800011c:	08000323 	.word	0x08000323
 8000120:	08004971 	.word	0x08004971
 8000124:	08004921 	.word	0x08004921
 8000128:	080048d1 	.word	0x080048d1
 800012c:	08004881 	.word	0x08004881
 8000130:	08004841 	.word	0x08004841
 8000134:	08000323 	.word	0x08000323
 8000138:	08000323 	.word	0x08000323
 800013c:	08000323 	.word	0x08000323
 8000140:	08000323 	.word	0x08000323
 8000144:	08000323 	.word	0x08000323
 8000148:	08000323 	.word	0x08000323
 800014c:	08004721 	.word	0x08004721
 8000150:	080047f1 	.word	0x080047f1
 8000154:	080047a1 	.word	0x080047a1
 8000158:	08004751 	.word	0x08004751
 800015c:	08000323 	.word	0x08000323
 8000160:	08000323 	.word	0x08000323
 8000164:	08000323 	.word	0x08000323
 8000168:	08000323 	.word	0x08000323
 800016c:	08000323 	.word	0x08000323
 8000170:	08000323 	.word	0x08000323
 8000174:	080046f1 	.word	0x080046f1
 8000178:	08000323 	.word	0x08000323
 800017c:	08000323 	.word	0x08000323
 8000180:	08000323 	.word	0x08000323
 8000184:	08000323 	.word	0x08000323
 8000188:	08000323 	.word	0x08000323
 800018c:	08000323 	.word	0x08000323
 8000190:	08000323 	.word	0x08000323
 8000194:	08000323 	.word	0x08000323
 8000198:	08000323 	.word	0x08000323
 800019c:	08000323 	.word	0x08000323
 80001a0:	08000323 	.word	0x08000323
 80001a4:	08000323 	.word	0x08000323
 80001a8:	08000323 	.word	0x08000323
 80001ac:	08000323 	.word	0x08000323
 80001b0:	08000323 	.word	0x08000323
 80001b4:	08000323 	.word	0x08000323
 80001b8:	08000323 	.word	0x08000323
 80001bc:	08000323 	.word	0x08000323
 80001c0:	08000323 	.word	0x08000323
 80001c4:	08000323 	.word	0x08000323
 80001c8:	08000323 	.word	0x08000323
 80001cc:	08000323 	.word	0x08000323
 80001d0:	08000323 	.word	0x08000323
 80001d4:	08000323 	.word	0x08000323
 80001d8:	08000323 	.word	0x08000323
 80001dc:	08000323 	.word	0x08000323

Disassembly of section .text:

08000200 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 8000200:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 8000202:	4839      	ldr	r0, [pc, #228]	; (80002e8 <endfiniloop+0x6>)
                msr     MSP, r0
 8000204:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000208:	4838      	ldr	r0, [pc, #224]	; (80002ec <endfiniloop+0xa>)
                msr     PSP, r0
 800020a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 800020e:	4838      	ldr	r0, [pc, #224]	; (80002f0 <endfiniloop+0xe>)
                movw    r1, #SCB_VTOR & 0xFFFF
 8000210:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 8000214:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000218:	6008      	str	r0, [r1, #0]
#endif

#if CRT0_INIT_FPU == TRUE
                /* FPU FPCCR initialization.*/
                movw    r0, #CRT0_FPCCR_INIT & 0xFFFF
 800021a:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_FPCCR_INIT >> 16
 800021e:	f2cc 0000 	movt	r0, #49152	; 0xc000
                movw    r1, #SCB_FPCCR & 0xFFFF
 8000222:	f64e 7134 	movw	r1, #61236	; 0xef34
                movt    r1, #SCB_FPCCR >> 16
 8000226:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800022a:	6008      	str	r0, [r1, #0]
                dsb
 800022c:	f3bf 8f4f 	dsb	sy
                isb
 8000230:	f3bf 8f6f 	isb	sy

                /* CPACR initialization.*/
                movw    r0, #CRT0_CPACR_INIT & 0xFFFF
 8000234:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_CPACR_INIT >> 16
 8000238:	f2c0 00f0 	movt	r0, #240	; 0xf0
                movw    r1, #SCB_CPACR & 0xFFFF
 800023c:	f64e 5188 	movw	r1, #60808	; 0xed88
                movt    r1, #SCB_CPACR >> 16
 8000240:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000244:	6008      	str	r0, [r1, #0]
                dsb
 8000246:	f3bf 8f4f 	dsb	sy
                isb
 800024a:	f3bf 8f6f 	isb	sy

                /* FPU FPSCR initially cleared.*/
                mov     r0, #0
 800024e:	f04f 0000 	mov.w	r0, #0
                vmsr    FPSCR, r0
 8000252:	eee1 0a10 	vmsr	fpscr, r0

                /* FPU FPDSCR initially cleared.*/
                movw    r1, #SCB_FPDSCR & 0xFFFF
 8000256:	f64e 713c 	movw	r1, #61244	; 0xef3c
                movt    r1, #SCB_FPDSCR >> 16
 800025a:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800025e:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA
 8000260:	2006      	movs	r0, #6
#else
                movs    r0, #CRT0_CONTROL_INIT
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 8000262:	f380 8814 	msr	CONTROL, r0
                isb
 8000266:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 800026a:	f004 fd19 	bl	8004ca0 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 800026e:	f003 ff47 	bl	8004100 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000272:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000276:	491f      	ldr	r1, [pc, #124]	; (80002f4 <endfiniloop+0x12>)
                ldr     r2, =__main_stack_end__
 8000278:	4a1b      	ldr	r2, [pc, #108]	; (80002e8 <endfiniloop+0x6>)

0800027a <msloop>:
msloop:
                cmp     r1, r2
 800027a:	4291      	cmp	r1, r2
                itt     lo
 800027c:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800027e:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000282:	e7fa      	bcc.n	800027a <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000284:	491c      	ldr	r1, [pc, #112]	; (80002f8 <endfiniloop+0x16>)
                ldr     r2, =__process_stack_end__
 8000286:	4a19      	ldr	r2, [pc, #100]	; (80002ec <endfiniloop+0xa>)

08000288 <psloop>:
psloop:
                cmp     r1, r2
 8000288:	4291      	cmp	r1, r2
                itt     lo
 800028a:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800028c:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000290:	e7fa      	bcc.n	8000288 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =__textdata_base__
 8000292:	491a      	ldr	r1, [pc, #104]	; (80002fc <endfiniloop+0x1a>)
                ldr     r2, =__data_base__
 8000294:	4a1a      	ldr	r2, [pc, #104]	; (8000300 <endfiniloop+0x1e>)
                ldr     r3, =__data_end__
 8000296:	4b1b      	ldr	r3, [pc, #108]	; (8000304 <endfiniloop+0x22>)

08000298 <dloop>:
dloop:
                cmp     r2, r3
 8000298:	429a      	cmp	r2, r3
                ittt    lo
 800029a:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 800029c:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 80002a0:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 80002a4:	e7f8      	bcc.n	8000298 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 80002a6:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 80002a8:	4917      	ldr	r1, [pc, #92]	; (8000308 <endfiniloop+0x26>)
                ldr     r2, =__bss_end__
 80002aa:	4a18      	ldr	r2, [pc, #96]	; (800030c <endfiniloop+0x2a>)

080002ac <bloop>:
bloop:
                cmp     r1, r2
 80002ac:	4291      	cmp	r1, r2
                itt     lo
 80002ae:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80002b0:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 80002b4:	e7fa      	bcc.n	80002ac <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 80002b6:	f004 fcab 	bl	8004c10 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 80002ba:	f004 fce9 	bl	8004c90 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 80002be:	4c14      	ldr	r4, [pc, #80]	; (8000310 <endfiniloop+0x2e>)
                ldr     r5, =__init_array_end__
 80002c0:	4d14      	ldr	r5, [pc, #80]	; (8000314 <endfiniloop+0x32>)

080002c2 <initloop>:
initloop:
                cmp     r4, r5
 80002c2:	42ac      	cmp	r4, r5
                bge     endinitloop
 80002c4:	da03      	bge.n	80002ce <endinitloop>
                ldr     r1, [r4], #4
 80002c6:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80002ca:	4788      	blx	r1
                b       initloop
 80002cc:	e7f9      	b.n	80002c2 <initloop>

080002ce <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 80002ce:	f002 fecf 	bl	8003070 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 80002d2:	4c11      	ldr	r4, [pc, #68]	; (8000318 <endfiniloop+0x36>)
                ldr     r5, =__fini_array_end__
 80002d4:	4d11      	ldr	r5, [pc, #68]	; (800031c <endfiniloop+0x3a>)

080002d6 <finiloop>:
finiloop:
                cmp     r4, r5
 80002d6:	42ac      	cmp	r4, r5
                bge     endfiniloop
 80002d8:	da03      	bge.n	80002e2 <endfiniloop>
                ldr     r1, [r4], #4
 80002da:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80002de:	4788      	blx	r1
                b       finiloop
 80002e0:	e7f9      	b.n	80002d6 <finiloop>

080002e2 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 80002e2:	f004 bccd 	b.w	8004c80 <__default_exit>
 80002e6:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 80002e8:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 80002ec:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 80002f0:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 80002f4:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 80002f8:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 80002fc:	0800552c 	.word	0x0800552c
                ldr     r2, =__data_base__
 8000300:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 8000304:	20000814 	.word	0x20000814
                ldr     r1, =__bss_base__
 8000308:	20000818 	.word	0x20000818
                ldr     r2, =__bss_end__
 800030c:	20002c50 	.word	0x20002c50
                ldr     r4, =__init_array_base__
 8000310:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end__
 8000314:	080001e0 	.word	0x080001e0
                ldr     r4, =__fini_array_base__
 8000318:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end__
 800031c:	080001e0 	.word	0x080001e0

08000320 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000320:	e76e      	b.n	8000200 <_crt0_entry>

08000322 <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 8000322:	f000 f800 	bl	8000326 <_unhandled_exception>

08000326 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 8000326:	e7fe      	b.n	8000326 <_unhandled_exception>

08000328 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8000328:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                /* Saving FPU context.*/
                vpush   {s16-s31}
 800032c:	ed2d 8a10 	vpush	{s16-s31}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 8000330:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 8000334:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 8000336:	469d      	mov	sp, r3
#endif
#endif

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
 8000338:	ecbd 8a10 	vpop	{s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800033c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000340 <_port_thread_start>:
_port_thread_start:
#if CH_DBG_ENABLE_STACK_CHECK && PORT_ENABLE_GUARD_PAGES
                bl      _port_set_region
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 8000340:	f002 faa6 	bl	8002890 <_dbg_check_unlock>
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 8000344:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 8000346:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 800034a:	4628      	mov	r0, r5
                blx     r4
 800034c:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 800034e:	2000      	movs	r0, #0
                bl      chThdExit
 8000350:	f002 fdb6 	bl	8002ec0 <chThdExit>

08000354 <_zombies>:
_zombies:       b       _zombies
 8000354:	e7fe      	b.n	8000354 <_zombies>

08000356 <_port_switch_from_isr>:
_port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
 8000356:	f002 fac3 	bl	80028e0 <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
 800035a:	f002 fa69 	bl	8002830 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 800035e:	f002 fa97 	bl	8002890 <_dbg_check_unlock>

08000362 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000362:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000364:	e7fe      	b.n	8000364 <_port_exit_from_isr+0x2>
	...

08000368 <memcpy>:
 8000368:	4684      	mov	ip, r0
 800036a:	ea41 0300 	orr.w	r3, r1, r0
 800036e:	f013 0303 	ands.w	r3, r3, #3
 8000372:	d16d      	bne.n	8000450 <memcpy+0xe8>
 8000374:	3a40      	subs	r2, #64	; 0x40
 8000376:	d341      	bcc.n	80003fc <memcpy+0x94>
 8000378:	f851 3b04 	ldr.w	r3, [r1], #4
 800037c:	f840 3b04 	str.w	r3, [r0], #4
 8000380:	f851 3b04 	ldr.w	r3, [r1], #4
 8000384:	f840 3b04 	str.w	r3, [r0], #4
 8000388:	f851 3b04 	ldr.w	r3, [r1], #4
 800038c:	f840 3b04 	str.w	r3, [r0], #4
 8000390:	f851 3b04 	ldr.w	r3, [r1], #4
 8000394:	f840 3b04 	str.w	r3, [r0], #4
 8000398:	f851 3b04 	ldr.w	r3, [r1], #4
 800039c:	f840 3b04 	str.w	r3, [r0], #4
 80003a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a4:	f840 3b04 	str.w	r3, [r0], #4
 80003a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003ac:	f840 3b04 	str.w	r3, [r0], #4
 80003b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b4:	f840 3b04 	str.w	r3, [r0], #4
 80003b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003bc:	f840 3b04 	str.w	r3, [r0], #4
 80003c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003c4:	f840 3b04 	str.w	r3, [r0], #4
 80003c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003cc:	f840 3b04 	str.w	r3, [r0], #4
 80003d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003d4:	f840 3b04 	str.w	r3, [r0], #4
 80003d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003dc:	f840 3b04 	str.w	r3, [r0], #4
 80003e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003e4:	f840 3b04 	str.w	r3, [r0], #4
 80003e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003ec:	f840 3b04 	str.w	r3, [r0], #4
 80003f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003f4:	f840 3b04 	str.w	r3, [r0], #4
 80003f8:	3a40      	subs	r2, #64	; 0x40
 80003fa:	d2bd      	bcs.n	8000378 <memcpy+0x10>
 80003fc:	3230      	adds	r2, #48	; 0x30
 80003fe:	d311      	bcc.n	8000424 <memcpy+0xbc>
 8000400:	f851 3b04 	ldr.w	r3, [r1], #4
 8000404:	f840 3b04 	str.w	r3, [r0], #4
 8000408:	f851 3b04 	ldr.w	r3, [r1], #4
 800040c:	f840 3b04 	str.w	r3, [r0], #4
 8000410:	f851 3b04 	ldr.w	r3, [r1], #4
 8000414:	f840 3b04 	str.w	r3, [r0], #4
 8000418:	f851 3b04 	ldr.w	r3, [r1], #4
 800041c:	f840 3b04 	str.w	r3, [r0], #4
 8000420:	3a10      	subs	r2, #16
 8000422:	d2ed      	bcs.n	8000400 <memcpy+0x98>
 8000424:	320c      	adds	r2, #12
 8000426:	d305      	bcc.n	8000434 <memcpy+0xcc>
 8000428:	f851 3b04 	ldr.w	r3, [r1], #4
 800042c:	f840 3b04 	str.w	r3, [r0], #4
 8000430:	3a04      	subs	r2, #4
 8000432:	d2f9      	bcs.n	8000428 <memcpy+0xc0>
 8000434:	3204      	adds	r2, #4
 8000436:	d008      	beq.n	800044a <memcpy+0xe2>
 8000438:	07d2      	lsls	r2, r2, #31
 800043a:	bf1c      	itt	ne
 800043c:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000440:	f800 3b01 	strbne.w	r3, [r0], #1
 8000444:	d301      	bcc.n	800044a <memcpy+0xe2>
 8000446:	880b      	ldrh	r3, [r1, #0]
 8000448:	8003      	strh	r3, [r0, #0]
 800044a:	4660      	mov	r0, ip
 800044c:	4770      	bx	lr
 800044e:	bf00      	nop
 8000450:	2a08      	cmp	r2, #8
 8000452:	d313      	bcc.n	800047c <memcpy+0x114>
 8000454:	078b      	lsls	r3, r1, #30
 8000456:	d08d      	beq.n	8000374 <memcpy+0xc>
 8000458:	f010 0303 	ands.w	r3, r0, #3
 800045c:	d08a      	beq.n	8000374 <memcpy+0xc>
 800045e:	f1c3 0304 	rsb	r3, r3, #4
 8000462:	1ad2      	subs	r2, r2, r3
 8000464:	07db      	lsls	r3, r3, #31
 8000466:	bf1c      	itt	ne
 8000468:	f811 3b01 	ldrbne.w	r3, [r1], #1
 800046c:	f800 3b01 	strbne.w	r3, [r0], #1
 8000470:	d380      	bcc.n	8000374 <memcpy+0xc>
 8000472:	f831 3b02 	ldrh.w	r3, [r1], #2
 8000476:	f820 3b02 	strh.w	r3, [r0], #2
 800047a:	e77b      	b.n	8000374 <memcpy+0xc>
 800047c:	3a04      	subs	r2, #4
 800047e:	d3d9      	bcc.n	8000434 <memcpy+0xcc>
 8000480:	3a01      	subs	r2, #1
 8000482:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000486:	f800 3b01 	strb.w	r3, [r0], #1
 800048a:	d2f9      	bcs.n	8000480 <memcpy+0x118>
 800048c:	780b      	ldrb	r3, [r1, #0]
 800048e:	7003      	strb	r3, [r0, #0]
 8000490:	784b      	ldrb	r3, [r1, #1]
 8000492:	7043      	strb	r3, [r0, #1]
 8000494:	788b      	ldrb	r3, [r1, #2]
 8000496:	7083      	strb	r3, [r0, #2]
 8000498:	4660      	mov	r0, ip
 800049a:	4770      	bx	lr
	...

080004c0 <strlen>:
 80004c0:	f890 f000 	pld	[r0]
 80004c4:	e96d 4502 	strd	r4, r5, [sp, #-8]!
 80004c8:	f020 0107 	bic.w	r1, r0, #7
 80004cc:	f06f 0c00 	mvn.w	ip, #0
 80004d0:	f010 0407 	ands.w	r4, r0, #7
 80004d4:	f891 f020 	pld	[r1, #32]
 80004d8:	f040 8049 	bne.w	800056e <strlen+0xae>
 80004dc:	f04f 0400 	mov.w	r4, #0
 80004e0:	f06f 0007 	mvn.w	r0, #7
 80004e4:	e9d1 2300 	ldrd	r2, r3, [r1]
 80004e8:	f891 f040 	pld	[r1, #64]	; 0x40
 80004ec:	f100 0008 	add.w	r0, r0, #8
 80004f0:	fa82 f24c 	uadd8	r2, r2, ip
 80004f4:	faa4 f28c 	sel	r2, r4, ip
 80004f8:	fa83 f34c 	uadd8	r3, r3, ip
 80004fc:	faa2 f38c 	sel	r3, r2, ip
 8000500:	bb4b      	cbnz	r3, 8000556 <strlen+0x96>
 8000502:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
 8000506:	fa82 f24c 	uadd8	r2, r2, ip
 800050a:	f100 0008 	add.w	r0, r0, #8
 800050e:	faa4 f28c 	sel	r2, r4, ip
 8000512:	fa83 f34c 	uadd8	r3, r3, ip
 8000516:	faa2 f38c 	sel	r3, r2, ip
 800051a:	b9e3      	cbnz	r3, 8000556 <strlen+0x96>
 800051c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
 8000520:	fa82 f24c 	uadd8	r2, r2, ip
 8000524:	f100 0008 	add.w	r0, r0, #8
 8000528:	faa4 f28c 	sel	r2, r4, ip
 800052c:	fa83 f34c 	uadd8	r3, r3, ip
 8000530:	faa2 f38c 	sel	r3, r2, ip
 8000534:	b97b      	cbnz	r3, 8000556 <strlen+0x96>
 8000536:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
 800053a:	f101 0120 	add.w	r1, r1, #32
 800053e:	fa82 f24c 	uadd8	r2, r2, ip
 8000542:	f100 0008 	add.w	r0, r0, #8
 8000546:	faa4 f28c 	sel	r2, r4, ip
 800054a:	fa83 f34c 	uadd8	r3, r3, ip
 800054e:	faa2 f38c 	sel	r3, r2, ip
 8000552:	2b00      	cmp	r3, #0
 8000554:	d0c6      	beq.n	80004e4 <strlen+0x24>
 8000556:	2a00      	cmp	r2, #0
 8000558:	bf04      	itt	eq
 800055a:	3004      	addeq	r0, #4
 800055c:	461a      	moveq	r2, r3
 800055e:	ba12      	rev	r2, r2
 8000560:	fab2 f282 	clz	r2, r2
 8000564:	e8fd 4502 	ldrd	r4, r5, [sp], #8
 8000568:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 800056c:	4770      	bx	lr
 800056e:	e9d1 2300 	ldrd	r2, r3, [r1]
 8000572:	f004 0503 	and.w	r5, r4, #3
 8000576:	f1c4 0000 	rsb	r0, r4, #0
 800057a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 800057e:	f014 0f04 	tst.w	r4, #4
 8000582:	f891 f040 	pld	[r1, #64]	; 0x40
 8000586:	fa0c f505 	lsl.w	r5, ip, r5
 800058a:	ea62 0205 	orn	r2, r2, r5
 800058e:	bf1c      	itt	ne
 8000590:	ea63 0305 	ornne	r3, r3, r5
 8000594:	4662      	movne	r2, ip
 8000596:	f04f 0400 	mov.w	r4, #0
 800059a:	e7a9      	b.n	80004f0 <strlen+0x30>
 800059c:	0000      	movs	r0, r0
	...

080005a0 <get_descriptor>:
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
 80005a0:	2902      	cmp	r1, #2
 80005a2:	d006      	beq.n	80005b2 <get_descriptor+0x12>
 80005a4:	2903      	cmp	r1, #3
 80005a6:	d006      	beq.n	80005b6 <get_descriptor+0x16>
 80005a8:	2901      	cmp	r1, #1
  case USB_DESCRIPTOR_DEVICE:
    return &vcom_device_descriptor;
 80005aa:	4807      	ldr	r0, [pc, #28]	; (80005c8 <get_descriptor+0x28>)
 80005ac:	bf18      	it	ne
 80005ae:	2000      	movne	r0, #0
 80005b0:	4770      	bx	lr
  switch (dtype) {
 80005b2:	4806      	ldr	r0, [pc, #24]	; (80005cc <get_descriptor+0x2c>)
 80005b4:	4770      	bx	lr
  case USB_DESCRIPTOR_CONFIGURATION:
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
 80005b6:	2a03      	cmp	r2, #3
 80005b8:	d803      	bhi.n	80005c2 <get_descriptor+0x22>
      return &vcom_strings[dindex];
 80005ba:	4805      	ldr	r0, [pc, #20]	; (80005d0 <get_descriptor+0x30>)
 80005bc:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
 80005c0:	4770      	bx	lr
  }
  return NULL;
 80005c2:	2000      	movs	r0, #0
}
 80005c4:	4770      	bx	lr
 80005c6:	bf00      	nop
 80005c8:	08005430 	.word	0x08005430
 80005cc:	080053e4 	.word	0x080053e4
 80005d0:	080054b8 	.word	0x080054b8
	...

080005e0 <notify4>:

#if STM32_SERIAL_USE_UART4 || defined(__DOXYGEN__)
static void notify4(io_queue_t *qp) {

  (void)qp;
  UART4->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 80005e0:	4a02      	ldr	r2, [pc, #8]	; (80005ec <notify4+0xc>)
 80005e2:	68d3      	ldr	r3, [r2, #12]
 80005e4:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80005e8:	60d3      	str	r3, [r2, #12]
}
 80005ea:	4770      	bx	lr
 80005ec:	40004c00 	.word	0x40004c00

080005f0 <_port_irq_epilogue>:
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80005f0:	2320      	movs	r3, #32
 80005f2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 80005f6:	4b10      	ldr	r3, [pc, #64]	; (8000638 <_port_irq_epilogue+0x48>)
 80005f8:	685b      	ldr	r3, [r3, #4]
 80005fa:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 80005fe:	d102      	bne.n	8000606 <_port_irq_epilogue+0x16>
 8000600:	f383 8811 	msr	BASEPRI, r3
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8000604:	4770      	bx	lr
  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
  return __builtin_arm_get_fpscr();
#else
  uint32_t result;

  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 8000606:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 800060a:	f3ef 8309 	mrs	r3, PSP
    s_psp -= sizeof (struct port_extctx);
 800060e:	3b68      	subs	r3, #104	; 0x68
    ectxp->xpsr = 0x01000000U;
 8000610:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ectxp->fpscr = FPU->FPDSCR;
 8000614:	4a09      	ldr	r2, [pc, #36]	; (800063c <_port_irq_epilogue+0x4c>)
    ectxp->xpsr = 0x01000000U;
 8000616:	61d9      	str	r1, [r3, #28]
    ectxp->fpscr = FPU->FPDSCR;
 8000618:	68d2      	ldr	r2, [r2, #12]
 800061a:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 800061c:	f383 8809 	msr	PSP, r3
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8000620:	4a07      	ldr	r2, [pc, #28]	; (8000640 <_port_irq_epilogue+0x50>)
 8000622:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 8000624:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
 8000626:	6889      	ldr	r1, [r1, #8]
 8000628:	6892      	ldr	r2, [r2, #8]
 800062a:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
 800062c:	bf8c      	ite	hi
 800062e:	4a05      	ldrhi	r2, [pc, #20]	; (8000644 <_port_irq_epilogue+0x54>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
 8000630:	4a05      	ldrls	r2, [pc, #20]	; (8000648 <_port_irq_epilogue+0x58>)
 8000632:	619a      	str	r2, [r3, #24]
 8000634:	4770      	bx	lr
 8000636:	bf00      	nop
 8000638:	e000ed00 	.word	0xe000ed00
 800063c:	e000ef30 	.word	0xe000ef30
 8000640:	20000e84 	.word	0x20000e84
 8000644:	08000357 	.word	0x08000357
 8000648:	08000362 	.word	0x08000362
 800064c:	00000000 	.word	0x00000000

08000650 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000650:	4a0e      	ldr	r2, [pc, #56]	; (800068c <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000652:	4b0f      	ldr	r3, [pc, #60]	; (8000690 <chTMStopMeasurementX+0x40>)
 8000654:	6852      	ldr	r2, [r2, #4]
 8000656:	f8d3 3884 	ldr.w	r3, [r3, #2180]	; 0x884
  tmp->last = (now - tmp->last) - offset;
 800065a:	6881      	ldr	r1, [r0, #8]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 800065c:	b430      	push	{r4, r5}
  tmp->last = (now - tmp->last) - offset;
 800065e:	1ad3      	subs	r3, r2, r3
  tmp->cumulative += (rttime_t)tmp->last;
 8000660:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  tmp->n++;
 8000664:	68c2      	ldr	r2, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 8000666:	1a5b      	subs	r3, r3, r1
  tmp->n++;
 8000668:	3201      	adds	r2, #1
  if (tmp->last > tmp->worst) {
 800066a:	6841      	ldr	r1, [r0, #4]
  tmp->n++;
 800066c:	60c2      	str	r2, [r0, #12]
  tmp->cumulative += (rttime_t)tmp->last;
 800066e:	18e4      	adds	r4, r4, r3
  if (tmp->last < tmp->best) {
 8000670:	6802      	ldr	r2, [r0, #0]
  tmp->last = (now - tmp->last) - offset;
 8000672:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8000674:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8000678:	428b      	cmp	r3, r1
    tmp->worst = tmp->last;
 800067a:	bf88      	it	hi
 800067c:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
 800067e:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
 8000680:	e9c0 4504 	strd	r4, r5, [r0, #16]
    tmp->best = tmp->last;
 8000684:	bf38      	it	cc
 8000686:	6003      	strcc	r3, [r0, #0]
}
 8000688:	bc30      	pop	{r4, r5}
 800068a:	4770      	bx	lr
 800068c:	e0001000 	.word	0xe0001000
 8000690:	20000e84 	.word	0x20000e84
	...

080006a0 <chTMStartMeasurementX>:
 80006a0:	4b01      	ldr	r3, [pc, #4]	; (80006a8 <chTMStartMeasurementX+0x8>)
 80006a2:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
 80006a4:	6083      	str	r3, [r0, #8]
}
 80006a6:	4770      	bx	lr
 80006a8:	e0001000 	.word	0xe0001000
 80006ac:	00000000 	.word	0x00000000

080006b0 <trace_next>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
NOINLINE static void trace_next(void) {
 80006b0:	b410      	push	{r4}

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 80006b2:	4a0b      	ldr	r2, [pc, #44]	; (80006e0 <trace_next+0x30>)
 80006b4:	480b      	ldr	r0, [pc, #44]	; (80006e4 <trace_next+0x34>)
 80006b6:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80006b8:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 80006bc:	6819      	ldr	r1, [r3, #0]
 80006be:	6a64      	ldr	r4, [r4, #36]	; 0x24
  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 80006c0:	605c      	str	r4, [r3, #4]
 80006c2:	6840      	ldr	r0, [r0, #4]
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 80006c4:	f360 211f 	bfi	r1, r0, #8, #24
 80006c8:	f843 1b10 	str.w	r1, [r3], #16
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 80006cc:	f502 6104 	add.w	r1, r2, #2112	; 0x840
 80006d0:	428b      	cmp	r3, r1
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 80006d2:	bf28      	it	cs
 80006d4:	f102 0340 	addcs.w	r3, r2, #64	; 0x40
  }
}
 80006d8:	f85d 4b04 	ldr.w	r4, [sp], #4
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 80006dc:	63d3      	str	r3, [r2, #60]	; 0x3c
}
 80006de:	4770      	bx	lr
 80006e0:	20000e84 	.word	0x20000e84
 80006e4:	e0001000 	.word	0xe0001000
	...

080006f0 <_trace_switch.part.0>:
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80006f0:	f890 3020 	ldrb.w	r3, [r0, #32]
 80006f4:	4905      	ldr	r1, [pc, #20]	; (800070c <_trace_switch.part.0+0x1c>)
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80006f6:	6a40      	ldr	r0, [r0, #36]	; 0x24
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80006f8:	6bca      	ldr	r2, [r1, #60]	; 0x3c
 80006fa:	00db      	lsls	r3, r3, #3
 80006fc:	f043 0301 	orr.w	r3, r3, #1
 8000700:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8000702:	698b      	ldr	r3, [r1, #24]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8000704:	e9c2 3002 	strd	r3, r0, [r2, #8]
    trace_next();
 8000708:	f7ff bfd2 	b.w	80006b0 <trace_next>
 800070c:	20000e84 	.word	0x20000e84

08000710 <_trace_isr_leave>:
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8000710:	4a09      	ldr	r2, [pc, #36]	; (8000738 <_trace_isr_leave+0x28>)
 8000712:	8f13      	ldrh	r3, [r2, #56]	; 0x38
void _trace_isr_leave(const char *isr) {
 8000714:	b510      	push	{r4, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8000716:	f013 0402 	ands.w	r4, r3, #2
 800071a:	d000      	beq.n	800071e <_trace_isr_leave+0xe>
    ch.dbg.trace_buffer.ptr->state       = 0U;
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
    trace_next();
    port_unlock_from_isr();
  }
}
 800071c:	bd10      	pop	{r4, pc}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800071e:	2320      	movs	r3, #32
 8000720:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8000724:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8000726:	2203      	movs	r2, #3
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8000728:	6098      	str	r0, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800072a:	701a      	strb	r2, [r3, #0]
    trace_next();
 800072c:	f7ff ffc0 	bl	80006b0 <trace_next>
 8000730:	f384 8811 	msr	BASEPRI, r4
}
 8000734:	bd10      	pop	{r4, pc}
 8000736:	bf00      	nop
 8000738:	20000e84 	.word	0x20000e84
 800073c:	00000000 	.word	0x00000000

08000740 <_trace_isr_enter>:
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8000740:	4a09      	ldr	r2, [pc, #36]	; (8000768 <_trace_isr_enter+0x28>)
 8000742:	8f13      	ldrh	r3, [r2, #56]	; 0x38
void _trace_isr_enter(const char *isr) {
 8000744:	b510      	push	{r4, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8000746:	f013 0402 	ands.w	r4, r3, #2
 800074a:	d000      	beq.n	800074e <_trace_isr_enter+0xe>
}
 800074c:	bd10      	pop	{r4, pc}
 800074e:	2320      	movs	r3, #32
 8000750:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8000754:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8000756:	2202      	movs	r2, #2
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8000758:	6098      	str	r0, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800075a:	701a      	strb	r2, [r3, #0]
    trace_next();
 800075c:	f7ff ffa8 	bl	80006b0 <trace_next>
 8000760:	f384 8811 	msr	BASEPRI, r4
}
 8000764:	bd10      	pop	{r4, pc}
 8000766:	bf00      	nop
 8000768:	20000e84 	.word	0x20000e84
 800076c:	00000000 	.word	0x00000000

08000770 <chSysPolledDelayX>:
 8000770:	4a03      	ldr	r2, [pc, #12]	; (8000780 <chSysPolledDelayX+0x10>)
 8000772:	6851      	ldr	r1, [r2, #4]
 8000774:	6853      	ldr	r3, [r2, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8000776:	1a5b      	subs	r3, r3, r1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8000778:	4298      	cmp	r0, r3
 800077a:	d8fb      	bhi.n	8000774 <chSysPolledDelayX+0x4>
  }
}
 800077c:	4770      	bx	lr
 800077e:	bf00      	nop
 8000780:	e0001000 	.word	0xe0001000
	...

08000790 <chSysHalt>:
void chSysHalt(const char *reason) {
 8000790:	b508      	push	{r3, lr}
 8000792:	4604      	mov	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
 8000794:	b672      	cpsid	i
 *
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 8000796:	4d06      	ldr	r5, [pc, #24]	; (80007b0 <chSysHalt+0x20>)
 8000798:	8f2b      	ldrh	r3, [r5, #56]	; 0x38
 800079a:	075b      	lsls	r3, r3, #29
 800079c:	d501      	bpl.n	80007a2 <chSysHalt+0x12>
  ch.dbg.panic_msg = reason;
 800079e:	62ec      	str	r4, [r5, #44]	; 0x2c
  while (true) {
 80007a0:	e7fe      	b.n	80007a0 <chSysHalt+0x10>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 80007a2:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 80007a4:	2204      	movs	r2, #4
    ch.dbg.trace_buffer.ptr->state         = 0;
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 80007a6:	6098      	str	r0, [r3, #8]
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 80007a8:	701a      	strb	r2, [r3, #0]
    trace_next();
 80007aa:	f7ff ff81 	bl	80006b0 <trace_next>
 80007ae:	e7f6      	b.n	800079e <chSysHalt+0xe>
 80007b0:	20000e84 	.word	0x20000e84
	...

080007c0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 80007c0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80007c2:	4b05      	ldr	r3, [pc, #20]	; (80007d8 <chDbgCheckClassS+0x18>)
 80007c4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80007c6:	b91a      	cbnz	r2, 80007d0 <chDbgCheckClassS+0x10>
 80007c8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80007ca:	2b00      	cmp	r3, #0
 80007cc:	dd00      	ble.n	80007d0 <chDbgCheckClassS+0x10>
    chSysHalt("SV#11");
  }
}
 80007ce:	bd08      	pop	{r3, pc}
    chSysHalt("SV#11");
 80007d0:	4802      	ldr	r0, [pc, #8]	; (80007dc <chDbgCheckClassS+0x1c>)
 80007d2:	f7ff ffdd 	bl	8000790 <chSysHalt>
 80007d6:	bf00      	nop
 80007d8:	20000e84 	.word	0x20000e84
 80007dc:	08004ca4 	.word	0x08004ca4

080007e0 <chDbgCheckClassI>:
void chDbgCheckClassI(void) {
 80007e0:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80007e2:	4b05      	ldr	r3, [pc, #20]	; (80007f8 <chDbgCheckClassI+0x18>)
 80007e4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80007e6:	2a00      	cmp	r2, #0
 80007e8:	db03      	blt.n	80007f2 <chDbgCheckClassI+0x12>
 80007ea:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80007ec:	2b00      	cmp	r3, #0
 80007ee:	dd00      	ble.n	80007f2 <chDbgCheckClassI+0x12>
}
 80007f0:	bd08      	pop	{r3, pc}
    chSysHalt("SV#10");
 80007f2:	4802      	ldr	r0, [pc, #8]	; (80007fc <chDbgCheckClassI+0x1c>)
 80007f4:	f7ff ffcc 	bl	8000790 <chSysHalt>
 80007f8:	20000e84 	.word	0x20000e84
 80007fc:	08004cac 	.word	0x08004cac

08000800 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 8000800:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000802:	460d      	mov	r5, r1
 8000804:	4604      	mov	r4, r0
 8000806:	4616      	mov	r6, r2
  uint8_t *p, *prev;

  chDbgCheckClassI();
 8000808:	f7ff ffea 	bl	80007e0 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 800080c:	b185      	cbz	r5, 8000830 <chCoreAllocFromTopI+0x30>
 800080e:	1e6b      	subs	r3, r5, #1
 8000810:	ea13 0705 	ands.w	r7, r3, r5
 8000814:	d10c      	bne.n	8000830 <chCoreAllocFromTopI+0x30>

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000816:	4909      	ldr	r1, [pc, #36]	; (800083c <chCoreAllocFromTopI+0x3c>)
  prev = p - offset;

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8000818:	e9d1 2300 	ldrd	r2, r3, [r1]
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 800081c:	426d      	negs	r5, r5
 800081e:	1b18      	subs	r0, r3, r4
 8000820:	4028      	ands	r0, r5
  prev = p - offset;
 8000822:	1b86      	subs	r6, r0, r6
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8000824:	42b2      	cmp	r2, r6
 8000826:	d806      	bhi.n	8000836 <chCoreAllocFromTopI+0x36>
 8000828:	42b3      	cmp	r3, r6
 800082a:	d304      	bcc.n	8000836 <chCoreAllocFromTopI+0x36>
    return NULL;
  }

  ch_memcore.topmem = prev;
 800082c:	604e      	str	r6, [r1, #4]

  return p;
}
 800082e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8000830:	4803      	ldr	r0, [pc, #12]	; (8000840 <chCoreAllocFromTopI+0x40>)
 8000832:	f7ff ffad 	bl	8000790 <chSysHalt>
    return NULL;
 8000836:	4638      	mov	r0, r7
}
 8000838:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800083a:	bf00      	nop
 800083c:	200018b8 	.word	0x200018b8
 8000840:	08005100 	.word	0x08005100
	...

08000850 <chCoreAllocAlignedI>:
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8000850:	2200      	movs	r2, #0
 8000852:	f7ff bfd5 	b.w	8000800 <chCoreAllocFromTopI>
 8000856:	bf00      	nop
	...

08000860 <chSchReadyAheadI>:
thread_t *chSchReadyAheadI(thread_t *tp) {
 8000860:	b510      	push	{r4, lr}
 8000862:	4604      	mov	r4, r0
  chDbgCheckClassI();
 8000864:	f7ff ffbc 	bl	80007e0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8000868:	b1a4      	cbz	r4, 8000894 <chSchReadyAheadI+0x34>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800086a:	f894 3020 	ldrb.w	r3, [r4, #32]
 800086e:	b18b      	cbz	r3, 8000894 <chSchReadyAheadI+0x34>
 8000870:	2b0f      	cmp	r3, #15
 8000872:	d00f      	beq.n	8000894 <chSchReadyAheadI+0x34>
  tp->state = CH_STATE_READY;
 8000874:	2200      	movs	r2, #0
  } while (cp->prio > tp->prio);
 8000876:	68a1      	ldr	r1, [r4, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8000878:	4b08      	ldr	r3, [pc, #32]	; (800089c <chSchReadyAheadI+0x3c>)
  tp->state = CH_STATE_READY;
 800087a:	f884 2020 	strb.w	r2, [r4, #32]
    cp = cp->queue.next;
 800087e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8000880:	689a      	ldr	r2, [r3, #8]
 8000882:	428a      	cmp	r2, r1
 8000884:	d8fb      	bhi.n	800087e <chSchReadyAheadI+0x1e>
  tp->queue.prev             = cp->queue.prev;
 8000886:	685a      	ldr	r2, [r3, #4]
}
 8000888:	4620      	mov	r0, r4
  tp->queue.prev             = cp->queue.prev;
 800088a:	e9c4 3200 	strd	r3, r2, [r4]
  tp->queue.prev->queue.next = tp;
 800088e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8000890:	605c      	str	r4, [r3, #4]
}
 8000892:	bd10      	pop	{r4, pc}
  chDbgCheck(tp != NULL);
 8000894:	4802      	ldr	r0, [pc, #8]	; (80008a0 <chSchReadyAheadI+0x40>)
 8000896:	f7ff ff7b 	bl	8000790 <chSysHalt>
 800089a:	bf00      	nop
 800089c:	20000e84 	.word	0x20000e84
 80008a0:	080050e0 	.word	0x080050e0
	...

080008b0 <chSchReadyI>:
thread_t *chSchReadyI(thread_t *tp) {
 80008b0:	b510      	push	{r4, lr}
 80008b2:	4604      	mov	r4, r0
  chDbgCheckClassI();
 80008b4:	f7ff ff94 	bl	80007e0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 80008b8:	b1a4      	cbz	r4, 80008e4 <chSchReadyI+0x34>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 80008ba:	f894 3020 	ldrb.w	r3, [r4, #32]
 80008be:	b18b      	cbz	r3, 80008e4 <chSchReadyI+0x34>
 80008c0:	2b0f      	cmp	r3, #15
 80008c2:	d00f      	beq.n	80008e4 <chSchReadyI+0x34>
  tp->state = CH_STATE_READY;
 80008c4:	2200      	movs	r2, #0
  } while (cp->prio >= tp->prio);
 80008c6:	68a1      	ldr	r1, [r4, #8]
  cp = (thread_t *)&ch.rlist.queue;
 80008c8:	4b08      	ldr	r3, [pc, #32]	; (80008ec <chSchReadyI+0x3c>)
  tp->state = CH_STATE_READY;
 80008ca:	f884 2020 	strb.w	r2, [r4, #32]
    cp = cp->queue.next;
 80008ce:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80008d0:	689a      	ldr	r2, [r3, #8]
 80008d2:	428a      	cmp	r2, r1
 80008d4:	d2fb      	bcs.n	80008ce <chSchReadyI+0x1e>
  tp->queue.prev             = cp->queue.prev;
 80008d6:	685a      	ldr	r2, [r3, #4]
}
 80008d8:	4620      	mov	r0, r4
  tp->queue.prev             = cp->queue.prev;
 80008da:	e9c4 3200 	strd	r3, r2, [r4]
  tp->queue.prev->queue.next = tp;
 80008de:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 80008e0:	605c      	str	r4, [r3, #4]
}
 80008e2:	bd10      	pop	{r4, pc}
  chDbgCheck(tp != NULL);
 80008e4:	4802      	ldr	r0, [pc, #8]	; (80008f0 <chSchReadyI+0x40>)
 80008e6:	f7ff ff53 	bl	8000790 <chSysHalt>
 80008ea:	bf00      	nop
 80008ec:	20000e84 	.word	0x20000e84
 80008f0:	080050c8 	.word	0x080050c8
	...

08000900 <chThdDequeueNextI.constprop.0>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8000900:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8000902:	6803      	ldr	r3, [r0, #0]

  if (queue_notempty(tqp)) {
 8000904:	4298      	cmp	r0, r3
 8000906:	d010      	beq.n	800092a <chThdDequeueNextI.constprop.0+0x2a>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000908:	681a      	ldr	r2, [r3, #0]
 800090a:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800090c:	6050      	str	r0, [r2, #4]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 800090e:	f893 2020 	ldrb.w	r2, [r3, #32]
 8000912:	2a04      	cmp	r2, #4
 8000914:	d106      	bne.n	8000924 <chThdDequeueNextI.constprop.0+0x24>

  tp->u.rdymsg = msg;
 8000916:	2200      	movs	r2, #0
 8000918:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800091a:	4618      	mov	r0, r3
    chThdDoDequeueNextI(tqp, msg);
  }
}
 800091c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8000920:	f7ff bfc6 	b.w	80008b0 <chSchReadyI>
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8000924:	4801      	ldr	r0, [pc, #4]	; (800092c <chThdDequeueNextI.constprop.0+0x2c>)
 8000926:	f7ff ff33 	bl	8000790 <chSysHalt>
 800092a:	bd08      	pop	{r3, pc}
 800092c:	08005084 	.word	0x08005084

08000930 <chThdDequeueAllI.constprop.0>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8000930:	b538      	push	{r3, r4, r5, lr}
 8000932:	4604      	mov	r4, r0
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000934:	6800      	ldr	r0, [r0, #0]

  while (queue_notempty(tqp)) {
 8000936:	4284      	cmp	r4, r0
 8000938:	d011      	beq.n	800095e <chThdDequeueAllI.constprop.0+0x2e>
  tp->u.rdymsg = msg;
 800093a:	f06f 0501 	mvn.w	r5, #1
  tqp->next             = tp->queue.next;
 800093e:	6803      	ldr	r3, [r0, #0]
 8000940:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000942:	605c      	str	r4, [r3, #4]
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8000944:	f890 3020 	ldrb.w	r3, [r0, #32]
 8000948:	2b04      	cmp	r3, #4
 800094a:	d002      	beq.n	8000952 <chThdDequeueAllI.constprop.0+0x22>
 800094c:	4804      	ldr	r0, [pc, #16]	; (8000960 <chThdDequeueAllI.constprop.0+0x30>)
 800094e:	f7ff ff1f 	bl	8000790 <chSysHalt>
  tp->u.rdymsg = msg;
 8000952:	6245      	str	r5, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000954:	f7ff ffac 	bl	80008b0 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000958:	6820      	ldr	r0, [r4, #0]
 800095a:	4284      	cmp	r4, r0
 800095c:	d1ef      	bne.n	800093e <chThdDequeueAllI.constprop.0+0xe>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 800095e:	bd38      	pop	{r3, r4, r5, pc}
 8000960:	08005084 	.word	0x08005084
	...

08000970 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000970:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8000974:	4607      	mov	r7, r0
 8000976:	460e      	mov	r6, r1
  event_listener_t *elp;

  chDbgCheckClassI();
 8000978:	f7ff ff32 	bl	80007e0 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);

  elp = esp->next;
 800097c:	683c      	ldr	r4, [r7, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800097e:	42a7      	cmp	r7, r4
 8000980:	d01a      	beq.n	80009b8 <chEvtBroadcastFlagsI+0x48>
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8000982:	f04f 0800 	mov.w	r8, #0
    elp->flags |= flags;
 8000986:	68e3      	ldr	r3, [r4, #12]
 8000988:	4333      	orrs	r3, r6
 800098a:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 800098c:	b116      	cbz	r6, 8000994 <chEvtBroadcastFlagsI+0x24>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 800098e:	6923      	ldr	r3, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 8000990:	421e      	tst	r6, r3
 8000992:	d00e      	beq.n	80009b2 <chEvtBroadcastFlagsI+0x42>
      chEvtSignalI(elp->listener, elp->events);
 8000994:	e9d4 5901 	ldrd	r5, r9, [r4, #4]
  chDbgCheckClassI();
 8000998:	f7ff ff22 	bl	80007e0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800099c:	b30d      	cbz	r5, 80009e2 <chEvtBroadcastFlagsI+0x72>
  tp->epending |= events;
 800099e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 80009a0:	f895 2020 	ldrb.w	r2, [r5, #32]
  tp->epending |= events;
 80009a4:	ea49 0303 	orr.w	r3, r9, r3
  if (((tp->state == CH_STATE_WTOREVT) &&
 80009a8:	2a0a      	cmp	r2, #10
  tp->epending |= events;
 80009aa:	636b      	str	r3, [r5, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 80009ac:	d006      	beq.n	80009bc <chEvtBroadcastFlagsI+0x4c>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80009ae:	2a0b      	cmp	r2, #11
 80009b0:	d00d      	beq.n	80009ce <chEvtBroadcastFlagsI+0x5e>
    elp = elp->next;
 80009b2:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80009b4:	42a7      	cmp	r7, r4
 80009b6:	d1e6      	bne.n	8000986 <chEvtBroadcastFlagsI+0x16>
}
 80009b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80009bc:	6a6a      	ldr	r2, [r5, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
 80009be:	4213      	tst	r3, r2
 80009c0:	d0f7      	beq.n	80009b2 <chEvtBroadcastFlagsI+0x42>
    tp->u.rdymsg = MSG_OK;
 80009c2:	f8c5 8024 	str.w	r8, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 80009c6:	4628      	mov	r0, r5
 80009c8:	f7ff ff72 	bl	80008b0 <chSchReadyI>
 80009cc:	e7f1      	b.n	80009b2 <chEvtBroadcastFlagsI+0x42>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 80009ce:	6a6a      	ldr	r2, [r5, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 80009d0:	ea32 0303 	bics.w	r3, r2, r3
 80009d4:	d1ed      	bne.n	80009b2 <chEvtBroadcastFlagsI+0x42>
    tp->u.rdymsg = MSG_OK;
 80009d6:	f8c5 8024 	str.w	r8, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 80009da:	4628      	mov	r0, r5
 80009dc:	f7ff ff68 	bl	80008b0 <chSchReadyI>
 80009e0:	e7e7      	b.n	80009b2 <chEvtBroadcastFlagsI+0x42>
  chDbgCheck(tp != NULL);
 80009e2:	4801      	ldr	r0, [pc, #4]	; (80009e8 <chEvtBroadcastFlagsI+0x78>)
 80009e4:	f7ff fed4 	bl	8000790 <chSysHalt>
 80009e8:	08005174 	.word	0x08005174
 80009ec:	00000000 	.word	0x00000000

080009f0 <_dbg_check_leave_isr>:
void _dbg_check_leave_isr(void) {
 80009f0:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80009f2:	2320      	movs	r3, #32
 80009f4:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80009f8:	4a06      	ldr	r2, [pc, #24]	; (8000a14 <_dbg_check_leave_isr+0x24>)
 80009fa:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80009fc:	2b00      	cmp	r3, #0
 80009fe:	dd01      	ble.n	8000a04 <_dbg_check_leave_isr+0x14>
 8000a00:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8000a02:	b111      	cbz	r1, 8000a0a <_dbg_check_leave_isr+0x1a>
    chSysHalt("SV#9");
 8000a04:	4804      	ldr	r0, [pc, #16]	; (8000a18 <_dbg_check_leave_isr+0x28>)
 8000a06:	f7ff fec3 	bl	8000790 <chSysHalt>
  ch.dbg.isr_cnt--;
 8000a0a:	3b01      	subs	r3, #1
 8000a0c:	6313      	str	r3, [r2, #48]	; 0x30
 8000a0e:	f381 8811 	msr	BASEPRI, r1
}
 8000a12:	bd08      	pop	{r3, pc}
 8000a14:	20000e84 	.word	0x20000e84
 8000a18:	08004cb4 	.word	0x08004cb4
 8000a1c:	00000000 	.word	0x00000000

08000a20 <_dbg_check_enter_isr>:
void _dbg_check_enter_isr(void) {
 8000a20:	b508      	push	{r3, lr}
 8000a22:	2320      	movs	r3, #32
 8000a24:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000a28:	4a06      	ldr	r2, [pc, #24]	; (8000a44 <_dbg_check_enter_isr+0x24>)
 8000a2a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8000a2c:	2b00      	cmp	r3, #0
 8000a2e:	db01      	blt.n	8000a34 <_dbg_check_enter_isr+0x14>
 8000a30:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8000a32:	b111      	cbz	r1, 8000a3a <_dbg_check_enter_isr+0x1a>
    chSysHalt("SV#8");
 8000a34:	4804      	ldr	r0, [pc, #16]	; (8000a48 <_dbg_check_enter_isr+0x28>)
 8000a36:	f7ff feab 	bl	8000790 <chSysHalt>
  ch.dbg.isr_cnt++;
 8000a3a:	3301      	adds	r3, #1
 8000a3c:	6313      	str	r3, [r2, #48]	; 0x30
 8000a3e:	f381 8811 	msr	BASEPRI, r1
}
 8000a42:	bd08      	pop	{r3, pc}
 8000a44:	20000e84 	.word	0x20000e84
 8000a48:	08004cbc 	.word	0x08004cbc
 8000a4c:	00000000 	.word	0x00000000

08000a50 <_dbg_check_unlock_from_isr>:
void _dbg_check_unlock_from_isr(void) {
 8000a50:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000a52:	4b06      	ldr	r3, [pc, #24]	; (8000a6c <_dbg_check_unlock_from_isr+0x1c>)
 8000a54:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000a56:	2a00      	cmp	r2, #0
 8000a58:	dd05      	ble.n	8000a66 <_dbg_check_unlock_from_isr+0x16>
 8000a5a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000a5c:	2a00      	cmp	r2, #0
 8000a5e:	dd02      	ble.n	8000a66 <_dbg_check_unlock_from_isr+0x16>
  _dbg_leave_lock();
 8000a60:	2200      	movs	r2, #0
 8000a62:	635a      	str	r2, [r3, #52]	; 0x34
}
 8000a64:	bd08      	pop	{r3, pc}
    chSysHalt("SV#7");
 8000a66:	4802      	ldr	r0, [pc, #8]	; (8000a70 <_dbg_check_unlock_from_isr+0x20>)
 8000a68:	f7ff fe92 	bl	8000790 <chSysHalt>
 8000a6c:	20000e84 	.word	0x20000e84
 8000a70:	08004cc4 	.word	0x08004cc4
	...

08000a80 <_dbg_check_lock_from_isr>:
void _dbg_check_lock_from_isr(void) {
 8000a80:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000a82:	4b06      	ldr	r3, [pc, #24]	; (8000a9c <_dbg_check_lock_from_isr+0x1c>)
 8000a84:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000a86:	2a00      	cmp	r2, #0
 8000a88:	dd01      	ble.n	8000a8e <_dbg_check_lock_from_isr+0xe>
 8000a8a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000a8c:	b112      	cbz	r2, 8000a94 <_dbg_check_lock_from_isr+0x14>
    chSysHalt("SV#6");
 8000a8e:	4804      	ldr	r0, [pc, #16]	; (8000aa0 <_dbg_check_lock_from_isr+0x20>)
 8000a90:	f7ff fe7e 	bl	8000790 <chSysHalt>
  _dbg_enter_lock();
 8000a94:	2201      	movs	r2, #1
 8000a96:	635a      	str	r2, [r3, #52]	; 0x34
}
 8000a98:	bd08      	pop	{r3, pc}
 8000a9a:	bf00      	nop
 8000a9c:	20000e84 	.word	0x20000e84
 8000aa0:	08004ccc 	.word	0x08004ccc
	...

08000ab0 <wakeup>:
static void wakeup(void *p) {
 8000ab0:	b538      	push	{r3, r4, r5, lr}
 8000ab2:	4604      	mov	r4, r0
 8000ab4:	2320      	movs	r3, #32
 8000ab6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000aba:	f7ff ffe1 	bl	8000a80 <_dbg_check_lock_from_isr>
  switch (tp->state) {
 8000abe:	f894 3020 	ldrb.w	r3, [r4, #32]
 8000ac2:	2b07      	cmp	r3, #7
 8000ac4:	d80f      	bhi.n	8000ae6 <wakeup+0x36>
 8000ac6:	e8df f003 	tbb	[pc, r3]
 8000aca:	0e14      	.short	0x0e14
 8000acc:	040a1a0e 	.word	0x040a1a0e
 8000ad0:	0a0e      	.short	0x0a0e
    chSemFastSignalI(tp->u.wtsemp);
 8000ad2:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 8000ad4:	f7ff fe84 	bl	80007e0 <chDbgCheckClassI>

  sp->cnt++;
 8000ad8:	68ab      	ldr	r3, [r5, #8]
 8000ada:	3301      	adds	r3, #1
 8000adc:	60ab      	str	r3, [r5, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000ade:	e9d4 3200 	ldrd	r3, r2, [r4]
 8000ae2:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000ae4:	605a      	str	r2, [r3, #4]
  tp->u.rdymsg = MSG_TIMEOUT;
 8000ae6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000aea:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000aec:	4620      	mov	r0, r4
 8000aee:	f7ff fedf 	bl	80008b0 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000af2:	f7ff ffad 	bl	8000a50 <_dbg_check_unlock_from_isr>
 8000af6:	2300      	movs	r3, #0
 8000af8:	f383 8811 	msr	BASEPRI, r3
}
 8000afc:	bd38      	pop	{r3, r4, r5, pc}
    *tp->u.wttrp = NULL;
 8000afe:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000b00:	2200      	movs	r2, #0
 8000b02:	601a      	str	r2, [r3, #0]
    break;
 8000b04:	e7ef      	b.n	8000ae6 <wakeup+0x36>
 8000b06:	bf00      	nop
	...

08000b10 <_idle_thread>:
}
 8000b10:	e7fe      	b.n	8000b10 <_idle_thread>
 8000b12:	bf00      	nop
	...

08000b20 <usb_lld_start_in>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8000b20:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8000b24:	b430      	push	{r4, r5}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8000b26:	68dc      	ldr	r4, [r3, #12]
 8000b28:	6962      	ldr	r2, [r4, #20]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 8000b2a:	6813      	ldr	r3, [r2, #0]
 8000b2c:	60d3      	str	r3, [r2, #12]
  if (isp->txsize == 0) {
 8000b2e:	b9f3      	cbnz	r3, 8000b6e <usb_lld_start_in+0x4e>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8000b30:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 8000b32:	eb02 1341 	add.w	r3, r2, r1, lsl #5
 8000b36:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8000b3a:	f8c3 0910 	str.w	r0, [r3, #2320]	; 0x910
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8000b3e:	6823      	ldr	r3, [r4, #0]
 8000b40:	f003 0303 	and.w	r3, r3, #3
 8000b44:	2b01      	cmp	r3, #1
 8000b46:	d02a      	beq.n	8000b9e <usb_lld_start_in+0x7e>
 8000b48:	b208      	sxth	r0, r1
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8000b4a:	eb02 1040 	add.w	r0, r2, r0, lsl #5
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8000b4e:	2301      	movs	r3, #1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8000b50:	f8d0 4900 	ldr.w	r4, [r0, #2304]	; 0x900
 8000b54:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 8000b58:	f8c0 4900 	str.w	r4, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8000b5c:	f8d2 0834 	ldr.w	r0, [r2, #2100]	; 0x834
 8000b60:	fa03 f101 	lsl.w	r1, r3, r1
 8000b64:	4301      	orrs	r1, r0
}
 8000b66:	bc30      	pop	{r4, r5}
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8000b68:	f8c2 1834 	str.w	r1, [r2, #2100]	; 0x834
}
 8000b6c:	4770      	bx	lr
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8000b6e:	b919      	cbnz	r1, 8000b78 <usb_lld_start_in+0x58>
 8000b70:	2b40      	cmp	r3, #64	; 0x40
      isp->txsize = EP0_MAX_INSIZE;
 8000b72:	bf84      	itt	hi
 8000b74:	2340      	movhi	r3, #64	; 0x40
 8000b76:	6013      	strhi	r3, [r2, #0]
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8000b78:	8a25      	ldrh	r5, [r4, #16]
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8000b7a:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8000b7c:	1e68      	subs	r0, r5, #1
 8000b7e:	4418      	add	r0, r3
 8000b80:	fbb0 f0f5 	udiv	r0, r0, r5
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8000b84:	eb02 1541 	add.w	r5, r2, r1, lsl #5
 8000b88:	ea43 43c0 	orr.w	r3, r3, r0, lsl #19
 8000b8c:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8000b90:	f8c5 3910 	str.w	r3, [r5, #2320]	; 0x910
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8000b94:	6823      	ldr	r3, [r4, #0]
 8000b96:	f003 0303 	and.w	r3, r3, #3
 8000b9a:	2b01      	cmp	r3, #1
 8000b9c:	d1d4      	bne.n	8000b48 <usb_lld_start_in+0x28>
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8000b9e:	f8d2 3808 	ldr.w	r3, [r2, #2056]	; 0x808
 8000ba2:	f413 7f80 	tst.w	r3, #256	; 0x100
 8000ba6:	eb02 1341 	add.w	r3, r2, r1, lsl #5
 8000baa:	b208      	sxth	r0, r1
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8000bac:	f8d3 4900 	ldr.w	r4, [r3, #2304]	; 0x900
 8000bb0:	bf14      	ite	ne
 8000bb2:	f044 5480 	orrne.w	r4, r4, #268435456	; 0x10000000
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 8000bb6:	f044 5400 	orreq.w	r4, r4, #536870912	; 0x20000000
 8000bba:	f8c3 4900 	str.w	r4, [r3, #2304]	; 0x900
 8000bbe:	e7c4      	b.n	8000b4a <usb_lld_start_in+0x2a>

08000bc0 <usb_lld_start_out>:
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8000bc0:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8000bc4:	b430      	push	{r4, r5}
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8000bc6:	68dd      	ldr	r5, [r3, #12]
 8000bc8:	69ab      	ldr	r3, [r5, #24]
  osp->totsize = osp->rxsize;
 8000bca:	681c      	ldr	r4, [r3, #0]
 8000bcc:	60dc      	str	r4, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8000bce:	b919      	cbnz	r1, 8000bd8 <usb_lld_start_out+0x18>
 8000bd0:	2c40      	cmp	r4, #64	; 0x40
      osp->rxsize = EP0_MAX_OUTSIZE;
 8000bd2:	bf84      	itt	hi
 8000bd4:	2440      	movhi	r4, #64	; 0x40
 8000bd6:	601c      	strhi	r4, [r3, #0]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8000bd8:	8a6b      	ldrh	r3, [r5, #18]
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8000bda:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8000bdc:	682d      	ldr	r5, [r5, #0]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8000bde:	1e5a      	subs	r2, r3, #1
 8000be0:	4422      	add	r2, r4
 8000be2:	fbb2 f2f3 	udiv	r2, r2, r3
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 8000be6:	fb02 f303 	mul.w	r3, r2, r3
 8000bea:	3303      	adds	r3, #3
 8000bec:	f023 0303 	bic.w	r3, r3, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8000bf0:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 8000bf4:	eb00 1441 	add.w	r4, r0, r1, lsl #5
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8000bf8:	f005 0203 	and.w	r2, r5, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8000bfc:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8000c00:	2a01      	cmp	r2, #1
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8000c02:	f8c4 3b10 	str.w	r3, [r4, #2832]	; 0xb10
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8000c06:	d00a      	beq.n	8000c1e <usb_lld_start_out+0x5e>
 8000c08:	b209      	sxth	r1, r1
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8000c0a:	eb00 1141 	add.w	r1, r0, r1, lsl #5
}
 8000c0e:	bc30      	pop	{r4, r5}
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8000c10:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 8000c14:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8000c18:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
 8000c1c:	4770      	bx	lr
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8000c1e:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8000c22:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 8000c26:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 8000c2a:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8000c2e:	bf14      	ite	ne
 8000c30:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 8000c34:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
 8000c38:	b209      	sxth	r1, r1
 8000c3a:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 8000c3e:	e7e4      	b.n	8000c0a <usb_lld_start_out+0x4a>

08000c40 <otg_epout_handler>:
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8000c40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8000c44:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8000c46:	eb06 1341 	add.w	r3, r6, r1, lsl #5
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8000c4a:	4607      	mov	r7, r0
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8000c4c:	f8d3 5b08 	ldr.w	r5, [r3, #2824]	; 0xb08
  otgp->oe[ep].DOEPINT = epint;
 8000c50:	f8c3 5b08 	str.w	r5, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8000c54:	072a      	lsls	r2, r5, #28
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8000c56:	460c      	mov	r4, r1
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8000c58:	d503      	bpl.n	8000c62 <otg_epout_handler+0x22>
 8000c5a:	f8d6 3814 	ldr.w	r3, [r6, #2068]	; 0x814
 8000c5e:	071b      	lsls	r3, r3, #28
 8000c60:	d435      	bmi.n	8000cce <otg_epout_handler+0x8e>
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8000c62:	07ea      	lsls	r2, r5, #31
 8000c64:	d531      	bpl.n	8000cca <otg_epout_handler+0x8a>
 8000c66:	f8d6 3814 	ldr.w	r3, [r6, #2068]	; 0x814
 8000c6a:	07db      	lsls	r3, r3, #31
 8000c6c:	d52d      	bpl.n	8000cca <otg_epout_handler+0x8a>
    osp = usbp->epc[ep]->out_state;
 8000c6e:	eb07 0384 	add.w	r3, r7, r4, lsl #2
 8000c72:	68d9      	ldr	r1, [r3, #12]
    if (ep == 0) {
 8000c74:	b95c      	cbnz	r4, 8000c8e <otg_epout_handler+0x4e>
    osp = usbp->epc[ep]->out_state;
 8000c76:	698a      	ldr	r2, [r1, #24]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8000c78:	8a48      	ldrh	r0, [r1, #18]
 8000c7a:	6855      	ldr	r5, [r2, #4]
 8000c7c:	fbb5 f3f0 	udiv	r3, r5, r0
 8000c80:	fb00 5313 	mls	r3, r0, r3, r5
 8000c84:	b91b      	cbnz	r3, 8000c8e <otg_epout_handler+0x4e>
          (osp->rxsize < osp->totsize)) {
 8000c86:	6810      	ldr	r0, [r2, #0]
 8000c88:	68d3      	ldr	r3, [r2, #12]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8000c8a:	4298      	cmp	r0, r3
 8000c8c:	d30d      	bcc.n	8000caa <otg_epout_handler+0x6a>
    _usb_isr_invoke_out_cb(usbp, ep);
 8000c8e:	897b      	ldrh	r3, [r7, #10]
 8000c90:	68cd      	ldr	r5, [r1, #12]
 8000c92:	2201      	movs	r2, #1
 8000c94:	40a2      	lsls	r2, r4
 8000c96:	ea23 0302 	bic.w	r3, r3, r2
 8000c9a:	817b      	strh	r3, [r7, #10]
 8000c9c:	b1ad      	cbz	r5, 8000cca <otg_epout_handler+0x8a>
 8000c9e:	4621      	mov	r1, r4
 8000ca0:	4638      	mov	r0, r7
 8000ca2:	462b      	mov	r3, r5
}
 8000ca4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _usb_isr_invoke_out_cb(usbp, ep);
 8000ca8:	4718      	bx	r3
        osp->rxsize = osp->totsize - osp->rxsize;
 8000caa:	1a1b      	subs	r3, r3, r0
        osp->rxcnt  = 0;
 8000cac:	e9c2 3400 	strd	r3, r4, [r2]
 8000cb0:	2320      	movs	r3, #32
 8000cb2:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8000cb6:	f7ff fee3 	bl	8000a80 <_dbg_check_lock_from_isr>
        usb_lld_start_out(usbp, ep);
 8000cba:	4621      	mov	r1, r4
 8000cbc:	4638      	mov	r0, r7
 8000cbe:	f7ff ff7f 	bl	8000bc0 <usb_lld_start_out>
  _dbg_check_unlock_from_isr();
 8000cc2:	f7ff fec5 	bl	8000a50 <_dbg_check_unlock_from_isr>
 8000cc6:	f384 8811 	msr	BASEPRI, r4
}
 8000cca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    _usb_isr_invoke_setup_cb(usbp, ep);
 8000cce:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8000cd2:	68db      	ldr	r3, [r3, #12]
 8000cd4:	685b      	ldr	r3, [r3, #4]
 8000cd6:	4798      	blx	r3
 8000cd8:	e7c3      	b.n	8000c62 <otg_epout_handler+0x22>
 8000cda:	bf00      	nop
 8000cdc:	0000      	movs	r0, r0
	...

08000ce0 <otg_txfifo_handler>:
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000ce0:	eb00 0381 	add.w	r3, r0, r1, lsl #2
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 8000ce4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000ce8:	68da      	ldr	r2, [r3, #12]
 8000cea:	f8d0 e06c 	ldr.w	lr, [r0, #108]	; 0x6c
 8000cee:	6956      	ldr	r6, [r2, #20]
 8000cf0:	e9d6 4300 	ldrd	r4, r3, [r6]
 8000cf4:	42a3      	cmp	r3, r4
 8000cf6:	d22c      	bcs.n	8000d52 <otg_txfifo_handler+0x72>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8000cf8:	1c4d      	adds	r5, r1, #1
    if (n > usbp->epc[ep]->in_maxsize)
 8000cfa:	f8b2 c010 	ldrh.w	ip, [r2, #16]
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8000cfe:	eb0e 3505 	add.w	r5, lr, r5, lsl #12
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8000d02:	eb0e 1741 	add.w	r7, lr, r1, lsl #5
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8000d06:	1ae0      	subs	r0, r4, r3
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8000d08:	f8d7 2918 	ldr.w	r2, [r7, #2328]	; 0x918
 8000d0c:	4560      	cmp	r0, ip
 8000d0e:	bf28      	it	cs
 8000d10:	4660      	movcs	r0, ip
 8000d12:	b293      	uxth	r3, r2
 8000d14:	ebb0 0f83 	cmp.w	r0, r3, lsl #2
 8000d18:	d829      	bhi.n	8000d6e <otg_txfifo_handler+0x8e>
  osalDbgAssert(n > 0, "is zero");
 8000d1a:	b328      	cbz	r0, 8000d68 <otg_txfifo_handler+0x88>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8000d1c:	f8d6 8008 	ldr.w	r8, [r6, #8]
    if (n <= 4) {
 8000d20:	2804      	cmp	r0, #4
    *fifop = *((uint32_t *)buf);
 8000d22:	f8d8 3000 	ldr.w	r3, [r8]
 8000d26:	602b      	str	r3, [r5, #0]
    if (n <= 4) {
 8000d28:	d90a      	bls.n	8000d40 <otg_txfifo_handler+0x60>
 8000d2a:	1f44      	subs	r4, r0, #5
 8000d2c:	f024 0403 	bic.w	r4, r4, #3
 8000d30:	3404      	adds	r4, #4
 8000d32:	4444      	add	r4, r8
 8000d34:	4643      	mov	r3, r8
    *fifop = *((uint32_t *)buf);
 8000d36:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8000d3a:	602a      	str	r2, [r5, #0]
    if (n <= 4) {
 8000d3c:	429c      	cmp	r4, r3
 8000d3e:	d1fa      	bne.n	8000d36 <otg_txfifo_handler+0x56>
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000d40:	e9d6 4300 	ldrd	r4, r3, [r6]
    usbp->epc[ep]->in_state->txcnt += n;
 8000d44:	4403      	add	r3, r0
    usbp->epc[ep]->in_state->txbuf += n;
 8000d46:	eb08 0200 	add.w	r2, r8, r0
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000d4a:	429c      	cmp	r4, r3
    usbp->epc[ep]->in_state->txcnt += n;
 8000d4c:	e9c6 3201 	strd	r3, r2, [r6, #4]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000d50:	d8d9      	bhi.n	8000d06 <otg_txfifo_handler+0x26>
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 8000d52:	f8de 3834 	ldr.w	r3, [lr, #2100]	; 0x834
 8000d56:	2001      	movs	r0, #1
 8000d58:	fa00 f101 	lsl.w	r1, r0, r1
 8000d5c:	ea23 0301 	bic.w	r3, r3, r1
 8000d60:	f8ce 3834 	str.w	r3, [lr, #2100]	; 0x834
}
 8000d64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  osalDbgAssert(n > 0, "is zero");
 8000d68:	4802      	ldr	r0, [pc, #8]	; (8000d74 <otg_txfifo_handler+0x94>)
 8000d6a:	f7ff fd11 	bl	8000790 <chSysHalt>
      return false;
 8000d6e:	2000      	movs	r0, #0
}
 8000d70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000d74:	08004f34 	.word	0x08004f34
	...

08000d80 <otg_epin_handler>:
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8000d80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8000d84:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8000d86:	eb06 1341 	add.w	r3, r6, r1, lsl #5
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8000d8a:	4607      	mov	r7, r0
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8000d8c:	f8d3 5908 	ldr.w	r5, [r3, #2312]	; 0x908
  otgp->ie[ep].DIEPINT = epint;
 8000d90:	f8c3 5908 	str.w	r5, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8000d94:	07eb      	lsls	r3, r5, #31
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8000d96:	460c      	mov	r4, r1
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8000d98:	d503      	bpl.n	8000da2 <otg_epin_handler+0x22>
 8000d9a:	f8d6 3810 	ldr.w	r3, [r6, #2064]	; 0x810
 8000d9e:	07da      	lsls	r2, r3, #31
 8000da0:	d409      	bmi.n	8000db6 <otg_epin_handler+0x36>
  if ((epint & DIEPINT_TXFE) &&
 8000da2:	062b      	lsls	r3, r5, #24
 8000da4:	d505      	bpl.n	8000db2 <otg_epin_handler+0x32>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 8000da6:	f8d6 2834 	ldr.w	r2, [r6, #2100]	; 0x834
 8000daa:	2301      	movs	r3, #1
 8000dac:	40a3      	lsls	r3, r4
  if ((epint & DIEPINT_TXFE) &&
 8000dae:	4213      	tst	r3, r2
 8000db0:	d119      	bne.n	8000de6 <otg_epin_handler+0x66>
}
 8000db2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8000db6:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8000dba:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 8000dbe:	f8dc 3014 	ldr.w	r3, [ip, #20]
    if (isp->txsize < isp->totsize) {
 8000dc2:	f8d3 e000 	ldr.w	lr, [r3]
 8000dc6:	68da      	ldr	r2, [r3, #12]
 8000dc8:	4596      	cmp	lr, r2
 8000dca:	d312      	bcc.n	8000df2 <otg_epin_handler+0x72>
      _usb_isr_invoke_in_cb(usbp, ep);
 8000dcc:	8903      	ldrh	r3, [r0, #8]
 8000dce:	f8dc 8008 	ldr.w	r8, [ip, #8]
 8000dd2:	2201      	movs	r2, #1
 8000dd4:	408a      	lsls	r2, r1
 8000dd6:	ea23 0302 	bic.w	r3, r3, r2
 8000dda:	8103      	strh	r3, [r0, #8]
 8000ddc:	f1b8 0f00 	cmp.w	r8, #0
 8000de0:	d0df      	beq.n	8000da2 <otg_epin_handler+0x22>
 8000de2:	47c0      	blx	r8
 8000de4:	e7dd      	b.n	8000da2 <otg_epin_handler+0x22>
    otg_txfifo_handler(usbp, ep);
 8000de6:	4621      	mov	r1, r4
 8000de8:	4638      	mov	r0, r7
}
 8000dea:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    otg_txfifo_handler(usbp, ep);
 8000dee:	f7ff bf77 	b.w	8000ce0 <otg_txfifo_handler>
      isp->txsize = isp->totsize - isp->txsize;
 8000df2:	eba2 020e 	sub.w	r2, r2, lr
      isp->txcnt  = 0;
 8000df6:	f04f 0800 	mov.w	r8, #0
 8000dfa:	e9c3 2800 	strd	r2, r8, [r3]
 8000dfe:	2320      	movs	r3, #32
 8000e00:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8000e04:	f7ff fe3c 	bl	8000a80 <_dbg_check_lock_from_isr>
      usb_lld_start_in(usbp, ep);
 8000e08:	4621      	mov	r1, r4
 8000e0a:	4638      	mov	r0, r7
 8000e0c:	f7ff fe88 	bl	8000b20 <usb_lld_start_in>
  _dbg_check_unlock_from_isr();
 8000e10:	f7ff fe1e 	bl	8000a50 <_dbg_check_unlock_from_isr>
 8000e14:	f388 8811 	msr	BASEPRI, r8
 8000e18:	e7c3      	b.n	8000da2 <otg_epin_handler+0x22>
 8000e1a:	bf00      	nop
 8000e1c:	0000      	movs	r0, r0
	...

08000e20 <usb_lld_serve_interrupt>:
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 8000e20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  stm32_otg_t *otgp = usbp->otg;
 8000e24:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
  sts  = otgp->GINTSTS;
 8000e26:	6977      	ldr	r7, [r6, #20]
  sts &= otgp->GINTMSK;
 8000e28:	69b3      	ldr	r3, [r6, #24]
 8000e2a:	401f      	ands	r7, r3
  if (sts & GINTSTS_USBRST) {
 8000e2c:	f417 5880 	ands.w	r8, r7, #4096	; 0x1000
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 8000e30:	b081      	sub	sp, #4
 8000e32:	4604      	mov	r4, r0
  otgp->GINTSTS = sts;
 8000e34:	6177      	str	r7, [r6, #20]
  if (sts & GINTSTS_USBRST) {
 8000e36:	f040 8142 	bne.w	80010be <usb_lld_serve_interrupt+0x29e>
  if (sts & GINTSTS_WKUPINT) {
 8000e3a:	2f00      	cmp	r7, #0
 8000e3c:	f2c0 80d0 	blt.w	8000fe0 <usb_lld_serve_interrupt+0x1c0>
  if (sts & GINTSTS_USBSUSP) {
 8000e40:	053b      	lsls	r3, r7, #20
 8000e42:	d539      	bpl.n	8000eb8 <usb_lld_serve_interrupt+0x98>
    otg_disable_ep(usbp);
 8000e44:	e9d4 531b 	ldrd	r5, r3, [r4, #108]	; 0x6c
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8000e48:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000e4c:	f8d3 e008 	ldr.w	lr, [r3, #8]
 8000e50:	2300      	movs	r3, #0
 8000e52:	e000      	b.n	8000e56 <usb_lld_serve_interrupt+0x36>
 8000e54:	460b      	mov	r3, r1
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 8000e56:	eb05 1143 	add.w	r1, r5, r3, lsl #5
 8000e5a:	015a      	lsls	r2, r3, #5
 8000e5c:	f8d1 0900 	ldr.w	r0, [r1, #2304]	; 0x900
 8000e60:	2800      	cmp	r0, #0
 8000e62:	da05      	bge.n	8000e70 <usb_lld_serve_interrupt+0x50>
      otgp->ie[i].DIEPCTL |= DIEPCTL_EPDIS;
 8000e64:	f8d1 0900 	ldr.w	r0, [r1, #2304]	; 0x900
 8000e68:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
 8000e6c:	f8c1 0900 	str.w	r0, [r1, #2304]	; 0x900
    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
 8000e70:	f8d1 0b00 	ldr.w	r0, [r1, #2816]	; 0xb00
 8000e74:	2800      	cmp	r0, #0
 8000e76:	da05      	bge.n	8000e84 <usb_lld_serve_interrupt+0x64>
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
 8000e78:	f8d1 0b00 	ldr.w	r0, [r1, #2816]	; 0xb00
 8000e7c:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
 8000e80:	f8c1 0b00 	str.w	r0, [r1, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8000e84:	442a      	add	r2, r5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000e86:	4573      	cmp	r3, lr
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8000e88:	f8c2 c908 	str.w	ip, [r2, #2312]	; 0x908
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000e8c:	f103 0101 	add.w	r1, r3, #1
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8000e90:	f8c2 cb08 	str.w	ip, [r2, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000e94:	d1de      	bne.n	8000e54 <usb_lld_serve_interrupt+0x34>
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8000e96:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8000e9a:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 8000e9e:	7822      	ldrb	r2, [r4, #0]
 8000ea0:	f884 2068 	strb.w	r2, [r4, #104]	; 0x68
  usbp->state       = USB_SUSPENDED;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8000ea4:	6863      	ldr	r3, [r4, #4]
  usbp->state       = USB_SUSPENDED;
 8000ea6:	2205      	movs	r2, #5
 8000ea8:	7022      	strb	r2, [r4, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8000eaa:	681b      	ldr	r3, [r3, #0]
 8000eac:	b113      	cbz	r3, 8000eb4 <usb_lld_serve_interrupt+0x94>
 8000eae:	2104      	movs	r1, #4
 8000eb0:	4620      	mov	r0, r4
 8000eb2:	4798      	blx	r3

  /* Terminating all pending transactions.*/
  usbp->transmitting  = 0;
 8000eb4:	2300      	movs	r3, #0
 8000eb6:	60a3      	str	r3, [r4, #8]
  if (sts & GINTSTS_ENUMDNE) {
 8000eb8:	04bd      	lsls	r5, r7, #18
 8000eba:	d50c      	bpl.n	8000ed6 <usb_lld_serve_interrupt+0xb6>
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8000ebc:	f8d6 3808 	ldr.w	r3, [r6, #2056]	; 0x808
 8000ec0:	f013 0f06 	tst.w	r3, #6
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8000ec4:	68f3      	ldr	r3, [r6, #12]
 8000ec6:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8000eca:	bf0c      	ite	eq
 8000ecc:	f443 5310 	orreq.w	r3, r3, #9216	; 0x2400
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8000ed0:	f443 53a0 	orrne.w	r3, r3, #5120	; 0x1400
 8000ed4:	60f3      	str	r3, [r6, #12]
  if (sts & GINTSTS_SOF) {
 8000ed6:	0738      	lsls	r0, r7, #28
 8000ed8:	d434      	bmi.n	8000f44 <usb_lld_serve_interrupt+0x124>
  if (sts & GINTSTS_IISOIXFR) {
 8000eda:	02f9      	lsls	r1, r7, #11
 8000edc:	d43a      	bmi.n	8000f54 <usb_lld_serve_interrupt+0x134>
  if (sts & GINTSTS_IISOOXFR) {
 8000ede:	02ba      	lsls	r2, r7, #10
 8000ee0:	f100 80c1 	bmi.w	8001066 <usb_lld_serve_interrupt+0x246>
  if ((sts & GINTSTS_RXFLVL) != 0U) {
 8000ee4:	06fd      	lsls	r5, r7, #27
 8000ee6:	f100 8095 	bmi.w	8001014 <usb_lld_serve_interrupt+0x1f4>
  if (sts & GINTSTS_OEPINT) {
 8000eea:	0339      	lsls	r1, r7, #12
  src = otgp->DAINT;
 8000eec:	f8d6 5818 	ldr.w	r5, [r6, #2072]	; 0x818
  if (sts & GINTSTS_OEPINT) {
 8000ef0:	d511      	bpl.n	8000f16 <usb_lld_serve_interrupt+0xf6>
    if (src & (1 << 16))
 8000ef2:	03ea      	lsls	r2, r5, #15
 8000ef4:	f100 81b9 	bmi.w	800126a <usb_lld_serve_interrupt+0x44a>
    if (src & (1 << 17))
 8000ef8:	03ab      	lsls	r3, r5, #14
 8000efa:	f100 81bd 	bmi.w	8001278 <usb_lld_serve_interrupt+0x458>
    if (src & (1 << 18))
 8000efe:	036e      	lsls	r6, r5, #13
 8000f00:	f100 81c1 	bmi.w	8001286 <usb_lld_serve_interrupt+0x466>
    if (src & (1 << 19))
 8000f04:	0328      	lsls	r0, r5, #12
 8000f06:	f100 81c5 	bmi.w	8001294 <usb_lld_serve_interrupt+0x474>
    if (src & (1 << 20))
 8000f0a:	02e9      	lsls	r1, r5, #11
 8000f0c:	f100 81c9 	bmi.w	80012a2 <usb_lld_serve_interrupt+0x482>
    if (src & (1 << 21))
 8000f10:	02aa      	lsls	r2, r5, #10
 8000f12:	f100 8151 	bmi.w	80011b8 <usb_lld_serve_interrupt+0x398>
  if (sts & GINTSTS_IEPINT) {
 8000f16:	037b      	lsls	r3, r7, #13
 8000f18:	d511      	bpl.n	8000f3e <usb_lld_serve_interrupt+0x11e>
    if (src & (1 << 0))
 8000f1a:	07ef      	lsls	r7, r5, #31
 8000f1c:	f100 8184 	bmi.w	8001228 <usb_lld_serve_interrupt+0x408>
    if (src & (1 << 1))
 8000f20:	07ae      	lsls	r6, r5, #30
 8000f22:	f100 8188 	bmi.w	8001236 <usb_lld_serve_interrupt+0x416>
    if (src & (1 << 2))
 8000f26:	0768      	lsls	r0, r5, #29
 8000f28:	f100 818c 	bmi.w	8001244 <usb_lld_serve_interrupt+0x424>
    if (src & (1 << 3))
 8000f2c:	0729      	lsls	r1, r5, #28
 8000f2e:	f100 8190 	bmi.w	8001252 <usb_lld_serve_interrupt+0x432>
    if (src & (1 << 4))
 8000f32:	06ea      	lsls	r2, r5, #27
 8000f34:	f100 8194 	bmi.w	8001260 <usb_lld_serve_interrupt+0x440>
    if (src & (1 << 5))
 8000f38:	06ab      	lsls	r3, r5, #26
 8000f3a:	f100 8145 	bmi.w	80011c8 <usb_lld_serve_interrupt+0x3a8>
}
 8000f3e:	b001      	add	sp, #4
 8000f40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    _usb_isr_invoke_sof_cb(usbp);
 8000f44:	6863      	ldr	r3, [r4, #4]
 8000f46:	68db      	ldr	r3, [r3, #12]
 8000f48:	2b00      	cmp	r3, #0
 8000f4a:	d0c6      	beq.n	8000eda <usb_lld_serve_interrupt+0xba>
 8000f4c:	4620      	mov	r0, r4
 8000f4e:	4798      	blx	r3
  if (sts & GINTSTS_IISOIXFR) {
 8000f50:	02f9      	lsls	r1, r7, #11
 8000f52:	d5c4      	bpl.n	8000ede <usb_lld_serve_interrupt+0xbe>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8000f54:	2100      	movs	r1, #0
  stm32_otg_t *otgp = usbp->otg;
 8000f56:	f8d4 a06c 	ldr.w	sl, [r4, #108]	; 0x6c
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8000f5a:	460d      	mov	r5, r1
      _usb_isr_invoke_in_cb(usbp, ep);
 8000f5c:	f04f 0901 	mov.w	r9, #1
 8000f60:	e006      	b.n	8000f70 <usb_lld_serve_interrupt+0x150>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8000f62:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8000f64:	3501      	adds	r5, #1
 8000f66:	689b      	ldr	r3, [r3, #8]
 8000f68:	b2ed      	uxtb	r5, r5
 8000f6a:	429d      	cmp	r5, r3
 8000f6c:	4629      	mov	r1, r5
 8000f6e:	d8b6      	bhi.n	8000ede <usb_lld_serve_interrupt+0xbe>
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8000f70:	eb0a 1245 	add.w	r2, sl, r5, lsl #5
 8000f74:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 8000f78:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8000f7c:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8000f80:	d1ef      	bne.n	8000f62 <usb_lld_serve_interrupt+0x142>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 8000f82:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8000f86:	2b00      	cmp	r3, #0
 8000f88:	daeb      	bge.n	8000f62 <usb_lld_serve_interrupt+0x142>
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 8000f8a:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 8000f8e:	f043 4390 	orr.w	r3, r3, #1207959552	; 0x48000000
 8000f92:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 8000f96:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 8000f9a:	2b00      	cmp	r3, #0
 8000f9c:	dbfb      	blt.n	8000f96 <usb_lld_serve_interrupt+0x176>
      otg_txfifo_flush(usbp, ep);
 8000f9e:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8000fa0:	0189      	lsls	r1, r1, #6
 8000fa2:	f041 0120 	orr.w	r1, r1, #32
 8000fa6:	6111      	str	r1, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8000fa8:	6913      	ldr	r3, [r2, #16]
 8000faa:	069b      	lsls	r3, r3, #26
 8000fac:	d4fc      	bmi.n	8000fa8 <usb_lld_serve_interrupt+0x188>
 * @xclass
 */
#if (PORT_SUPPORTS_RT == TRUE) || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
 8000fae:	2012      	movs	r0, #18
 8000fb0:	f7ff fbde 	bl	8000770 <chSysPolledDelayX>
      _usb_isr_invoke_in_cb(usbp, ep);
 8000fb4:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 8000fb8:	8922      	ldrh	r2, [r4, #8]
 8000fba:	68d9      	ldr	r1, [r3, #12]
 8000fbc:	fa09 f305 	lsl.w	r3, r9, r5
 8000fc0:	f8d1 b008 	ldr.w	fp, [r1, #8]
 8000fc4:	ea22 0303 	bic.w	r3, r2, r3
 8000fc8:	8123      	strh	r3, [r4, #8]
 8000fca:	f1bb 0f00 	cmp.w	fp, #0
 8000fce:	d002      	beq.n	8000fd6 <usb_lld_serve_interrupt+0x1b6>
 8000fd0:	4629      	mov	r1, r5
 8000fd2:	4620      	mov	r0, r4
 8000fd4:	47d8      	blx	fp
      otg_txfifo_handler(usbp, ep);
 8000fd6:	4629      	mov	r1, r5
 8000fd8:	4620      	mov	r0, r4
 8000fda:	f7ff fe81 	bl	8000ce0 <otg_txfifo_handler>
 8000fde:	e7c0      	b.n	8000f62 <usb_lld_serve_interrupt+0x142>
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8000fe0:	f8d6 3e00 	ldr.w	r3, [r6, #3584]	; 0xe00
 8000fe4:	079a      	lsls	r2, r3, #30
 8000fe6:	f040 80e0 	bne.w	80011aa <usb_lld_serve_interrupt+0x38a>
    otgp->DCTL &= ~DCTL_RWUSIG;
 8000fea:	f8d6 3804 	ldr.w	r3, [r6, #2052]	; 0x804

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8000fee:	6862      	ldr	r2, [r4, #4]
 8000ff0:	f023 0301 	bic.w	r3, r3, #1
 8000ff4:	f8c6 3804 	str.w	r3, [r6, #2052]	; 0x804
  usbp->state = usbp->saved_state;
 8000ff8:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
 8000ffc:	7023      	strb	r3, [r4, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8000ffe:	6813      	ldr	r3, [r2, #0]
 8001000:	2b00      	cmp	r3, #0
 8001002:	f43f af1d 	beq.w	8000e40 <usb_lld_serve_interrupt+0x20>
 8001006:	2105      	movs	r1, #5
 8001008:	4620      	mov	r0, r4
 800100a:	4798      	blx	r3
  if (sts & GINTSTS_USBSUSP) {
 800100c:	053b      	lsls	r3, r7, #20
 800100e:	f57f af53 	bpl.w	8000eb8 <usb_lld_serve_interrupt+0x98>
 8001012:	e717      	b.n	8000e44 <usb_lld_serve_interrupt+0x24>
  sts = usbp->otg->GRXSTSP;
 8001014:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
 8001016:	6a2b      	ldr	r3, [r5, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8001018:	f403 12f0 	and.w	r2, r3, #1966080	; 0x1e0000
 800101c:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
  cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8001020:	f3c3 110a 	ubfx	r1, r3, #4, #11
  ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8001024:	f003 030f 	and.w	r3, r3, #15
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8001028:	f000 80d5 	beq.w	80011d6 <usb_lld_serve_interrupt+0x3b6>
 800102c:	f5b2 2f40 	cmp.w	r2, #786432	; 0xc0000
 8001030:	f47f af5b 	bne.w	8000eea <usb_lld_serve_interrupt+0xca>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8001034:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8001038:	68db      	ldr	r3, [r3, #12]
 800103a:	6a1a      	ldr	r2, [r3, #32]
  while (i < n) {
 800103c:	2900      	cmp	r1, #0
 800103e:	f43f af54 	beq.w	8000eea <usb_lld_serve_interrupt+0xca>
      w = *fifop;
 8001042:	f505 5580 	add.w	r5, r5, #4096	; 0x1000
  size_t i = 0;
 8001046:	2300      	movs	r3, #0
    if ((i & 3) == 0) {
 8001048:	0798      	lsls	r0, r3, #30
      w = *fifop;
 800104a:	bf08      	it	eq
 800104c:	f8d5 8000 	ldreq.w	r8, [r5]
    if (i < max) {
 8001050:	2b07      	cmp	r3, #7
    i++;
 8001052:	f103 0301 	add.w	r3, r3, #1
      *buf++ = (uint8_t)w;
 8001056:	bf9c      	itt	ls
 8001058:	f802 8b01 	strbls.w	r8, [r2], #1
      w >>= 8;
 800105c:	ea4f 2818 	movls.w	r8, r8, lsr #8
  while (i < n) {
 8001060:	4299      	cmp	r1, r3
 8001062:	d1f1      	bne.n	8001048 <usb_lld_serve_interrupt+0x228>
 8001064:	e741      	b.n	8000eea <usb_lld_serve_interrupt+0xca>
  stm32_otg_t *otgp = usbp->otg;
 8001066:	f8d4 906c 	ldr.w	r9, [r4, #108]	; 0x6c
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800106a:	2500      	movs	r5, #0
      _usb_isr_invoke_out_cb(usbp, ep);
 800106c:	f04f 0a01 	mov.w	sl, #1
 8001070:	e006      	b.n	8001080 <usb_lld_serve_interrupt+0x260>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8001072:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8001074:	3501      	adds	r5, #1
 8001076:	689b      	ldr	r3, [r3, #8]
 8001078:	b2ed      	uxtb	r5, r5
 800107a:	429d      	cmp	r5, r3
 800107c:	f63f af32 	bhi.w	8000ee4 <usb_lld_serve_interrupt+0xc4>
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8001080:	eb09 1245 	add.w	r2, r9, r5, lsl #5
 8001084:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8001088:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 800108c:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8001090:	d1ef      	bne.n	8001072 <usb_lld_serve_interrupt+0x252>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 8001092:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8001096:	2b00      	cmp	r3, #0
 8001098:	daeb      	bge.n	8001072 <usb_lld_serve_interrupt+0x252>
      _usb_isr_invoke_out_cb(usbp, ep);
 800109a:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 800109e:	8962      	ldrh	r2, [r4, #10]
 80010a0:	68d9      	ldr	r1, [r3, #12]
 80010a2:	fa0a f305 	lsl.w	r3, sl, r5
 80010a6:	f8d1 b00c 	ldr.w	fp, [r1, #12]
 80010aa:	ea22 0303 	bic.w	r3, r2, r3
 80010ae:	8163      	strh	r3, [r4, #10]
 80010b0:	f1bb 0f00 	cmp.w	fp, #0
 80010b4:	d0dd      	beq.n	8001072 <usb_lld_serve_interrupt+0x252>
 80010b6:	4629      	mov	r1, r5
 80010b8:	4620      	mov	r0, r4
 80010ba:	47d8      	blx	fp
 80010bc:	e7d9      	b.n	8001072 <usb_lld_serve_interrupt+0x252>
  usbp->status        = 0;
 80010be:	2300      	movs	r3, #0
  usbp->state         = USB_READY;
 80010c0:	2102      	movs	r1, #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80010c2:	2220      	movs	r2, #32
    usbp->epc[i] = NULL;
 80010c4:	e9c0 3302 	strd	r3, r3, [r0, #8]
 80010c8:	e9c0 3304 	strd	r3, r3, [r0, #16]
 80010cc:	e9c0 3306 	strd	r3, r3, [r0, #24]
  usbp->state         = USB_READY;
 80010d0:	7001      	strb	r1, [r0, #0]
  usbp->status        = 0;
 80010d2:	6643      	str	r3, [r0, #100]	; 0x64
    usbp->epc[i] = NULL;
 80010d4:	6203      	str	r3, [r0, #32]
  usbp->ep0state = USB_EP0_STP_WAITING;
 80010d6:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
 80010da:	6132      	str	r2, [r6, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 80010dc:	6935      	ldr	r5, [r6, #16]
 80010de:	f015 0520 	ands.w	r5, r5, #32
 80010e2:	d1fb      	bne.n	80010dc <usb_lld_serve_interrupt+0x2bc>
 80010e4:	2012      	movs	r0, #18
 80010e6:	f7ff fb43 	bl	8000770 <chSysPolledDelayX>
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80010ea:	f8d4 c070 	ldr.w	ip, [r4, #112]	; 0x70
  otgp->DIEPEMPMSK = 0;
 80010ee:	f8c6 5834 	str.w	r5, [r6, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80010f2:	f04f 1301 	mov.w	r3, #65537	; 0x10001
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80010f6:	f8dc 7008 	ldr.w	r7, [ip, #8]
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80010fa:	f8c6 381c 	str.w	r3, [r6, #2076]	; 0x81c
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 80010fe:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8001102:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8001106:	eb06 1345 	add.w	r3, r6, r5, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800110a:	42bd      	cmp	r5, r7
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 800110c:	f8c3 0900 	str.w	r0, [r3, #2304]	; 0x900
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8001110:	f105 0501 	add.w	r5, r5, #1
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 8001114:	f8c3 0b00 	str.w	r0, [r3, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8001118:	f8c3 1908 	str.w	r1, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800111c:	f8c3 1b08 	str.w	r1, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8001120:	d1f1      	bne.n	8001106 <usb_lld_serve_interrupt+0x2e6>
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8001122:	f8dc 3000 	ldr.w	r3, [ip]
 8001126:	6763      	str	r3, [r4, #116]	; 0x74
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8001128:	f8dc 2000 	ldr.w	r2, [ip]
  otg_rxfifo_flush(usbp);
 800112c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 800112e:	6272      	str	r2, [r6, #36]	; 0x24
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8001130:	2210      	movs	r2, #16
 8001132:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 8001134:	691d      	ldr	r5, [r3, #16]
 8001136:	f015 0510 	ands.w	r5, r5, #16
 800113a:	d1fb      	bne.n	8001134 <usb_lld_serve_interrupt+0x314>
 800113c:	2012      	movs	r0, #18
 800113e:	f7ff fb17 	bl	8000770 <chSysPolledDelayX>
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8001142:	f8d6 3800 	ldr.w	r3, [r6, #2048]	; 0x800
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
 8001146:	6f21      	ldr	r1, [r4, #112]	; 0x70
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8001148:	4a58      	ldr	r2, [pc, #352]	; (80012ac <usb_lld_serve_interrupt+0x48c>)
  usbp->epc[0] = &ep0config;
 800114a:	4859      	ldr	r0, [pc, #356]	; (80012b0 <usb_lld_serve_interrupt+0x490>)
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 800114c:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8001150:	f8c6 3800 	str.w	r3, [r6, #2048]	; 0x800
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8001154:	69b3      	ldr	r3, [r6, #24]
 8001156:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 800115a:	f043 0310 	orr.w	r3, r3, #16
 800115e:	61b3      	str	r3, [r6, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8001160:	2309      	movs	r3, #9
 8001162:	f8c6 3810 	str.w	r3, [r6, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8001166:	f8c6 3814 	str.w	r3, [r6, #2068]	; 0x814
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 800116a:	f04f 43c0 	mov.w	r3, #1610612736	; 0x60000000
  usbp->epc[0] = &ep0config;
 800116e:	60e0      	str	r0, [r4, #12]
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 8001170:	f8c6 3b10 	str.w	r3, [r6, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8001174:	f8c6 2b00 	str.w	r2, [r6, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
 8001178:	f8c6 5910 	str.w	r5, [r6, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 800117c:	f8c6 2900 	str.w	r2, [r6, #2304]	; 0x900
  next = usbp->pmnext;
 8001180:	6f63      	ldr	r3, [r4, #116]	; 0x74
  usbp->pmnext += size;
 8001182:	f103 0210 	add.w	r2, r3, #16
 8001186:	6762      	str	r2, [r4, #116]	; 0x74
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8001188:	6849      	ldr	r1, [r1, #4]
 800118a:	428a      	cmp	r2, r1
 800118c:	d849      	bhi.n	8001222 <usb_lld_serve_interrupt+0x402>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 800118e:	6862      	ldr	r2, [r4, #4]
 8001190:	6812      	ldr	r2, [r2, #0]
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8001192:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8001196:	62b3      	str	r3, [r6, #40]	; 0x28
 8001198:	2a00      	cmp	r2, #0
 800119a:	f43f aed0 	beq.w	8000f3e <usb_lld_serve_interrupt+0x11e>
 800119e:	4629      	mov	r1, r5
 80011a0:	4620      	mov	r0, r4
}
 80011a2:	b001      	add	sp, #4
 80011a4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80011a8:	4710      	bx	r2
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 80011aa:	f8d6 3e00 	ldr.w	r3, [r6, #3584]	; 0xe00
 80011ae:	f023 0303 	bic.w	r3, r3, #3
 80011b2:	f8c6 3e00 	str.w	r3, [r6, #3584]	; 0xe00
 80011b6:	e718      	b.n	8000fea <usb_lld_serve_interrupt+0x1ca>
      otg_epout_handler(usbp, 5);
 80011b8:	2105      	movs	r1, #5
 80011ba:	4620      	mov	r0, r4
 80011bc:	f7ff fd40 	bl	8000c40 <otg_epout_handler>
  if (sts & GINTSTS_IEPINT) {
 80011c0:	037b      	lsls	r3, r7, #13
 80011c2:	f57f aebc 	bpl.w	8000f3e <usb_lld_serve_interrupt+0x11e>
 80011c6:	e6a8      	b.n	8000f1a <usb_lld_serve_interrupt+0xfa>
      otg_epin_handler(usbp, 5);
 80011c8:	4620      	mov	r0, r4
 80011ca:	2105      	movs	r1, #5
}
 80011cc:	b001      	add	sp, #4
 80011ce:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      otg_epin_handler(usbp, 5);
 80011d2:	f7ff bdd5 	b.w	8000d80 <otg_epin_handler>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 80011d6:	eb04 0e83 	add.w	lr, r4, r3, lsl #2
                            usbp->epc[ep]->out_state->rxbuf,
 80011da:	f8de 300c 	ldr.w	r3, [lr, #12]
 80011de:	699b      	ldr	r3, [r3, #24]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 80011e0:	e9d3 9201 	ldrd	r9, r2, [r3, #4]
 80011e4:	6818      	ldr	r0, [r3, #0]
 80011e6:	eba0 0c09 	sub.w	ip, r0, r9
  while (i < n) {
 80011ea:	b1a9      	cbz	r1, 8001218 <usb_lld_serve_interrupt+0x3f8>
      w = *fifop;
 80011ec:	f505 5580 	add.w	r5, r5, #4096	; 0x1000
  size_t i = 0;
 80011f0:	2300      	movs	r3, #0
    if ((i & 3) == 0) {
 80011f2:	0798      	lsls	r0, r3, #30
      w = *fifop;
 80011f4:	bf08      	it	eq
 80011f6:	f8d5 8000 	ldreq.w	r8, [r5]
    if (i < max) {
 80011fa:	459c      	cmp	ip, r3
    i++;
 80011fc:	f103 0301 	add.w	r3, r3, #1
      *buf++ = (uint8_t)w;
 8001200:	bf84      	itt	hi
 8001202:	f802 8b01 	strbhi.w	r8, [r2], #1
      w >>= 8;
 8001206:	ea4f 2818 	movhi.w	r8, r8, lsr #8
  while (i < n) {
 800120a:	4299      	cmp	r1, r3
 800120c:	d1f1      	bne.n	80011f2 <usb_lld_serve_interrupt+0x3d2>
 800120e:	f8de 300c 	ldr.w	r3, [lr, #12]
 8001212:	699b      	ldr	r3, [r3, #24]
 8001214:	e9d3 9201 	ldrd	r9, r2, [r3, #4]
    usbp->epc[ep]->out_state->rxbuf += cnt;
 8001218:	440a      	add	r2, r1
    usbp->epc[ep]->out_state->rxcnt += cnt;
 800121a:	4449      	add	r1, r9
 800121c:	e9c3 1201 	strd	r1, r2, [r3, #4]
    break;
 8001220:	e663      	b.n	8000eea <usb_lld_serve_interrupt+0xca>
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8001222:	4824      	ldr	r0, [pc, #144]	; (80012b4 <usb_lld_serve_interrupt+0x494>)
 8001224:	f7ff fab4 	bl	8000790 <chSysHalt>
      otg_epin_handler(usbp, 0);
 8001228:	2100      	movs	r1, #0
 800122a:	4620      	mov	r0, r4
 800122c:	f7ff fda8 	bl	8000d80 <otg_epin_handler>
    if (src & (1 << 1))
 8001230:	07ae      	lsls	r6, r5, #30
 8001232:	f57f ae78 	bpl.w	8000f26 <usb_lld_serve_interrupt+0x106>
      otg_epin_handler(usbp, 1);
 8001236:	4620      	mov	r0, r4
 8001238:	2101      	movs	r1, #1
 800123a:	f7ff fda1 	bl	8000d80 <otg_epin_handler>
    if (src & (1 << 2))
 800123e:	0768      	lsls	r0, r5, #29
 8001240:	f57f ae74 	bpl.w	8000f2c <usb_lld_serve_interrupt+0x10c>
      otg_epin_handler(usbp, 2);
 8001244:	2102      	movs	r1, #2
 8001246:	4620      	mov	r0, r4
 8001248:	f7ff fd9a 	bl	8000d80 <otg_epin_handler>
    if (src & (1 << 3))
 800124c:	0729      	lsls	r1, r5, #28
 800124e:	f57f ae70 	bpl.w	8000f32 <usb_lld_serve_interrupt+0x112>
      otg_epin_handler(usbp, 3);
 8001252:	2103      	movs	r1, #3
 8001254:	4620      	mov	r0, r4
 8001256:	f7ff fd93 	bl	8000d80 <otg_epin_handler>
    if (src & (1 << 4))
 800125a:	06ea      	lsls	r2, r5, #27
 800125c:	f57f ae6c 	bpl.w	8000f38 <usb_lld_serve_interrupt+0x118>
      otg_epin_handler(usbp, 4);
 8001260:	2104      	movs	r1, #4
 8001262:	4620      	mov	r0, r4
 8001264:	f7ff fd8c 	bl	8000d80 <otg_epin_handler>
 8001268:	e666      	b.n	8000f38 <usb_lld_serve_interrupt+0x118>
      otg_epout_handler(usbp, 0);
 800126a:	2100      	movs	r1, #0
 800126c:	4620      	mov	r0, r4
 800126e:	f7ff fce7 	bl	8000c40 <otg_epout_handler>
    if (src & (1 << 17))
 8001272:	03ab      	lsls	r3, r5, #14
 8001274:	f57f ae43 	bpl.w	8000efe <usb_lld_serve_interrupt+0xde>
      otg_epout_handler(usbp, 1);
 8001278:	2101      	movs	r1, #1
 800127a:	4620      	mov	r0, r4
 800127c:	f7ff fce0 	bl	8000c40 <otg_epout_handler>
    if (src & (1 << 18))
 8001280:	036e      	lsls	r6, r5, #13
 8001282:	f57f ae3f 	bpl.w	8000f04 <usb_lld_serve_interrupt+0xe4>
      otg_epout_handler(usbp, 2);
 8001286:	4620      	mov	r0, r4
 8001288:	2102      	movs	r1, #2
 800128a:	f7ff fcd9 	bl	8000c40 <otg_epout_handler>
    if (src & (1 << 19))
 800128e:	0328      	lsls	r0, r5, #12
 8001290:	f57f ae3b 	bpl.w	8000f0a <usb_lld_serve_interrupt+0xea>
      otg_epout_handler(usbp, 3);
 8001294:	2103      	movs	r1, #3
 8001296:	4620      	mov	r0, r4
 8001298:	f7ff fcd2 	bl	8000c40 <otg_epout_handler>
    if (src & (1 << 20))
 800129c:	02e9      	lsls	r1, r5, #11
 800129e:	f57f ae37 	bpl.w	8000f10 <usb_lld_serve_interrupt+0xf0>
      otg_epout_handler(usbp, 4);
 80012a2:	2104      	movs	r1, #4
 80012a4:	4620      	mov	r0, r4
 80012a6:	f7ff fccb 	bl	8000c40 <otg_epout_handler>
 80012aa:	e631      	b.n	8000f10 <usb_lld_serve_interrupt+0xf0>
 80012ac:	10008040 	.word	0x10008040
 80012b0:	080052c4 	.word	0x080052c4
 80012b4:	08004f08 	.word	0x08004f08
	...

080012c0 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 80012c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80012c4:	f002 0703 	and.w	r7, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 80012c8:	09d6      	lsrs	r6, r2, #7
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80012ca:	463d      	mov	r5, r7
  uint32_t bit     = 0;
 80012cc:	2400      	movs	r4, #0
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 80012ce:	f04f 080f 	mov.w	r8, #15
      m1 = 1 << bit;
 80012d2:	f04f 0e01 	mov.w	lr, #1
      m2 = 3 << (bit * 2);
 80012d6:	f04f 0c03 	mov.w	ip, #3
 80012da:	e011      	b.n	8001300 <_pal_lld_setgroupmode+0x40>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80012dc:	f8d0 a000 	ldr.w	sl, [r0]
 80012e0:	ea03 030a 	and.w	r3, r3, sl
 80012e4:	432b      	orrs	r3, r5
        if (bit < 8)
 80012e6:	2c07      	cmp	r4, #7
        port->MODER   = (port->MODER & ~m2) | moder;
 80012e8:	6003      	str	r3, [r0, #0]
        if (bit < 8)
 80012ea:	d83a      	bhi.n	8001362 <_pal_lld_setgroupmode+0xa2>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80012ec:	6a03      	ldr	r3, [r0, #32]
 80012ee:	ea23 0202 	bic.w	r2, r3, r2
 80012f2:	ea42 0209 	orr.w	r2, r2, r9
 80012f6:	6202      	str	r2, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 80012f8:	0849      	lsrs	r1, r1, #1
 80012fa:	d030      	beq.n	800135e <_pal_lld_setgroupmode+0x9e>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 80012fc:	00ad      	lsls	r5, r5, #2
    bit++;
 80012fe:	3401      	adds	r4, #1
    if ((mask & 1) != 0) {
 8001300:	07cb      	lsls	r3, r1, #31
 8001302:	d5f9      	bpl.n	80012f8 <_pal_lld_setgroupmode+0x38>
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001304:	6843      	ldr	r3, [r0, #4]
      m1 = 1 << bit;
 8001306:	fa0e f204 	lsl.w	r2, lr, r4
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800130a:	ea23 0302 	bic.w	r3, r3, r2
 800130e:	6043      	str	r3, [r0, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001310:	6882      	ldr	r2, [r0, #8]
      m2 = 3 << (bit * 2);
 8001312:	0063      	lsls	r3, r4, #1
 8001314:	fa0c f303 	lsl.w	r3, ip, r3
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001318:	ea22 0203 	bic.w	r2, r2, r3
 800131c:	6082      	str	r2, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800131e:	f8d0 900c 	ldr.w	r9, [r0, #12]
      altrmask = altr << ((bit & 7) * 4);
 8001322:	f004 0207 	and.w	r2, r4, #7
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001326:	ea29 0903 	bic.w	r9, r9, r3
      altrmask = altr << ((bit & 7) * 4);
 800132a:	0092      	lsls	r2, r2, #2
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 800132c:	2f02      	cmp	r7, #2
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800132e:	f8c0 900c 	str.w	r9, [r0, #12]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001332:	ea6f 0303 	mvn.w	r3, r3
      altrmask = altr << ((bit & 7) * 4);
 8001336:	fa06 f902 	lsl.w	r9, r6, r2
      m4 = 15 << ((bit & 7) * 4);
 800133a:	fa08 f202 	lsl.w	r2, r8, r2
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 800133e:	d1cd      	bne.n	80012dc <_pal_lld_setgroupmode+0x1c>
        if (bit < 8)
 8001340:	2c07      	cmp	r4, #7
 8001342:	d815      	bhi.n	8001370 <_pal_lld_setgroupmode+0xb0>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001344:	f8d0 a020 	ldr.w	sl, [r0, #32]
 8001348:	ea2a 0202 	bic.w	r2, sl, r2
 800134c:	ea42 0209 	orr.w	r2, r2, r9
 8001350:	6202      	str	r2, [r0, #32]
        port->MODER   = (port->MODER & ~m2) | moder;
 8001352:	6802      	ldr	r2, [r0, #0]
 8001354:	4013      	ands	r3, r2
 8001356:	432b      	orrs	r3, r5
    if (!mask)
 8001358:	0849      	lsrs	r1, r1, #1
        port->MODER   = (port->MODER & ~m2) | moder;
 800135a:	6003      	str	r3, [r0, #0]
    if (!mask)
 800135c:	d1ce      	bne.n	80012fc <_pal_lld_setgroupmode+0x3c>
  }
}
 800135e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001362:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001364:	ea23 0202 	bic.w	r2, r3, r2
 8001368:	ea42 0209 	orr.w	r2, r2, r9
 800136c:	6242      	str	r2, [r0, #36]	; 0x24
 800136e:	e7c3      	b.n	80012f8 <_pal_lld_setgroupmode+0x38>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001370:	f8d0 a024 	ldr.w	sl, [r0, #36]	; 0x24
 8001374:	ea2a 0202 	bic.w	r2, sl, r2
 8001378:	ea42 0209 	orr.w	r2, r2, r9
 800137c:	6242      	str	r2, [r0, #36]	; 0x24
 800137e:	e7e8      	b.n	8001352 <_pal_lld_setgroupmode+0x92>

08001380 <usbStartTransmitI>:
                       const uint8_t *buf, size_t n) {
 8001380:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001384:	4604      	mov	r4, r0
 8001386:	460d      	mov	r5, r1
 8001388:	4690      	mov	r8, r2
 800138a:	461f      	mov	r7, r3
  osalDbgCheckClassI();
 800138c:	f7ff fa28 	bl	80007e0 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8001390:	b1bc      	cbz	r4, 80013c2 <usbStartTransmitI+0x42>
 8001392:	2d05      	cmp	r5, #5
 8001394:	d815      	bhi.n	80013c2 <usbStartTransmitI+0x42>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 8001396:	8921      	ldrh	r1, [r4, #8]
 8001398:	2001      	movs	r0, #1
 800139a:	40a8      	lsls	r0, r5
 800139c:	b282      	uxth	r2, r0
 800139e:	4008      	ands	r0, r1
 80013a0:	d10f      	bne.n	80013c2 <usbStartTransmitI+0x42>
  isp = usbp->epc[ep]->in_state;
 80013a2:	eb04 0385 	add.w	r3, r4, r5, lsl #2
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80013a6:	4311      	orrs	r1, r2
  isp = usbp->epc[ep]->in_state;
 80013a8:	68db      	ldr	r3, [r3, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80013aa:	8121      	strh	r1, [r4, #8]
  isp = usbp->epc[ep]->in_state;
 80013ac:	695e      	ldr	r6, [r3, #20]
  usb_lld_start_in(usbp, ep);
 80013ae:	4629      	mov	r1, r5
  isp->txcnt  = 0;
 80013b0:	e9c6 7000 	strd	r7, r0, [r6]
  isp->txbuf  = buf;
 80013b4:	f8c6 8008 	str.w	r8, [r6, #8]
  usb_lld_start_in(usbp, ep);
 80013b8:	4620      	mov	r0, r4
}
 80013ba:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  usb_lld_start_in(usbp, ep);
 80013be:	f7ff bbaf 	b.w	8000b20 <usb_lld_start_in>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 80013c2:	4801      	ldr	r0, [pc, #4]	; (80013c8 <usbStartTransmitI+0x48>)
 80013c4:	f7ff f9e4 	bl	8000790 <chSysHalt>
 80013c8:	08004fc4 	.word	0x08004fc4
 80013cc:	00000000 	.word	0x00000000

080013d0 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 80013d0:	b538      	push	{r3, r4, r5, lr}

  (void)ep;
  switch (usbp->ep0state) {
 80013d2:	f890 104c 	ldrb.w	r1, [r0, #76]	; 0x4c
 80013d6:	2914      	cmp	r1, #20
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 80013d8:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 80013da:	d006      	beq.n	80013ea <_usb_ep0out+0x1a>
 80013dc:	2915      	cmp	r1, #21
 80013de:	d024      	beq.n	800142a <_usb_ep0out+0x5a>
 80013e0:	2906      	cmp	r1, #6
 80013e2:	d00d      	beq.n	8001400 <_usb_ep0out+0x30>
  case USB_EP0_STP_WAITING:
  case USB_EP0_IN_TX:
  case USB_EP0_IN_WAITING_TX0:
  case USB_EP0_IN_SENDING_STS:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
 80013e4:	481b      	ldr	r0, [pc, #108]	; (8001454 <_usb_ep0out+0x84>)
 80013e6:	f7ff f9d3 	bl	8000790 <chSysHalt>
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 80013ea:	68c3      	ldr	r3, [r0, #12]
 80013ec:	699b      	ldr	r3, [r3, #24]
 80013ee:	685b      	ldr	r3, [r3, #4]
 80013f0:	b92b      	cbnz	r3, 80013fe <_usb_ep0out+0x2e>
    if (usbp->ep0endcb != NULL) {
 80013f2:	6d83      	ldr	r3, [r0, #88]	; 0x58
 80013f4:	b103      	cbz	r3, 80013f8 <_usb_ep0out+0x28>
      usbp->ep0endcb(usbp);
 80013f6:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
 80013f8:	2300      	movs	r3, #0
 80013fa:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 80013fe:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8001400:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8001402:	6845      	ldr	r5, [r0, #4]
 8001404:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8001408:	682d      	ldr	r5, [r5, #0]
 800140a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800140e:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8001412:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8001416:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800141a:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 800141e:	b105      	cbz	r5, 8001422 <_usb_ep0out+0x52>
 8001420:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 8001422:	2306      	movs	r3, #6
 8001424:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
}
 8001428:	bd38      	pop	{r3, r4, r5, pc}
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
 800142a:	230b      	movs	r3, #11
 800142c:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
 8001430:	2320      	movs	r3, #32
 8001432:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001436:	f7ff fb23 	bl	8000a80 <_dbg_check_lock_from_isr>
    usbStartTransmitI(usbp, 0, NULL, 0);
 800143a:	2300      	movs	r3, #0
 800143c:	461a      	mov	r2, r3
 800143e:	4619      	mov	r1, r3
 8001440:	4620      	mov	r0, r4
 8001442:	f7ff ff9d 	bl	8001380 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
 8001446:	f7ff fb03 	bl	8000a50 <_dbg_check_unlock_from_isr>
 800144a:	2300      	movs	r3, #0
 800144c:	f383 8811 	msr	BASEPRI, r3
}
 8001450:	bd38      	pop	{r3, r4, r5, pc}
 8001452:	bf00      	nop
 8001454:	08005030 	.word	0x08005030
	...

08001460 <usbStartReceiveI>:
                      uint8_t *buf, size_t n) {
 8001460:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001464:	4604      	mov	r4, r0
 8001466:	460d      	mov	r5, r1
 8001468:	4690      	mov	r8, r2
 800146a:	461f      	mov	r7, r3
  osalDbgCheckClassI();
 800146c:	f7ff f9b8 	bl	80007e0 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8001470:	b1bc      	cbz	r4, 80014a2 <usbStartReceiveI+0x42>
 8001472:	2d05      	cmp	r5, #5
 8001474:	d815      	bhi.n	80014a2 <usbStartReceiveI+0x42>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 8001476:	8961      	ldrh	r1, [r4, #10]
 8001478:	2001      	movs	r0, #1
 800147a:	40a8      	lsls	r0, r5
 800147c:	b282      	uxth	r2, r0
 800147e:	4008      	ands	r0, r1
 8001480:	d10f      	bne.n	80014a2 <usbStartReceiveI+0x42>
  osp = usbp->epc[ep]->out_state;
 8001482:	eb04 0385 	add.w	r3, r4, r5, lsl #2
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001486:	4311      	orrs	r1, r2
  osp = usbp->epc[ep]->out_state;
 8001488:	68db      	ldr	r3, [r3, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800148a:	8161      	strh	r1, [r4, #10]
  osp = usbp->epc[ep]->out_state;
 800148c:	699e      	ldr	r6, [r3, #24]
  usb_lld_start_out(usbp, ep);
 800148e:	4629      	mov	r1, r5
  osp->rxcnt  = 0;
 8001490:	e9c6 7000 	strd	r7, r0, [r6]
  osp->rxbuf  = buf;
 8001494:	f8c6 8008 	str.w	r8, [r6, #8]
  usb_lld_start_out(usbp, ep);
 8001498:	4620      	mov	r0, r4
}
 800149a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  usb_lld_start_out(usbp, ep);
 800149e:	f7ff bb8f 	b.w	8000bc0 <usb_lld_start_out>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 80014a2:	4801      	ldr	r0, [pc, #4]	; (80014a8 <usbStartReceiveI+0x48>)
 80014a4:	f7ff f974 	bl	8000790 <chSysHalt>
 80014a8:	08004f94 	.word	0x08004f94
 80014ac:	00000000 	.word	0x00000000

080014b0 <_usb_ep0in>:
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 80014b0:	b538      	push	{r3, r4, r5, lr}
 80014b2:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
 80014b6:	3b06      	subs	r3, #6
 80014b8:	4604      	mov	r4, r0
 80014ba:	2b05      	cmp	r3, #5
 80014bc:	d804      	bhi.n	80014c8 <_usb_ep0in+0x18>
 80014be:	e8df f003 	tbb	[pc, r3]
 80014c2:	0331      	.short	0x0331
 80014c4:	2a160603 	.word	0x2a160603
    osalDbgAssert(false, "EP0 state machine error");
 80014c8:	482b      	ldr	r0, [pc, #172]	; (8001578 <_usb_ep0in+0xc8>)
 80014ca:	f7ff f961 	bl	8000790 <chSysHalt>
  hw |= (uint16_t)*p << 8U;
 80014ce:	f890 2063 	ldrb.w	r2, [r0, #99]	; 0x63
 80014d2:	f890 0062 	ldrb.w	r0, [r0, #98]	; 0x62
    if ((usbp->ep0n < max) &&
 80014d6:	6d63      	ldr	r3, [r4, #84]	; 0x54
    max = (size_t)get_hword(&usbp->setup[6]);
 80014d8:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
    if ((usbp->ep0n < max) &&
 80014dc:	4283      	cmp	r3, r0
 80014de:	d206      	bcs.n	80014ee <_usb_ep0in+0x3e>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 80014e0:	68e2      	ldr	r2, [r4, #12]
 80014e2:	8a12      	ldrh	r2, [r2, #16]
 80014e4:	fbb3 f5f2 	udiv	r5, r3, r2
 80014e8:	fb02 3515 	mls	r5, r2, r5, r3
    if ((usbp->ep0n < max) &&
 80014ec:	b385      	cbz	r5, 8001550 <_usb_ep0in+0xa0>
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 80014ee:	2314      	movs	r3, #20
 80014f0:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 80014f4:	2320      	movs	r3, #32
 80014f6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 80014fa:	f7ff fac1 	bl	8000a80 <_dbg_check_lock_from_isr>
    usbStartReceiveI(usbp, 0, NULL, 0);
 80014fe:	2300      	movs	r3, #0
 8001500:	461a      	mov	r2, r3
 8001502:	4619      	mov	r1, r3
 8001504:	4620      	mov	r0, r4
 8001506:	f7ff ffab 	bl	8001460 <usbStartReceiveI>
  _dbg_check_unlock_from_isr();
 800150a:	f7ff faa1 	bl	8000a50 <_dbg_check_unlock_from_isr>
 800150e:	2300      	movs	r3, #0
 8001510:	f383 8811 	msr	BASEPRI, r3
}
 8001514:	bd38      	pop	{r3, r4, r5, pc}
    if (usbp->ep0endcb != NULL) {
 8001516:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8001518:	b103      	cbz	r3, 800151c <_usb_ep0in+0x6c>
      usbp->ep0endcb(usbp);
 800151a:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
 800151c:	2300      	movs	r3, #0
 800151e:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
}
 8001522:	bd38      	pop	{r3, r4, r5, pc}
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8001524:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8001526:	6841      	ldr	r1, [r0, #4]
 8001528:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800152c:	680d      	ldr	r5, [r1, #0]
 800152e:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8001532:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8001536:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800153a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800153e:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8001542:	b10d      	cbz	r5, 8001548 <_usb_ep0in+0x98>
 8001544:	2106      	movs	r1, #6
 8001546:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 8001548:	2306      	movs	r3, #6
 800154a:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
}
 800154e:	bd38      	pop	{r3, r4, r5, pc}
 8001550:	2320      	movs	r3, #32
 8001552:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001556:	f7ff fa93 	bl	8000a80 <_dbg_check_lock_from_isr>
      usbStartTransmitI(usbp, 0, NULL, 0);
 800155a:	462b      	mov	r3, r5
 800155c:	462a      	mov	r2, r5
 800155e:	4629      	mov	r1, r5
 8001560:	4620      	mov	r0, r4
 8001562:	f7ff ff0d 	bl	8001380 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
 8001566:	f7ff fa73 	bl	8000a50 <_dbg_check_unlock_from_isr>
 800156a:	f385 8811 	msr	BASEPRI, r5
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
 800156e:	230a      	movs	r3, #10
 8001570:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
}
 8001574:	bd38      	pop	{r3, r4, r5, pc}
 8001576:	bf00      	nop
 8001578:	08005024 	.word	0x08005024
 800157c:	00000000 	.word	0x00000000

08001580 <sduInterruptTransmitted>:
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  (void)ep;
}
 8001580:	4770      	bx	lr
 8001582:	bf00      	nop
	...

08001590 <sduRequestsHook>:
  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8001590:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
 8001594:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8001598:	2b20      	cmp	r3, #32
 800159a:	d001      	beq.n	80015a0 <sduRequestsHook+0x10>
  return false;
 800159c:	2000      	movs	r0, #0
}
 800159e:	4770      	bx	lr
    switch (usbp->setup[1]) {
 80015a0:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
 80015a4:	2b21      	cmp	r3, #33	; 0x21
 80015a6:	d809      	bhi.n	80015bc <sduRequestsHook+0x2c>
 80015a8:	2b1f      	cmp	r3, #31
 80015aa:	d9f7      	bls.n	800159c <sduRequestsHook+0xc>
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 80015ac:	4b07      	ldr	r3, [pc, #28]	; (80015cc <sduRequestsHook+0x3c>)
 80015ae:	6503      	str	r3, [r0, #80]	; 0x50
 80015b0:	2207      	movs	r2, #7
 80015b2:	2300      	movs	r3, #0
 80015b4:	e9c0 2315 	strd	r2, r3, [r0, #84]	; 0x54
      return true;
 80015b8:	2001      	movs	r0, #1
 80015ba:	4770      	bx	lr
    switch (usbp->setup[1]) {
 80015bc:	2b22      	cmp	r3, #34	; 0x22
 80015be:	d1ed      	bne.n	800159c <sduRequestsHook+0xc>
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80015c0:	2300      	movs	r3, #0
 80015c2:	e9c0 3314 	strd	r3, r3, [r0, #80]	; 0x50
 80015c6:	6583      	str	r3, [r0, #88]	; 0x58
      return true;
 80015c8:	2001      	movs	r0, #1
 80015ca:	4770      	bx	lr
 80015cc:	20000800 	.word	0x20000800

080015d0 <_ctl.lto_priv.1>:
static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
 80015d0:	b508      	push	{r3, lr}
  osalDbgCheck(sdup != NULL);
 80015d2:	b130      	cbz	r0, 80015e2 <_ctl.lto_priv.1+0x12>
  switch (operation) {
 80015d4:	b129      	cbz	r1, 80015e2 <_ctl.lto_priv.1+0x12>
 80015d6:	2901      	cmp	r1, #1
 80015d8:	d001      	beq.n	80015de <_ctl.lto_priv.1+0xe>
}
 80015da:	2000      	movs	r0, #0
 80015dc:	bd08      	pop	{r3, pc}
    osalDbgCheck(arg == NULL);
 80015de:	2a00      	cmp	r2, #0
 80015e0:	d0fb      	beq.n	80015da <_ctl.lto_priv.1+0xa>
    osalDbgAssert(false, "invalid CTL operation");
 80015e2:	4801      	ldr	r0, [pc, #4]	; (80015e8 <_ctl.lto_priv.1+0x18>)
 80015e4:	f7ff f8d4 	bl	8000790 <chSysHalt>
 80015e8:	08004e1c 	.word	0x08004e1c
 80015ec:	00000000 	.word	0x00000000

080015f0 <sdu_start_receive>:
static bool sdu_start_receive(SerialUSBDriver *sdup) {
 80015f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80015f2:	f8d0 648c 	ldr.w	r6, [r0, #1164]	; 0x48c
 80015f6:	6835      	ldr	r5, [r6, #0]
 80015f8:	782b      	ldrb	r3, [r5, #0]
 80015fa:	2b04      	cmp	r3, #4
 80015fc:	d103      	bne.n	8001606 <sdu_start_receive+0x16>
 80015fe:	7a03      	ldrb	r3, [r0, #8]
 8001600:	2b02      	cmp	r3, #2
 8001602:	4607      	mov	r7, r0
 8001604:	d001      	beq.n	800160a <sdu_start_receive+0x1a>
    return true;
 8001606:	2001      	movs	r0, #1
}
 8001608:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800160a:	7933      	ldrb	r3, [r6, #4]
 800160c:	896a      	ldrh	r2, [r5, #10]
 800160e:	2401      	movs	r4, #1
 8001610:	fa04 f303 	lsl.w	r3, r4, r3
 8001614:	4213      	tst	r3, r2
 8001616:	d1f6      	bne.n	8001606 <sdu_start_receive+0x16>
 *
 * @iclass
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();
 8001618:	f7ff f8e2 	bl	80007e0 <chDbgCheckClassI>

  if (ibqIsFullI(ibqp)) {
 800161c:	e9d7 2307 	ldrd	r2, r3, [r7, #28]
 8001620:	429a      	cmp	r2, r3
 8001622:	d008      	beq.n	8001636 <sdu_start_receive+0x46>
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 8001624:	4628      	mov	r0, r5
 8001626:	7971      	ldrb	r1, [r6, #5]
 8001628:	3204      	adds	r2, #4
 800162a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800162e:	f7ff ff17 	bl	8001460 <usbStartReceiveI>
  return false;
 8001632:	2000      	movs	r0, #0
}
 8001634:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001636:	69bb      	ldr	r3, [r7, #24]
 8001638:	2b00      	cmp	r3, #0
 800163a:	d0f3      	beq.n	8001624 <sdu_start_receive+0x34>
 800163c:	e7e3      	b.n	8001606 <sdu_start_receive+0x16>
 800163e:	bf00      	nop

08001640 <ibnotify>:
  (void) sdu_start_receive(sdup);
 8001640:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8001642:	f7ff bfd5 	b.w	80015f0 <sdu_start_receive>
 8001646:	bf00      	nop
	...

08001650 <sduDataReceived>:
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8001650:	310d      	adds	r1, #13
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 8001652:	b538      	push	{r3, r4, r5, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8001654:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
  if (sdup == NULL) {
 8001658:	b1b4      	cbz	r4, 8001688 <sduDataReceived+0x38>
 800165a:	2320      	movs	r3, #32
 800165c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001660:	f7ff fa0e 	bl	8000a80 <_dbg_check_lock_from_isr>
  size = usbGetReceiveTransactionSizeX(sdup->config->usbp,
 8001664:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 8001668:	6813      	ldr	r3, [r2, #0]
 800166a:	7952      	ldrb	r2, [r2, #5]
 800166c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8001670:	68db      	ldr	r3, [r3, #12]
 8001672:	699b      	ldr	r3, [r3, #24]
 8001674:	685d      	ldr	r5, [r3, #4]
  if (size > (size_t)0) {
 8001676:	b945      	cbnz	r5, 800168a <sduDataReceived+0x3a>
  (void) sdu_start_receive(sdup);
 8001678:	4620      	mov	r0, r4
 800167a:	f7ff ffb9 	bl	80015f0 <sdu_start_receive>
  _dbg_check_unlock_from_isr();
 800167e:	f7ff f9e7 	bl	8000a50 <_dbg_check_unlock_from_isr>
 8001682:	2300      	movs	r3, #0
 8001684:	f383 8811 	msr	BASEPRI, r3
}
 8001688:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800168a:	2104      	movs	r1, #4
 800168c:	1860      	adds	r0, r4, r1
 800168e:	f7ff f96f 	bl	8000970 <chEvtBroadcastFlagsI>
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {

  osalDbgCheckClassI();
 8001692:	f7ff f8a5 	bl	80007e0 <chDbgCheckClassI>

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 8001696:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001698:	3b04      	subs	r3, #4
 800169a:	429d      	cmp	r5, r3
 800169c:	d817      	bhi.n	80016ce <sduDataReceived+0x7e>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 800169e:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
 80016a2:	4293      	cmp	r3, r2
 80016a4:	d010      	beq.n	80016c8 <sduDataReceived+0x78>

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 80016a6:	601d      	str	r5, [r3, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
  ibqp->bwrptr += ibqp->bsize;
  if (ibqp->bwrptr >= ibqp->btop) {
 80016a8:	e9d4 1009 	ldrd	r1, r0, [r4, #36]	; 0x24
  ibqp->bcounter++;
 80016ac:	69a2      	ldr	r2, [r4, #24]
  ibqp->bwrptr += ibqp->bsize;
 80016ae:	4403      	add	r3, r0
  ibqp->bcounter++;
 80016b0:	3201      	adds	r2, #1
  if (ibqp->bwrptr >= ibqp->btop) {
 80016b2:	428b      	cmp	r3, r1
  ibqp->bcounter++;
 80016b4:	61a2      	str	r2, [r4, #24]
  ibqp->bwrptr += ibqp->bsize;
 80016b6:	61e3      	str	r3, [r4, #28]
  if (ibqp->bwrptr >= ibqp->btop) {
 80016b8:	d301      	bcc.n	80016be <sduDataReceived+0x6e>
    ibqp->bwrptr = ibqp->buffers;
 80016ba:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80016bc:	61e3      	str	r3, [r4, #28]
  chThdDequeueNextI(tqp, msg);
 80016be:	f104 000c 	add.w	r0, r4, #12
 80016c2:	f7ff f91d 	bl	8000900 <chThdDequeueNextI.constprop.0>
 80016c6:	e7d7      	b.n	8001678 <sduDataReceived+0x28>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 80016c8:	69a2      	ldr	r2, [r4, #24]
 80016ca:	2a00      	cmp	r2, #0
 80016cc:	d0eb      	beq.n	80016a6 <sduDataReceived+0x56>
  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 80016ce:	4801      	ldr	r0, [pc, #4]	; (80016d4 <sduDataReceived+0x84>)
 80016d0:	f7ff f85e 	bl	8000790 <chSysHalt>
 80016d4:	08004eb0 	.word	0x08004eb0
	...

080016e0 <_ctl.lto_priv.0>:
                     sysinterval_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
}

static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
 80016e0:	b508      	push	{r3, lr}
  SerialDriver *sdp = (SerialDriver *)ip;

  osalDbgCheck(sdp != NULL);
 80016e2:	b130      	cbz	r0, 80016f2 <_ctl.lto_priv.0+0x12>

  switch (operation) {
 80016e4:	b129      	cbz	r1, 80016f2 <_ctl.lto_priv.0+0x12>
 80016e6:	2901      	cmp	r1, #1
 80016e8:	d001      	beq.n	80016ee <_ctl.lto_priv.0+0xe>
#else
    break;
#endif
  }
  return MSG_OK;
}
 80016ea:	2000      	movs	r0, #0
 80016ec:	bd08      	pop	{r3, pc}
    osalDbgCheck(arg == NULL);
 80016ee:	2a00      	cmp	r2, #0
 80016f0:	d0fb      	beq.n	80016ea <_ctl.lto_priv.0+0xa>
    osalDbgAssert(false, "invalid CTL operation");
 80016f2:	4801      	ldr	r0, [pc, #4]	; (80016f8 <_ctl.lto_priv.0+0x18>)
 80016f4:	f7ff f84c 	bl	8000790 <chSysHalt>
 80016f8:	08004e08 	.word	0x08004e08
 80016fc:	00000000 	.word	0x00000000

08001700 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 8001700:	b570      	push	{r4, r5, r6, lr}
 8001702:	460d      	mov	r5, r1
 8001704:	4604      	mov	r4, r0

  osalDbgCheckClassS();
 8001706:	f7ff f85b 	bl	80007c0 <chDbgCheckClassS>
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 800170a:	b1d5      	cbz	r5, 8001742 <obqPostFullBufferS+0x42>
 800170c:	69e3      	ldr	r3, [r4, #28]
 800170e:	3b04      	subs	r3, #4
 8001710:	42ab      	cmp	r3, r5
 8001712:	d316      	bcc.n	8001742 <obqPostFullBufferS+0x42>
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
 8001714:	68e3      	ldr	r3, [r4, #12]
 8001716:	b1a3      	cbz	r3, 8001742 <obqPostFullBufferS+0x42>

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 8001718:	6923      	ldr	r3, [r4, #16]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
  obqp->bwrptr += obqp->bsize;
  if (obqp->bwrptr >= obqp->btop) {
 800171a:	69a1      	ldr	r1, [r4, #24]
  *((size_t *)obqp->bwrptr) = size;
 800171c:	601d      	str	r5, [r3, #0]
  obqp->bwrptr += obqp->bsize;
 800171e:	69e0      	ldr	r0, [r4, #28]
  obqp->bcounter--;
 8001720:	68e2      	ldr	r2, [r4, #12]
  obqp->bwrptr += obqp->bsize;
 8001722:	4403      	add	r3, r0
  if (obqp->bwrptr >= obqp->btop) {
 8001724:	428b      	cmp	r3, r1
  obqp->bwrptr += obqp->bsize;
 8001726:	6123      	str	r3, [r4, #16]
    obqp->bwrptr = obqp->buffers;
 8001728:	bf24      	itt	cs
 800172a:	6a63      	ldrcs	r3, [r4, #36]	; 0x24
 800172c:	6123      	strcs	r3, [r4, #16]
  obqp->bcounter--;
 800172e:	3a01      	subs	r2, #1

  /* No "current" buffer.*/
  obqp->ptr = NULL;

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 8001730:	6b23      	ldr	r3, [r4, #48]	; 0x30
  obqp->bcounter--;
 8001732:	60e2      	str	r2, [r4, #12]
  obqp->ptr = NULL;
 8001734:	2200      	movs	r2, #0
 8001736:	62a2      	str	r2, [r4, #40]	; 0x28
  if (obqp->notify != NULL) {
 8001738:	b133      	cbz	r3, 8001748 <obqPostFullBufferS+0x48>
    obqp->notify(obqp);
 800173a:	4620      	mov	r0, r4
  }
}
 800173c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    obqp->notify(obqp);
 8001740:	4718      	bx	r3
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 8001742:	4802      	ldr	r0, [pc, #8]	; (800174c <obqPostFullBufferS+0x4c>)
 8001744:	f7ff f824 	bl	8000790 <chSysHalt>
}
 8001748:	bd70      	pop	{r4, r5, r6, pc}
 800174a:	bf00      	nop
 800174c:	08004fd8 	.word	0x08004fd8

08001750 <obqGetFullBufferI>:
                           size_t *sizep) {
 8001750:	b538      	push	{r3, r4, r5, lr}
 8001752:	4604      	mov	r4, r0
 8001754:	460d      	mov	r5, r1
  osalDbgCheckClassI();
 8001756:	f7ff f843 	bl	80007e0 <chDbgCheckClassI>
  if (obqIsEmptyI(obqp)) {
 800175a:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
 800175e:	4282      	cmp	r2, r0
 8001760:	d003      	beq.n	800176a <obqGetFullBufferI+0x1a>
  *sizep = *((size_t *)obqp->brdptr);
 8001762:	f850 3b04 	ldr.w	r3, [r0], #4
 8001766:	602b      	str	r3, [r5, #0]
}
 8001768:	bd38      	pop	{r3, r4, r5, pc}
  if (obqIsEmptyI(obqp)) {
 800176a:	68e2      	ldr	r2, [r4, #12]
 800176c:	2a00      	cmp	r2, #0
 800176e:	d0f8      	beq.n	8001762 <obqGetFullBufferI+0x12>
    return NULL;
 8001770:	2000      	movs	r0, #0
}
 8001772:	bd38      	pop	{r3, r4, r5, pc}
	...

08001780 <sof_handler>:
}

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 8001780:	b510      	push	{r4, lr}
 8001782:	2320      	movs	r3, #32
 8001784:	b082      	sub	sp, #8
 8001786:	f383 8811 	msr	BASEPRI, r3
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800178a:	4c23      	ldr	r4, [pc, #140]	; (8001818 <sof_handler+0x98>)
  _dbg_check_lock_from_isr();
 800178c:	f7ff f978 	bl	8000a80 <_dbg_check_lock_from_isr>
 8001790:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 8001794:	6813      	ldr	r3, [r2, #0]
 8001796:	7819      	ldrb	r1, [r3, #0]
 8001798:	2904      	cmp	r1, #4
 800179a:	d102      	bne.n	80017a2 <sof_handler+0x22>
 800179c:	7a21      	ldrb	r1, [r4, #8]
 800179e:	2902      	cmp	r1, #2
 80017a0:	d006      	beq.n	80017b0 <sof_handler+0x30>
  _dbg_check_unlock_from_isr();
 80017a2:	f7ff f955 	bl	8000a50 <_dbg_check_unlock_from_isr>
 80017a6:	2300      	movs	r3, #0
 80017a8:	f383 8811 	msr	BASEPRI, r3
  (void)usbp;

  osalSysLockFromISR();
  sduSOFHookI(&SDU1);
  osalSysUnlockFromISR();
}
 80017ac:	b002      	add	sp, #8
 80017ae:	bd10      	pop	{r4, pc}
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80017b0:	7911      	ldrb	r1, [r2, #4]
 80017b2:	891a      	ldrh	r2, [r3, #8]
 80017b4:	2301      	movs	r3, #1
 80017b6:	408b      	lsls	r3, r1
 80017b8:	4213      	tst	r3, r2
 80017ba:	d1f2      	bne.n	80017a2 <sof_handler+0x22>
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();
 80017bc:	f7ff f810 	bl	80007e0 <chDbgCheckClassI>

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 80017c0:	e9d4 3215 	ldrd	r3, r2, [r4, #84]	; 0x54
 80017c4:	4293      	cmp	r3, r2
 80017c6:	d1ec      	bne.n	80017a2 <sof_handler+0x22>
 80017c8:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80017ca:	2a00      	cmp	r2, #0
 80017cc:	d0e9      	beq.n	80017a2 <sof_handler+0x22>
 80017ce:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 80017d0:	2a00      	cmp	r2, #0
 80017d2:	d0e6      	beq.n	80017a2 <sof_handler+0x22>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 80017d4:	3a04      	subs	r2, #4

    if (size > 0U) {
 80017d6:	1ad2      	subs	r2, r2, r3
 80017d8:	d0e3      	beq.n	80017a2 <sof_handler+0x22>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 80017da:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
      obqp->bwrptr += obqp->bsize;
      if (obqp->bwrptr >= obqp->btop) {
 80017dc:	e9d4 1017 	ldrd	r1, r0, [r4, #92]	; 0x5c
      obqp->bwrptr += obqp->bsize;
 80017e0:	4403      	add	r3, r0
      if (obqp->bwrptr >= obqp->btop) {
 80017e2:	428b      	cmp	r3, r1
      obqp->bcounter--;
 80017e4:	6d22      	ldr	r2, [r4, #80]	; 0x50
      obqp->bwrptr += obqp->bsize;
 80017e6:	6563      	str	r3, [r4, #84]	; 0x54
        obqp->bwrptr = obqp->buffers;
 80017e8:	bf24      	itt	cs
 80017ea:	6ea3      	ldrcs	r3, [r4, #104]	; 0x68
 80017ec:	6563      	strcs	r3, [r4, #84]	; 0x54
      obqp->bcounter--;
 80017ee:	3a01      	subs	r2, #1
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 80017f0:	2300      	movs	r3, #0
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80017f2:	480a      	ldr	r0, [pc, #40]	; (800181c <sof_handler+0x9c>)
      obqp->bcounter--;
 80017f4:	6522      	str	r2, [r4, #80]	; 0x50
 80017f6:	a901      	add	r1, sp, #4
      obqp->ptr = NULL;
 80017f8:	66e3      	str	r3, [r4, #108]	; 0x6c
 80017fa:	f7ff ffa9 	bl	8001750 <obqGetFullBufferI>
    osalDbgAssert(buf != NULL, "queue is empty");
 80017fe:	4602      	mov	r2, r0
 8001800:	b138      	cbz	r0, 8001812 <sof_handler+0x92>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8001802:	f8d4 048c 	ldr.w	r0, [r4, #1164]	; 0x48c
 8001806:	9b01      	ldr	r3, [sp, #4]
 8001808:	7901      	ldrb	r1, [r0, #4]
 800180a:	6800      	ldr	r0, [r0, #0]
 800180c:	f7ff fdb8 	bl	8001380 <usbStartTransmitI>
 8001810:	e7c7      	b.n	80017a2 <sof_handler+0x22>
    osalDbgAssert(buf != NULL, "queue is empty");
 8001812:	4803      	ldr	r0, [pc, #12]	; (8001820 <sof_handler+0xa0>)
 8001814:	f7fe ffbc 	bl	8000790 <chSysHalt>
 8001818:	20000904 	.word	0x20000904
 800181c:	20000948 	.word	0x20000948
 8001820:	08004ea4 	.word	0x08004ea4
	...

08001830 <obnotify>:
static void obnotify(io_buffers_queue_t *bqp) {
 8001830:	b510      	push	{r4, lr}
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 8001832:	6b44      	ldr	r4, [r0, #52]	; 0x34
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8001834:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 8001838:	6813      	ldr	r3, [r2, #0]
 800183a:	7819      	ldrb	r1, [r3, #0]
 800183c:	2904      	cmp	r1, #4
static void obnotify(io_buffers_queue_t *bqp) {
 800183e:	b082      	sub	sp, #8
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8001840:	d102      	bne.n	8001848 <obnotify+0x18>
 8001842:	7a21      	ldrb	r1, [r4, #8]
 8001844:	2902      	cmp	r1, #2
 8001846:	d001      	beq.n	800184c <obnotify+0x1c>
}
 8001848:	b002      	add	sp, #8
 800184a:	bd10      	pop	{r4, pc}
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800184c:	7911      	ldrb	r1, [r2, #4]
 800184e:	891a      	ldrh	r2, [r3, #8]
 8001850:	2301      	movs	r3, #1
 8001852:	408b      	lsls	r3, r1
 8001854:	4213      	tst	r3, r2
 8001856:	d1f7      	bne.n	8001848 <obnotify+0x18>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8001858:	a901      	add	r1, sp, #4
 800185a:	f104 0044 	add.w	r0, r4, #68	; 0x44
 800185e:	f7ff ff77 	bl	8001750 <obqGetFullBufferI>
    osalDbgAssert(buf != NULL, "buffer not found");
 8001862:	4602      	mov	r2, r0
 8001864:	b138      	cbz	r0, 8001876 <obnotify+0x46>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8001866:	f8d4 048c 	ldr.w	r0, [r4, #1164]	; 0x48c
 800186a:	9b01      	ldr	r3, [sp, #4]
 800186c:	7901      	ldrb	r1, [r0, #4]
 800186e:	6800      	ldr	r0, [r0, #0]
 8001870:	f7ff fd86 	bl	8001380 <usbStartTransmitI>
 8001874:	e7e8      	b.n	8001848 <obnotify+0x18>
    osalDbgAssert(buf != NULL, "buffer not found");
 8001876:	4801      	ldr	r0, [pc, #4]	; (800187c <obnotify+0x4c>)
 8001878:	f7fe ff8a 	bl	8000790 <chSysHalt>
 800187c:	08004e50 	.word	0x08004e50

08001880 <sduDataTransmitted>:
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8001880:	b5f0      	push	{r4, r5, r6, r7, lr}
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8001882:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8001886:	b085      	sub	sp, #20
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8001888:	6a1c      	ldr	r4, [r3, #32]
  if (sdup == NULL) {
 800188a:	b30c      	cbz	r4, 80018d0 <sduDataTransmitted+0x50>
 800188c:	4605      	mov	r5, r0
 800188e:	460e      	mov	r6, r1
 8001890:	2320      	movs	r3, #32
 8001892:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001896:	eb00 0781 	add.w	r7, r0, r1, lsl #2
 800189a:	f7ff f8f1 	bl	8000a80 <_dbg_check_lock_from_isr>
  chEvtBroadcastFlagsI(esp, flags);
 800189e:	1d20      	adds	r0, r4, #4
 80018a0:	2108      	movs	r1, #8
 80018a2:	f7ff f865 	bl	8000970 <chEvtBroadcastFlagsI>
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 80018a6:	68fb      	ldr	r3, [r7, #12]
 80018a8:	695b      	ldr	r3, [r3, #20]
 80018aa:	681b      	ldr	r3, [r3, #0]
 80018ac:	b993      	cbnz	r3, 80018d4 <sduDataTransmitted+0x54>
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80018ae:	f104 0044 	add.w	r0, r4, #68	; 0x44
 80018b2:	a903      	add	r1, sp, #12
 80018b4:	f7ff ff4c 	bl	8001750 <obqGetFullBufferI>
  if (buf != NULL) {
 80018b8:	4602      	mov	r2, r0
 80018ba:	b340      	cbz	r0, 800190e <sduDataTransmitted+0x8e>
    usbStartTransmitI(usbp, ep, buf, n);
 80018bc:	9b03      	ldr	r3, [sp, #12]
 80018be:	4631      	mov	r1, r6
 80018c0:	4628      	mov	r0, r5
 80018c2:	f7ff fd5d 	bl	8001380 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
 80018c6:	f7ff f8c3 	bl	8000a50 <_dbg_check_unlock_from_isr>
 80018ca:	2300      	movs	r3, #0
 80018cc:	f383 8811 	msr	BASEPRI, r3
}
 80018d0:	b005      	add	sp, #20
 80018d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  osalDbgCheckClassI();
 80018d4:	f7fe ff84 	bl	80007e0 <chDbgCheckClassI>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 80018d8:	e9d4 2315 	ldrd	r2, r3, [r4, #84]	; 0x54
 80018dc:	429a      	cmp	r2, r3
 80018de:	d026      	beq.n	800192e <sduDataTransmitted+0xae>
  if (obqp->brdptr >= obqp->btop) {
 80018e0:	e9d4 1017 	ldrd	r1, r0, [r4, #92]	; 0x5c
  obqp->bcounter++;
 80018e4:	6d22      	ldr	r2, [r4, #80]	; 0x50
  obqp->brdptr += obqp->bsize;
 80018e6:	4403      	add	r3, r0
  obqp->bcounter++;
 80018e8:	3201      	adds	r2, #1
  if (obqp->brdptr >= obqp->btop) {
 80018ea:	428b      	cmp	r3, r1
  obqp->bcounter++;
 80018ec:	6522      	str	r2, [r4, #80]	; 0x50
  obqp->brdptr += obqp->bsize;
 80018ee:	65a3      	str	r3, [r4, #88]	; 0x58
  if (obqp->brdptr >= obqp->btop) {
 80018f0:	d301      	bcc.n	80018f6 <sduDataTransmitted+0x76>
    obqp->brdptr = obqp->buffers;
 80018f2:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 80018f4:	65a3      	str	r3, [r4, #88]	; 0x58
    obqReleaseEmptyBufferI(&sdup->obqueue);
 80018f6:	f104 0044 	add.w	r0, r4, #68	; 0x44
  chThdDequeueNextI(tqp, msg);
 80018fa:	9001      	str	r0, [sp, #4]
 80018fc:	f7ff f800 	bl	8000900 <chThdDequeueNextI.constprop.0>
 8001900:	9801      	ldr	r0, [sp, #4]
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8001902:	a903      	add	r1, sp, #12
 8001904:	f7ff ff24 	bl	8001750 <obqGetFullBufferI>
  if (buf != NULL) {
 8001908:	4602      	mov	r2, r0
 800190a:	2800      	cmp	r0, #0
 800190c:	d1d6      	bne.n	80018bc <sduDataTransmitted+0x3c>
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800190e:	68fb      	ldr	r3, [r7, #12]
 8001910:	695a      	ldr	r2, [r3, #20]
 8001912:	6812      	ldr	r2, [r2, #0]
 8001914:	2a00      	cmp	r2, #0
 8001916:	d0d6      	beq.n	80018c6 <sduDataTransmitted+0x46>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 8001918:	8a1b      	ldrh	r3, [r3, #16]
 800191a:	3b01      	subs	r3, #1
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800191c:	4013      	ands	r3, r2
 800191e:	d1d2      	bne.n	80018c6 <sduDataTransmitted+0x46>
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 8001920:	4631      	mov	r1, r6
 8001922:	f105 025c 	add.w	r2, r5, #92	; 0x5c
 8001926:	4628      	mov	r0, r5
 8001928:	f7ff fd2a 	bl	8001380 <usbStartTransmitI>
 800192c:	e7cb      	b.n	80018c6 <sduDataTransmitted+0x46>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 800192e:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8001930:	2a00      	cmp	r2, #0
 8001932:	d0d5      	beq.n	80018e0 <sduDataTransmitted+0x60>
 8001934:	4801      	ldr	r0, [pc, #4]	; (800193c <sduDataTransmitted+0xbc>)
 8001936:	f7fe ff2b 	bl	8000790 <chSysHalt>
 800193a:	bf00      	nop
 800193c:	08004f64 	.word	0x08004f64

08001940 <ibqReleaseEmptyBufferS>:
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8001940:	b510      	push	{r4, lr}
 8001942:	4604      	mov	r4, r0
  osalDbgCheckClassS();
 8001944:	f7fe ff3c 	bl	80007c0 <chDbgCheckClassS>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 8001948:	68e3      	ldr	r3, [r4, #12]
 800194a:	b19b      	cbz	r3, 8001974 <ibqReleaseEmptyBufferS+0x34>
  if (ibqp->brdptr >= ibqp->btop) {
 800194c:	e9d4 1006 	ldrd	r1, r0, [r4, #24]
  ibqp->brdptr += ibqp->bsize;
 8001950:	6963      	ldr	r3, [r4, #20]
  ibqp->bcounter--;
 8001952:	68e2      	ldr	r2, [r4, #12]
  ibqp->brdptr += ibqp->bsize;
 8001954:	4403      	add	r3, r0
  if (ibqp->brdptr >= ibqp->btop) {
 8001956:	428b      	cmp	r3, r1
  ibqp->brdptr += ibqp->bsize;
 8001958:	6163      	str	r3, [r4, #20]
    ibqp->brdptr = ibqp->buffers;
 800195a:	bf24      	itt	cs
 800195c:	6a63      	ldrcs	r3, [r4, #36]	; 0x24
 800195e:	6163      	strcs	r3, [r4, #20]
  ibqp->bcounter--;
 8001960:	3a01      	subs	r2, #1
  if (ibqp->notify != NULL) {
 8001962:	6b23      	ldr	r3, [r4, #48]	; 0x30
  ibqp->bcounter--;
 8001964:	60e2      	str	r2, [r4, #12]
  ibqp->ptr = NULL;
 8001966:	2200      	movs	r2, #0
 8001968:	62a2      	str	r2, [r4, #40]	; 0x28
  if (ibqp->notify != NULL) {
 800196a:	b133      	cbz	r3, 800197a <ibqReleaseEmptyBufferS+0x3a>
    ibqp->notify(ibqp);
 800196c:	4620      	mov	r0, r4
}
 800196e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ibqp->notify(ibqp);
 8001972:	4718      	bx	r3
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 8001974:	4801      	ldr	r0, [pc, #4]	; (800197c <ibqReleaseEmptyBufferS+0x3c>)
 8001976:	f7fe ff0b 	bl	8000790 <chSysHalt>
}
 800197a:	bd10      	pop	{r4, pc}
 800197c:	08004ee0 	.word	0x08004ee0

08001980 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8001980:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8001982:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001986:	68da      	ldr	r2, [r3, #12]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8001988:	0792      	lsls	r2, r2, #30
 800198a:	d501      	bpl.n	8001990 <stSetAlarm+0x10>
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 800198c:	6358      	str	r0, [r3, #52]	; 0x34

  st_lld_set_alarm(abstime);
}
 800198e:	bd08      	pop	{r3, pc}
  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8001990:	4801      	ldr	r0, [pc, #4]	; (8001998 <stSetAlarm+0x18>)
 8001992:	f7fe fefd 	bl	8000790 <chSysHalt>
 8001996:	bf00      	nop
 8001998:	08004da8 	.word	0x08004da8
 800199c:	00000000 	.word	0x00000000

080019a0 <chSchWakeupS.constprop.0>:
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80019a0:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
 80019a2:	4d1b      	ldr	r5, [pc, #108]	; (8001a10 <chSchWakeupS.constprop.0+0x70>)
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80019a4:	4604      	mov	r4, r0
  chDbgCheckClassS();
 80019a6:	f7fe ff0b 	bl	80007c0 <chDbgCheckClassS>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80019aa:	682b      	ldr	r3, [r5, #0]
  thread_t *otp = currp;
 80019ac:	69a8      	ldr	r0, [r5, #24]
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80019ae:	42ab      	cmp	r3, r5
 80019b0:	d026      	beq.n	8001a00 <chSchWakeupS.constprop.0+0x60>
 80019b2:	689a      	ldr	r2, [r3, #8]
 80019b4:	6883      	ldr	r3, [r0, #8]
 80019b6:	4293      	cmp	r3, r2
 80019b8:	d31f      	bcc.n	80019fa <chSchWakeupS.constprop.0+0x5a>
  if (ntp->prio <= otp->prio) {
 80019ba:	68a2      	ldr	r2, [r4, #8]
  ntp->u.rdymsg = msg;
 80019bc:	2100      	movs	r1, #0
  if (ntp->prio <= otp->prio) {
 80019be:	429a      	cmp	r2, r3
  ntp->u.rdymsg = msg;
 80019c0:	6261      	str	r1, [r4, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
 80019c2:	d915      	bls.n	80019f0 <chSchWakeupS.constprop.0+0x50>
    otp = chSchReadyAheadI(otp);
 80019c4:	f7fe ff4c 	bl	8000860 <chSchReadyAheadI>
    ntp->state = CH_STATE_CURRENT;
 80019c8:	2301      	movs	r3, #1
 80019ca:	f884 3020 	strb.w	r3, [r4, #32]
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80019ce:	8f2b      	ldrh	r3, [r5, #56]	; 0x38
    currp = ntp;
 80019d0:	61ac      	str	r4, [r5, #24]
 80019d2:	07db      	lsls	r3, r3, #31
    otp = chSchReadyAheadI(otp);
 80019d4:	4605      	mov	r5, r0
 80019d6:	d515      	bpl.n	8001a04 <chSchWakeupS.constprop.0+0x64>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80019d8:	f3ef 8309 	mrs	r3, PSP
    chSysSwitch(ntp, otp);
 80019dc:	69ea      	ldr	r2, [r5, #28]
 80019de:	3b64      	subs	r3, #100	; 0x64
 80019e0:	429a      	cmp	r2, r3
 80019e2:	d812      	bhi.n	8001a0a <chSchWakeupS.constprop.0+0x6a>
 80019e4:	4629      	mov	r1, r5
 80019e6:	4620      	mov	r0, r4
}
 80019e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    chSysSwitch(ntp, otp);
 80019ec:	f7fe bc9c 	b.w	8000328 <_port_switch>
    (void) chSchReadyI(ntp);
 80019f0:	4620      	mov	r0, r4
}
 80019f2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    (void) chSchReadyI(ntp);
 80019f6:	f7fe bf5b 	b.w	80008b0 <chSchReadyI>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80019fa:	4806      	ldr	r0, [pc, #24]	; (8001a14 <chSchWakeupS.constprop.0+0x74>)
 80019fc:	f7fe fec8 	bl	8000790 <chSysHalt>
 8001a00:	6883      	ldr	r3, [r0, #8]
 8001a02:	e7da      	b.n	80019ba <chSchWakeupS.constprop.0+0x1a>
 8001a04:	f7fe fe74 	bl	80006f0 <_trace_switch.part.0>
 8001a08:	e7e6      	b.n	80019d8 <chSchWakeupS.constprop.0+0x38>
    chSysSwitch(ntp, otp);
 8001a0a:	4803      	ldr	r0, [pc, #12]	; (8001a18 <chSchWakeupS.constprop.0+0x78>)
 8001a0c:	f7fe fec0 	bl	8000790 <chSysHalt>
 8001a10:	20000e84 	.word	0x20000e84
 8001a14:	08005158 	.word	0x08005158
 8001a18:	08004cd4 	.word	0x08004cd4
 8001a1c:	00000000 	.word	0x00000000

08001a20 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
 8001a20:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8001a22:	4c15      	ldr	r4, [pc, #84]	; (8001a78 <chSchGoSleepS+0x58>)
 8001a24:	69a5      	ldr	r5, [r4, #24]
void chSchGoSleepS(tstate_t newstate) {
 8001a26:	4606      	mov	r6, r0
  chDbgCheckClassS();
 8001a28:	f7fe feca 	bl	80007c0 <chDbgCheckClassS>
  thread_t *tp = tqp->next;
 8001a2c:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
 8001a2e:	f885 6020 	strb.w	r6, [r5, #32]
  tqp->next             = tp->queue.next;
 8001a32:	681a      	ldr	r2, [r3, #0]
 8001a34:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 8001a36:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8001a38:	6054      	str	r4, [r2, #4]
 8001a3a:	f883 1020 	strb.w	r1, [r3, #32]
 8001a3e:	8f22      	ldrh	r2, [r4, #56]	; 0x38
  currp = queue_fifo_remove(&ch.rlist.queue);
 8001a40:	61a3      	str	r3, [r4, #24]
 8001a42:	07d3      	lsls	r3, r2, #31
 8001a44:	d50b      	bpl.n	8001a5e <chSchGoSleepS+0x3e>
 8001a46:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 8001a4a:	69ea      	ldr	r2, [r5, #28]
 8001a4c:	3b64      	subs	r3, #100	; 0x64
 8001a4e:	429a      	cmp	r2, r3
 8001a50:	d80e      	bhi.n	8001a70 <chSchGoSleepS+0x50>
 8001a52:	69a0      	ldr	r0, [r4, #24]
 8001a54:	4629      	mov	r1, r5
}
 8001a56:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chSysSwitch(currp, otp);
 8001a5a:	f7fe bc65 	b.w	8000328 <_port_switch>
 8001a5e:	4628      	mov	r0, r5
 8001a60:	f7fe fe46 	bl	80006f0 <_trace_switch.part.0>
 8001a64:	f3ef 8309 	mrs	r3, PSP
 8001a68:	69ea      	ldr	r2, [r5, #28]
 8001a6a:	3b64      	subs	r3, #100	; 0x64
 8001a6c:	429a      	cmp	r2, r3
 8001a6e:	d9f0      	bls.n	8001a52 <chSchGoSleepS+0x32>
 8001a70:	4802      	ldr	r0, [pc, #8]	; (8001a7c <chSchGoSleepS+0x5c>)
 8001a72:	f7fe fe8d 	bl	8000790 <chSysHalt>
 8001a76:	bf00      	nop
 8001a78:	20000e84 	.word	0x20000e84
 8001a7c:	08004cd4 	.word	0x08004cd4

08001a80 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8001a80:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001a84:	460c      	mov	r4, r1
 8001a86:	b087      	sub	sp, #28
 8001a88:	4606      	mov	r6, r0
  chDbgCheckClassS();
 8001a8a:	f7fe fe99 	bl	80007c0 <chDbgCheckClassS>
  if (TIME_INFINITE != timeout) {
 8001a8e:	1c63      	adds	r3, r4, #1
 8001a90:	d053      	beq.n	8001b3a <chSchGoSleepTimeoutS+0xba>
                vtfunc_t vtfunc, void *par) {
  virtual_timers_list_t *vtlp = &ch.vtlist;
  virtual_timer_t *p;
  sysinterval_t delta;

  chDbgCheckClassI();
 8001a92:	f7fe fea5 	bl	80007e0 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8001a96:	2c00      	cmp	r4, #0
 8001a98:	d04c      	beq.n	8001b34 <chSchGoSleepTimeoutS+0xb4>
    chVTDoSetI(&vt, timeout, wakeup, currp);
 8001a9a:	4f58      	ldr	r7, [pc, #352]	; (8001bfc <chSchGoSleepTimeoutS+0x17c>)

  vtp->par = par;
  vtp->func = vtfunc;
 8001a9c:	4a58      	ldr	r2, [pc, #352]	; (8001c00 <chSchGoSleepTimeoutS+0x180>)
  vtp->par = par;
 8001a9e:	69bb      	ldr	r3, [r7, #24]
 8001aa0:	9305      	str	r3, [sp, #20]
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (is_vtlist_empty(vtlp)) {
 8001aa2:	46b8      	mov	r8, r7
 8001aa4:	2c02      	cmp	r4, #2
 8001aa6:	f858 0f1c 	ldr.w	r0, [r8, #28]!
  return (systime_t)STM32_ST_TIM->CNT;
 8001aaa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001aae:	bf38      	it	cc
 8001ab0:	2402      	movcc	r4, #2
 8001ab2:	4540      	cmp	r0, r8
 8001ab4:	f8d3 c024 	ldr.w	ip, [r3, #36]	; 0x24
  vtp->func = vtfunc;
 8001ab8:	9204      	str	r2, [sp, #16]
    if (is_vtlist_empty(vtlp)) {
 8001aba:	f000 8081 	beq.w	8001bc0 <chSchGoSleepTimeoutS+0x140>
      return;
    }

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'deltanow'.*/
    deltanow = chTimeDiffX(vtlp->lasttime, now);
 8001abe:	f8d7 e028 	ldr.w	lr, [r7, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8001ac2:	ebac 030e 	sub.w	r3, ip, lr
 8001ac6:	18e4      	adds	r4, r4, r3
    delta    = deltanow + delay;
 8001ac8:	4625      	mov	r5, r4

    /* Scenario where a very large delay exceeded the numeric range, it
       requires a special handling, the compression procedure.*/
    if (delta < deltanow) {
 8001aca:	d23f      	bcs.n	8001b4c <chSchGoSleepTimeoutS+0xcc>
      vt_list_compress(vtlp, deltanow);
      delta -= deltanow;
    }
    else if (delta < vtlp->next->delta) {
 8001acc:	6883      	ldr	r3, [r0, #8]
 8001ace:	429c      	cmp	r4, r3
 8001ad0:	d36f      	bcc.n	8001bb2 <chSchGoSleepTimeoutS+0x132>
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = vtlp->next;
  while (p->delta < delta) {
 8001ad2:	429d      	cmp	r5, r3
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
 8001ad4:	f10d 0904 	add.w	r9, sp, #4
  while (p->delta < delta) {
 8001ad8:	d906      	bls.n	8001ae8 <chSchGoSleepTimeoutS+0x68>
    chDbgAssert(p != vtp, "timer already armed");
 8001ada:	4548      	cmp	r0, r9
 8001adc:	d02a      	beq.n	8001b34 <chSchGoSleepTimeoutS+0xb4>

    delta -= p->delta;
    p = p->next;
 8001ade:	6800      	ldr	r0, [r0, #0]
    delta -= p->delta;
 8001ae0:	1aed      	subs	r5, r5, r3
  while (p->delta < delta) {
 8001ae2:	6883      	ldr	r3, [r0, #8]
 8001ae4:	429d      	cmp	r5, r3
 8001ae6:	d8f8      	bhi.n	8001ada <chSchGoSleepTimeoutS+0x5a>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8001ae8:	6843      	ldr	r3, [r0, #4]
 8001aea:	e9cd 0301 	strd	r0, r3, [sp, #4]
  vtp->prev->next = vtp;
 8001aee:	f8c3 9000 	str.w	r9, [r3]
  p->prev = vtp;
 8001af2:	f8c0 9004 	str.w	r9, [r0, #4]
  vtp->delta = delta;
 8001af6:	9503      	str	r5, [sp, #12]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 8001af8:	6883      	ldr	r3, [r0, #8]
 8001afa:	1b5d      	subs	r5, r3, r5

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  vtlp->delta = (sysinterval_t)-1;
 8001afc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  p->delta -= delta;
 8001b00:	6085      	str	r5, [r0, #8]
  vtlp->delta = (sysinterval_t)-1;
 8001b02:	627b      	str	r3, [r7, #36]	; 0x24
    chSchGoSleepS(newstate);
 8001b04:	4630      	mov	r0, r6
 8001b06:	f7ff ff8b 	bl	8001a20 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8001b0a:	f7fe fe69 	bl	80007e0 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
 8001b0e:	9b04      	ldr	r3, [sp, #16]
 8001b10:	b1bb      	cbz	r3, 8001b42 <chSchGoSleepTimeoutS+0xc2>
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
  virtual_timers_list_t *vtlp = &ch.vtlist;

  chDbgCheckClassI();
 8001b12:	f7fe fe65 	bl	80007e0 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!is_first_timer(vtlp, vtp)) {
 8001b16:	69fb      	ldr	r3, [r7, #28]
 8001b18:	454b      	cmp	r3, r9
 8001b1a:	d02e      	beq.n	8001b7a <chSchGoSleepTimeoutS+0xfa>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8001b1c:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
 8001b20:	6013      	str	r3, [r2, #0]
    vtp->next->prev = vtp->prev;
 8001b22:	9b01      	ldr	r3, [sp, #4]
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (is_timer(vtlp, vtp->next))
 8001b24:	4543      	cmp	r3, r8
    vtp->next->prev = vtp->prev;
 8001b26:	605a      	str	r2, [r3, #4]
    if (is_timer(vtlp, vtp->next))
 8001b28:	d00b      	beq.n	8001b42 <chSchGoSleepTimeoutS+0xc2>
      vtp->next->delta += vtp->delta;
 8001b2a:	689a      	ldr	r2, [r3, #8]
 8001b2c:	9903      	ldr	r1, [sp, #12]
 8001b2e:	440a      	add	r2, r1
 8001b30:	609a      	str	r2, [r3, #8]
 8001b32:	e006      	b.n	8001b42 <chSchGoSleepTimeoutS+0xc2>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8001b34:	4833      	ldr	r0, [pc, #204]	; (8001c04 <chSchGoSleepTimeoutS+0x184>)
 8001b36:	f7fe fe2b 	bl	8000790 <chSysHalt>
    chSchGoSleepS(newstate);
 8001b3a:	4630      	mov	r0, r6
 8001b3c:	f7ff ff70 	bl	8001a20 <chSchGoSleepS>
 8001b40:	4f2e      	ldr	r7, [pc, #184]	; (8001bfc <chSchGoSleepTimeoutS+0x17c>)
  return currp->u.rdymsg;
 8001b42:	69bb      	ldr	r3, [r7, #24]
 8001b44:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 8001b46:	b007      	add	sp, #28
 8001b48:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  while (vtp->delta < deltanow) {
 8001b4c:	6881      	ldr	r1, [r0, #8]
 8001b4e:	428b      	cmp	r3, r1
 8001b50:	d949      	bls.n	8001be6 <chSchGoSleepTimeoutS+0x166>
 8001b52:	4602      	mov	r2, r0
    vtp->delta = (sysinterval_t)0;
 8001b54:	2500      	movs	r5, #0
 8001b56:	6095      	str	r5, [r2, #8]
    vtp        = vtp->next;
 8001b58:	6812      	ldr	r2, [r2, #0]
    deltanow  -= vtp->delta;
 8001b5a:	1a5b      	subs	r3, r3, r1
  while (vtp->delta < deltanow) {
 8001b5c:	6891      	ldr	r1, [r2, #8]
 8001b5e:	4299      	cmp	r1, r3
 8001b60:	d3f9      	bcc.n	8001b56 <chSchGoSleepTimeoutS+0xd6>
  vtlp->lasttime = vtlp->lasttime + deltanow;
 8001b62:	eb0e 0503 	add.w	r5, lr, r3
  if (is_timer(vtlp, vtp)) {
 8001b66:	4542      	cmp	r2, r8
  vtlp->lasttime = vtlp->lasttime + deltanow;
 8001b68:	62bd      	str	r5, [r7, #40]	; 0x28
  if (is_timer(vtlp, vtp)) {
 8001b6a:	d001      	beq.n	8001b70 <chSchGoSleepTimeoutS+0xf0>
    vtp->delta -= deltanow;
 8001b6c:	1acb      	subs	r3, r1, r3
 8001b6e:	6093      	str	r3, [r2, #8]
      delta -= deltanow;
 8001b70:	ebae 050c 	sub.w	r5, lr, ip
 8001b74:	6883      	ldr	r3, [r0, #8]
 8001b76:	4425      	add	r5, r4
 8001b78:	e7ab      	b.n	8001ad2 <chSchGoSleepTimeoutS+0x52>

    return;
  }

  /* Removing the first timer from the list.*/
  vtlp->next = vtp->next;
 8001b7a:	9b01      	ldr	r3, [sp, #4]
 8001b7c:	61fb      	str	r3, [r7, #28]
  vtlp->next->prev = (virtual_timer_t *)vtlp;
  vtp->func = NULL;
 8001b7e:	2200      	movs	r2, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (is_vtlist_empty(vtlp)) {
 8001b80:	4543      	cmp	r3, r8
  vtlp->next->prev = (virtual_timer_t *)vtlp;
 8001b82:	f8c3 8004 	str.w	r8, [r3, #4]
  vtp->func = NULL;
 8001b86:	9204      	str	r2, [sp, #16]
  if (is_vtlist_empty(vtlp)) {
 8001b88:	d034      	beq.n	8001bf4 <chSchGoSleepTimeoutS+0x174>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->next->delta += vtp->delta;
 8001b8a:	689a      	ldr	r2, [r3, #8]
 8001b8c:	9903      	ldr	r1, [sp, #12]
/*  if (vtlp->next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(vtlp->lasttime, chVTGetSystemTimeX());
 8001b8e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  vtlp->next->delta += vtp->delta;
 8001b90:	440a      	add	r2, r1
 8001b92:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8001b96:	609a      	str	r2, [r3, #8]
 8001b98:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8001b9a:	1a19      	subs	r1, r3, r0

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->next->delta) {
 8001b9c:	428a      	cmp	r2, r1
 8001b9e:	d9d0      	bls.n	8001b42 <chSchGoSleepTimeoutS+0xc2>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->next->delta - nowdelta;
 8001ba0:	1ac3      	subs	r3, r0, r3
 8001ba2:	4413      	add	r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8001ba4:	2b01      	cmp	r3, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8001ba6:	bf98      	it	ls
 8001ba8:	1c8a      	addls	r2, r1, #2
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8001baa:	4410      	add	r0, r2
 8001bac:	f7ff fee8 	bl	8001980 <stSetAlarm>
 8001bb0:	e7c7      	b.n	8001b42 <chSchGoSleepTimeoutS+0xc2>
 8001bb2:	eb0e 0004 	add.w	r0, lr, r4
 8001bb6:	f7ff fee3 	bl	8001980 <stSetAlarm>
 8001bba:	69f8      	ldr	r0, [r7, #28]
 8001bbc:	6883      	ldr	r3, [r0, #8]
 8001bbe:	e788      	b.n	8001ad2 <chSchGoSleepTimeoutS+0x52>
      vtlp->lasttime = now;
 8001bc0:	f8c7 c028 	str.w	ip, [r7, #40]	; 0x28
      vtp->delta = delay;
 8001bc4:	9403      	str	r4, [sp, #12]
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8001bc6:	68da      	ldr	r2, [r3, #12]
      vtp->next = (virtual_timer_t *)vtlp;
 8001bc8:	9001      	str	r0, [sp, #4]
      vtlp->next = vtp;
 8001bca:	f10d 0904 	add.w	r9, sp, #4
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8001bce:	f012 0202 	ands.w	r2, r2, #2
      vtlp->prev = vtp;
 8001bd2:	e9c7 9907 	strd	r9, r9, [r7, #28]
      vtp->prev = (virtual_timer_t *)vtlp;
 8001bd6:	9002      	str	r0, [sp, #8]
 8001bd8:	d109      	bne.n	8001bee <chSchGoSleepTimeoutS+0x16e>
  return systime + (systime_t)interval;
 8001bda:	4464      	add	r4, ip
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001bdc:	2102      	movs	r1, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8001bde:	635c      	str	r4, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8001be0:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001be2:	60d9      	str	r1, [r3, #12]
 8001be4:	e78e      	b.n	8001b04 <chSchGoSleepTimeoutS+0x84>
  vtlp->lasttime = vtlp->lasttime + deltanow;
 8001be6:	f8c7 c028 	str.w	ip, [r7, #40]	; 0x28
 8001bea:	4602      	mov	r2, r0
 8001bec:	e7be      	b.n	8001b6c <chSchGoSleepTimeoutS+0xec>
 8001bee:	4806      	ldr	r0, [pc, #24]	; (8001c08 <chSchGoSleepTimeoutS+0x188>)
 8001bf0:	f7fe fdce 	bl	8000790 <chSysHalt>
  STM32_ST_TIM->DIER = 0U;
 8001bf4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001bf8:	60da      	str	r2, [r3, #12]
    return;
 8001bfa:	e7a2      	b.n	8001b42 <chSchGoSleepTimeoutS+0xc2>
 8001bfc:	20000e84 	.word	0x20000e84
 8001c00:	08000ab1 	.word	0x08000ab1
 8001c04:	080050f4 	.word	0x080050f4
 8001c08:	08004d8c 	.word	0x08004d8c
 8001c0c:	00000000 	.word	0x00000000

08001c10 <chThdEnqueueTimeoutS>:
  if (TIME_IMMEDIATE == timeout) {
 8001c10:	b169      	cbz	r1, 8001c2e <chThdEnqueueTimeoutS+0x1e>
  queue_insert(currp, tqp);
 8001c12:	4a08      	ldr	r2, [pc, #32]	; (8001c34 <chThdEnqueueTimeoutS+0x24>)
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8001c14:	b410      	push	{r4}
  queue_insert(currp, tqp);
 8001c16:	6992      	ldr	r2, [r2, #24]
  tp->queue.prev             = tqp->prev;
 8001c18:	6844      	ldr	r4, [r0, #4]
 8001c1a:	4603      	mov	r3, r0
 8001c1c:	e9c2 3400 	strd	r3, r4, [r2]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001c20:	2004      	movs	r0, #4
  tp->queue.prev->queue.next = tp;
 8001c22:	6022      	str	r2, [r4, #0]
}
 8001c24:	f85d 4b04 	ldr.w	r4, [sp], #4
  tqp->prev                  = tp;
 8001c28:	605a      	str	r2, [r3, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001c2a:	f7ff bf29 	b.w	8001a80 <chSchGoSleepTimeoutS>
}
 8001c2e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001c32:	4770      	bx	lr
 8001c34:	20000e84 	.word	0x20000e84
	...

08001c40 <obqGetEmptyBufferTimeoutS>:
                                sysinterval_t timeout) {
 8001c40:	b538      	push	{r3, r4, r5, lr}
 8001c42:	4604      	mov	r4, r0
 8001c44:	460d      	mov	r5, r1
  osalDbgCheckClassS();
 8001c46:	f7fe fdbb 	bl	80007c0 <chDbgCheckClassS>
  while (obqIsFullI(obqp)) {
 8001c4a:	e007      	b.n	8001c5c <obqGetEmptyBufferTimeoutS+0x1c>
    if (obqp->suspended) {
 8001c4c:	7a23      	ldrb	r3, [r4, #8]
 8001c4e:	b993      	cbnz	r3, 8001c76 <obqGetEmptyBufferTimeoutS+0x36>
  return chThdEnqueueTimeoutS(tqp, timeout);
 8001c50:	4629      	mov	r1, r5
 8001c52:	4620      	mov	r0, r4
 8001c54:	f7ff ffdc 	bl	8001c10 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8001c58:	2800      	cmp	r0, #0
 8001c5a:	db0b      	blt.n	8001c74 <obqGetEmptyBufferTimeoutS+0x34>
  while (obqIsFullI(obqp)) {
 8001c5c:	68e3      	ldr	r3, [r4, #12]
 8001c5e:	2b00      	cmp	r3, #0
 8001c60:	d0f4      	beq.n	8001c4c <obqGetEmptyBufferTimeoutS+0xc>
  osalDbgAssert(!obqIsFullI(obqp), "still full");
 8001c62:	68e3      	ldr	r3, [r4, #12]
 8001c64:	b153      	cbz	r3, 8001c7c <obqGetEmptyBufferTimeoutS+0x3c>
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8001c66:	6923      	ldr	r3, [r4, #16]
  obqp->top = obqp->bwrptr + obqp->bsize;
 8001c68:	69e1      	ldr	r1, [r4, #28]
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8001c6a:	1d1a      	adds	r2, r3, #4
  obqp->top = obqp->bwrptr + obqp->bsize;
 8001c6c:	440b      	add	r3, r1
 8001c6e:	e9c4 230a 	strd	r2, r3, [r4, #40]	; 0x28
 8001c72:	2000      	movs	r0, #0
}
 8001c74:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 8001c76:	f06f 0001 	mvn.w	r0, #1
}
 8001c7a:	bd38      	pop	{r3, r4, r5, pc}
  osalDbgAssert(!obqIsFullI(obqp), "still full");
 8001c7c:	4801      	ldr	r0, [pc, #4]	; (8001c84 <obqGetEmptyBufferTimeoutS+0x44>)
 8001c7e:	f7fe fd87 	bl	8000790 <chSysHalt>
 8001c82:	bf00      	nop
 8001c84:	08004fa8 	.word	0x08004fa8
	...

08001c90 <ibqGetFullBufferTimeoutS>:
                                 sysinterval_t timeout) {
 8001c90:	b538      	push	{r3, r4, r5, lr}
 8001c92:	4604      	mov	r4, r0
 8001c94:	460d      	mov	r5, r1
  osalDbgCheckClassS();
 8001c96:	f7fe fd93 	bl	80007c0 <chDbgCheckClassS>
  while (ibqIsEmptyI(ibqp)) {
 8001c9a:	e007      	b.n	8001cac <ibqGetFullBufferTimeoutS+0x1c>
    if (ibqp->suspended) {
 8001c9c:	7a23      	ldrb	r3, [r4, #8]
 8001c9e:	b993      	cbnz	r3, 8001cc6 <ibqGetFullBufferTimeoutS+0x36>
 8001ca0:	4629      	mov	r1, r5
 8001ca2:	4620      	mov	r0, r4
 8001ca4:	f7ff ffb4 	bl	8001c10 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8001ca8:	2800      	cmp	r0, #0
 8001caa:	db0b      	blt.n	8001cc4 <ibqGetFullBufferTimeoutS+0x34>
  while (ibqIsEmptyI(ibqp)) {
 8001cac:	68e3      	ldr	r3, [r4, #12]
 8001cae:	2b00      	cmp	r3, #0
 8001cb0:	d0f4      	beq.n	8001c9c <ibqGetFullBufferTimeoutS+0xc>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 8001cb2:	68e3      	ldr	r3, [r4, #12]
 8001cb4:	b153      	cbz	r3, 8001ccc <ibqGetFullBufferTimeoutS+0x3c>
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8001cb6:	6963      	ldr	r3, [r4, #20]
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8001cb8:	681a      	ldr	r2, [r3, #0]
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8001cba:	3304      	adds	r3, #4
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8001cbc:	441a      	add	r2, r3
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8001cbe:	e9c4 320a 	strd	r3, r2, [r4, #40]	; 0x28
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8001cc2:	2000      	movs	r0, #0
}
 8001cc4:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 8001cc6:	f06f 0001 	mvn.w	r0, #1
}
 8001cca:	bd38      	pop	{r3, r4, r5, pc}
  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 8001ccc:	4801      	ldr	r0, [pc, #4]	; (8001cd4 <ibqGetFullBufferTimeoutS+0x44>)
 8001cce:	f7fe fd5f 	bl	8000790 <chSysHalt>
 8001cd2:	bf00      	nop
 8001cd4:	08004ec4 	.word	0x08004ec4
	...

08001ce0 <usbInitEndpointI>:
                      const USBEndpointConfig *epcp) {
 8001ce0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001ce4:	4604      	mov	r4, r0
 8001ce6:	460d      	mov	r5, r1
 8001ce8:	4616      	mov	r6, r2
  osalDbgCheckClassI();
 8001cea:	f7fe fd79 	bl	80007e0 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 8001cee:	b14c      	cbz	r4, 8001d04 <usbInitEndpointI+0x24>
  osalDbgAssert(usbp->state == USB_ACTIVE,
 8001cf0:	7823      	ldrb	r3, [r4, #0]
 8001cf2:	2b04      	cmp	r3, #4
 8001cf4:	d106      	bne.n	8001d04 <usbInitEndpointI+0x24>
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");
 8001cf6:	eb04 0885 	add.w	r8, r4, r5, lsl #2
 8001cfa:	fa0f f985 	sxth.w	r9, r5
 8001cfe:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8001d02:	b113      	cbz	r3, 8001d0a <usbInitEndpointI+0x2a>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 8001d04:	4857      	ldr	r0, [pc, #348]	; (8001e64 <usbInitEndpointI+0x184>)
 8001d06:	f7fe fd43 	bl	8000790 <chSysHalt>
  if (epcp->in_state != NULL) {
 8001d0a:	6972      	ldr	r2, [r6, #20]
  usbp->epc[ep] = epcp;
 8001d0c:	f8c8 600c 	str.w	r6, [r8, #12]
  if (epcp->in_state != NULL) {
 8001d10:	b11a      	cbz	r2, 8001d1a <usbInitEndpointI+0x3a>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8001d12:	6013      	str	r3, [r2, #0]
 8001d14:	6053      	str	r3, [r2, #4]
 8001d16:	6093      	str	r3, [r2, #8]
 8001d18:	60d3      	str	r3, [r2, #12]
  if (epcp->out_state != NULL) {
 8001d1a:	69b3      	ldr	r3, [r6, #24]
 8001d1c:	b123      	cbz	r3, 8001d28 <usbInitEndpointI+0x48>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 8001d1e:	2200      	movs	r2, #0
 8001d20:	601a      	str	r2, [r3, #0]
 8001d22:	605a      	str	r2, [r3, #4]
 8001d24:	609a      	str	r2, [r3, #8]
 8001d26:	60da      	str	r2, [r3, #12]
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8001d28:	f8d8 300c 	ldr.w	r3, [r8, #12]
  stm32_otg_t *otgp = usbp->otg;
 8001d2c:	6ee6      	ldr	r6, [r4, #108]	; 0x6c
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8001d2e:	681f      	ldr	r7, [r3, #0]
  if (usbp->epc[ep]->out_state != NULL) {
 8001d30:	6998      	ldr	r0, [r3, #24]
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8001d32:	f007 0703 	and.w	r7, r7, #3
 8001d36:	1e7a      	subs	r2, r7, #1
 8001d38:	2a02      	cmp	r2, #2
 8001d3a:	bf98      	it	ls
 8001d3c:	04bf      	lslls	r7, r7, #18
  otgp->oe[ep].DOEPTSIZ = 0;
 8001d3e:	eb06 1245 	add.w	r2, r6, r5, lsl #5
 8001d42:	f04f 0100 	mov.w	r1, #0
 8001d46:	bf98      	it	ls
 8001d48:	f107 5780 	addls.w	r7, r7, #268435456	; 0x10000000
 8001d4c:	f8c2 1b10 	str.w	r1, [r2, #2832]	; 0xb10
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8001d50:	bf8c      	ite	hi
 8001d52:	4f45      	ldrhi	r7, [pc, #276]	; (8001e68 <usbInitEndpointI+0x188>)
 8001d54:	f507 4700 	addls.w	r7, r7, #32768	; 0x8000
  otgp->oe[ep].DOEPTSIZ = 0;
 8001d58:	0169      	lsls	r1, r5, #5
  if (usbp->epc[ep]->out_state != NULL) {
 8001d5a:	2800      	cmp	r0, #0
 8001d5c:	d048      	beq.n	8001df0 <usbInitEndpointI+0x110>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8001d5e:	8a58      	ldrh	r0, [r3, #18]
 8001d60:	f105 0258 	add.w	r2, r5, #88	; 0x58
 8001d64:	0152      	lsls	r2, r2, #5
 8001d66:	4338      	orrs	r0, r7
 8001d68:	50b0      	str	r0, [r6, r2]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8001d6a:	f105 0c10 	add.w	ip, r5, #16
 8001d6e:	f8d6 081c 	ldr.w	r0, [r6, #2076]	; 0x81c
 8001d72:	2201      	movs	r2, #1
 8001d74:	fa02 f20c 	lsl.w	r2, r2, ip
 8001d78:	4302      	orrs	r2, r0
 8001d7a:	f8c6 281c 	str.w	r2, [r6, #2076]	; 0x81c
  otgp->ie[ep].DIEPTSIZ = 0;
 8001d7e:	1872      	adds	r2, r6, r1
  if (usbp->epc[ep]->in_state != NULL) {
 8001d80:	6959      	ldr	r1, [r3, #20]
  otgp->ie[ep].DIEPTSIZ = 0;
 8001d82:	2000      	movs	r0, #0
 8001d84:	f8c2 0910 	str.w	r0, [r2, #2320]	; 0x910
  if (usbp->epc[ep]->in_state != NULL) {
 8001d88:	2900      	cmp	r1, #0
 8001d8a:	d045      	beq.n	8001e18 <usbInitEndpointI+0x138>
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8001d8c:	8a1a      	ldrh	r2, [r3, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 8001d8e:	8b99      	ldrh	r1, [r3, #28]
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8001d90:	0893      	lsrs	r3, r2, #2
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
 8001d92:	e9d4 021c 	ldrd	r0, r2, [r4, #112]	; 0x70
    if (usbp->epc[ep]->in_multiplier > 1)
 8001d96:	2901      	cmp	r1, #1
      fsize *= usbp->epc[ep]->in_multiplier;
 8001d98:	bf88      	it	hi
 8001d9a:	434b      	mulhi	r3, r1
  usbp->pmnext += size;
 8001d9c:	1899      	adds	r1, r3, r2
 8001d9e:	6761      	str	r1, [r4, #116]	; 0x74
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8001da0:	6840      	ldr	r0, [r0, #4]
 8001da2:	4281      	cmp	r1, r0
 8001da4:	d85a      	bhi.n	8001e5c <usbInitEndpointI+0x17c>
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8001da6:	f105 013f 	add.w	r1, r5, #63	; 0x3f
 8001daa:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 8001dae:	eb06 0181 	add.w	r1, r6, r1, lsl #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8001db2:	01aa      	lsls	r2, r5, #6
 8001db4:	f042 0220 	orr.w	r2, r2, #32
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8001db8:	604b      	str	r3, [r1, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8001dba:	6132      	str	r2, [r6, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8001dbc:	6933      	ldr	r3, [r6, #16]
 8001dbe:	069a      	lsls	r2, r3, #26
 8001dc0:	d4fc      	bmi.n	8001dbc <usbInitEndpointI+0xdc>
  chSysPolledDelayX(cycles);
 8001dc2:	2012      	movs	r0, #18
 8001dc4:	f7fe fcd4 	bl	8000770 <chSysPolledDelayX>
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 8001dc8:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8001dcc:	8a1b      	ldrh	r3, [r3, #16]
    otgp->ie[ep].DIEPCTL = ctl |
 8001dce:	f105 0248 	add.w	r2, r5, #72	; 0x48
                           DIEPCTL_TXFNUM(ep) |
 8001dd2:	ea43 5385 	orr.w	r3, r3, r5, lsl #22
    otgp->ie[ep].DIEPCTL = ctl |
 8001dd6:	0152      	lsls	r2, r2, #5
                           DIEPCTL_TXFNUM(ep) |
 8001dd8:	431f      	orrs	r7, r3
    otgp->ie[ep].DIEPCTL = ctl |
 8001dda:	50b7      	str	r7, [r6, r2]
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8001ddc:	2101      	movs	r1, #1
 8001dde:	f8d6 381c 	ldr.w	r3, [r6, #2076]	; 0x81c
 8001de2:	fa01 f505 	lsl.w	r5, r1, r5
 8001de6:	431d      	orrs	r5, r3
 8001de8:	f8c6 581c 	str.w	r5, [r6, #2076]	; 0x81c
}
 8001dec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8001df0:	eb06 1249 	add.w	r2, r6, r9, lsl #5
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8001df4:	f105 0c10 	add.w	ip, r5, #16
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8001df8:	f8d2 0b00 	ldr.w	r0, [r2, #2816]	; 0xb00
 8001dfc:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
 8001e00:	f8c2 0b00 	str.w	r0, [r2, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8001e04:	f8d6 281c 	ldr.w	r2, [r6, #2076]	; 0x81c
 8001e08:	2001      	movs	r0, #1
 8001e0a:	fa00 f00c 	lsl.w	r0, r0, ip
 8001e0e:	ea22 0200 	bic.w	r2, r2, r0
 8001e12:	f8c6 281c 	str.w	r2, [r6, #2076]	; 0x81c
 8001e16:	e7b2      	b.n	8001d7e <usbInitEndpointI+0x9e>
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8001e18:	f105 023f 	add.w	r2, r5, #63	; 0x3f
 8001e1c:	eb06 0282 	add.w	r2, r6, r2, lsl #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8001e20:	01ab      	lsls	r3, r5, #6
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8001e22:	4912      	ldr	r1, [pc, #72]	; (8001e6c <usbInitEndpointI+0x18c>)
 8001e24:	6051      	str	r1, [r2, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8001e26:	f043 0320 	orr.w	r3, r3, #32
 8001e2a:	6133      	str	r3, [r6, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8001e2c:	6933      	ldr	r3, [r6, #16]
 8001e2e:	069b      	lsls	r3, r3, #26
 8001e30:	d4fc      	bmi.n	8001e2c <usbInitEndpointI+0x14c>
 8001e32:	eb06 1949 	add.w	r9, r6, r9, lsl #5
 8001e36:	2012      	movs	r0, #18
 8001e38:	f7fe fc9a 	bl	8000770 <chSysPolledDelayX>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8001e3c:	f8d9 3900 	ldr.w	r3, [r9, #2304]	; 0x900
 8001e40:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8001e44:	f8c9 3900 	str.w	r3, [r9, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 8001e48:	f8d6 381c 	ldr.w	r3, [r6, #2076]	; 0x81c
 8001e4c:	2201      	movs	r2, #1
 8001e4e:	fa02 f505 	lsl.w	r5, r2, r5
 8001e52:	ea23 0505 	bic.w	r5, r3, r5
 8001e56:	f8c6 581c 	str.w	r5, [r6, #2076]	; 0x81c
 8001e5a:	e7c7      	b.n	8001dec <usbInitEndpointI+0x10c>
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8001e5c:	4804      	ldr	r0, [pc, #16]	; (8001e70 <usbInitEndpointI+0x190>)
 8001e5e:	f7fe fc97 	bl	8000790 <chSysHalt>
 8001e62:	bf00      	nop
 8001e64:	08004f50 	.word	0x08004f50
 8001e68:	10008000 	.word	0x10008000
 8001e6c:	02000400 	.word	0x02000400
 8001e70:	08004f08 	.word	0x08004f08
	...

08001e80 <usb_event>:
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8001e80:	b538      	push	{r3, r4, r5, lr}
 8001e82:	2905      	cmp	r1, #5
 8001e84:	d822      	bhi.n	8001ecc <usb_event+0x4c>
 8001e86:	e8df f001 	tbb	[pc, r1]
 8001e8a:	2103      	.short	0x2103
 8001e8c:	22030335 	.word	0x22030335
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001e90:	2320      	movs	r3, #32
 8001e92:	f383 8811 	msr	BASEPRI, r3
  if (bqIsSuspendedX(&sdup->ibqueue) && bqIsSuspendedX(&sdup->obqueue)) {
 8001e96:	4c34      	ldr	r4, [pc, #208]	; (8001f68 <usb_event+0xe8>)
  _dbg_check_lock_from_isr();
 8001e98:	f7fe fdf2 	bl	8000a80 <_dbg_check_lock_from_isr>
 8001e9c:	7d23      	ldrb	r3, [r4, #20]
 8001e9e:	b113      	cbz	r3, 8001ea6 <usb_event+0x26>
 8001ea0:	f894 304c 	ldrb.w	r3, [r4, #76]	; 0x4c
 8001ea4:	b96b      	cbnz	r3, 8001ec2 <usb_event+0x42>
  chEvtBroadcastFlagsI(esp, flags);
 8001ea6:	4831      	ldr	r0, [pc, #196]	; (8001f6c <usb_event+0xec>)
 8001ea8:	2102      	movs	r1, #2
 8001eaa:	f7fe fd61 	bl	8000970 <chEvtBroadcastFlagsI>
  bqSuspendI(&sdup->ibqueue);
 8001eae:	2501      	movs	r5, #1
  chThdDequeueAllI(tqp, msg);
 8001eb0:	482f      	ldr	r0, [pc, #188]	; (8001f70 <usb_event+0xf0>)
 8001eb2:	7525      	strb	r5, [r4, #20]
 8001eb4:	f7fe fd3c 	bl	8000930 <chThdDequeueAllI.constprop.0>
 8001eb8:	482e      	ldr	r0, [pc, #184]	; (8001f74 <usb_event+0xf4>)
  bqSuspendI(&sdup->obqueue);
 8001eba:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
 8001ebe:	f7fe fd37 	bl	8000930 <chThdDequeueAllI.constprop.0>
  _dbg_check_unlock_from_isr();
 8001ec2:	f7fe fdc5 	bl	8000a50 <_dbg_check_unlock_from_isr>
 8001ec6:	2300      	movs	r3, #0
 8001ec8:	f383 8811 	msr	BASEPRI, r3
}
 8001ecc:	bd38      	pop	{r3, r4, r5, pc}
 8001ece:	2320      	movs	r3, #32
 8001ed0:	f383 8811 	msr	BASEPRI, r3
  chEvtBroadcastFlagsI(esp, flags);
 8001ed4:	4d24      	ldr	r5, [pc, #144]	; (8001f68 <usb_event+0xe8>)
  _dbg_check_lock_from_isr();
 8001ed6:	f7fe fdd3 	bl	8000a80 <_dbg_check_lock_from_isr>
  bqResumeX(&sdup->ibqueue);
 8001eda:	2400      	movs	r4, #0
 8001edc:	1d28      	adds	r0, r5, #4
 8001ede:	2101      	movs	r1, #1
 8001ee0:	f7fe fd46 	bl	8000970 <chEvtBroadcastFlagsI>
 8001ee4:	752c      	strb	r4, [r5, #20]
  bqResumeX(&sdup->obqueue);
 8001ee6:	f885 404c 	strb.w	r4, [r5, #76]	; 0x4c
  _dbg_check_unlock_from_isr();
 8001eea:	f7fe fdb1 	bl	8000a50 <_dbg_check_unlock_from_isr>
 8001eee:	f384 8811 	msr	BASEPRI, r4
 8001ef2:	bd38      	pop	{r3, r4, r5, pc}
 8001ef4:	4605      	mov	r5, r0
 8001ef6:	2320      	movs	r3, #32
 8001ef8:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001efc:	f7fe fdc0 	bl	8000a80 <_dbg_check_lock_from_isr>
  ibqp->bcounter  = 0;
 8001f00:	4c19      	ldr	r4, [pc, #100]	; (8001f68 <usb_event+0xe8>)
    usbInitEndpointI(usbp, USB1_DATA_REQUEST_EP, &ep1config);
 8001f02:	4a1d      	ldr	r2, [pc, #116]	; (8001f78 <usb_event+0xf8>)
 8001f04:	4628      	mov	r0, r5
 8001f06:	2101      	movs	r1, #1
 8001f08:	f7ff feea 	bl	8001ce0 <usbInitEndpointI>
    usbInitEndpointI(usbp, USB1_INTERRUPT_REQUEST_EP, &ep2config);
 8001f0c:	2102      	movs	r1, #2
 8001f0e:	4a1b      	ldr	r2, [pc, #108]	; (8001f7c <usb_event+0xfc>)
 8001f10:	4628      	mov	r0, r5
 8001f12:	f7ff fee5 	bl	8001ce0 <usbInitEndpointI>
 8001f16:	2500      	movs	r5, #0
  osalDbgCheckClassI();
 8001f18:	f7fe fc62 	bl	80007e0 <chDbgCheckClassI>
  ibqp->brdptr    = ibqp->buffers;
 8001f1c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001f1e:	6223      	str	r3, [r4, #32]
  chThdDequeueAllI(tqp, msg);
 8001f20:	f104 000c 	add.w	r0, r4, #12
  ibqp->bwrptr    = ibqp->buffers;
 8001f24:	61e3      	str	r3, [r4, #28]
  ibqp->top       = NULL;
 8001f26:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
  ibqp->bcounter  = 0;
 8001f2a:	61a5      	str	r5, [r4, #24]
 8001f2c:	f7fe fd00 	bl	8000930 <chThdDequeueAllI.constprop.0>
  bqResumeX(&sdup->ibqueue);
 8001f30:	7525      	strb	r5, [r4, #20]
  osalDbgCheckClassI();
 8001f32:	f7fe fc55 	bl	80007e0 <chDbgCheckClassI>
  obqp->brdptr    = obqp->buffers;
 8001f36:	e9d4 2319 	ldrd	r2, r3, [r4, #100]	; 0x64
 8001f3a:	f104 0044 	add.w	r0, r4, #68	; 0x44
  obqp->bwrptr    = obqp->buffers;
 8001f3e:	e9c4 3315 	strd	r3, r3, [r4, #84]	; 0x54
  obqp->bcounter  = bqSizeX(obqp);
 8001f42:	6522      	str	r2, [r4, #80]	; 0x50
  obqp->ptr       = NULL;
 8001f44:	66e5      	str	r5, [r4, #108]	; 0x6c
  obqp->top       = NULL;
 8001f46:	6725      	str	r5, [r4, #112]	; 0x70
 8001f48:	f7fe fcf2 	bl	8000930 <chThdDequeueAllI.constprop.0>
  chEvtBroadcastFlagsI(esp, flags);
 8001f4c:	2101      	movs	r1, #1
 8001f4e:	1d20      	adds	r0, r4, #4
  bqResumeX(&sdup->obqueue);
 8001f50:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
 8001f54:	f7fe fd0c 	bl	8000970 <chEvtBroadcastFlagsI>
  (void) sdu_start_receive(sdup);
 8001f58:	4620      	mov	r0, r4
 8001f5a:	f7ff fb49 	bl	80015f0 <sdu_start_receive>
  _dbg_check_unlock_from_isr();
 8001f5e:	f7fe fd77 	bl	8000a50 <_dbg_check_unlock_from_isr>
 8001f62:	f385 8811 	msr	BASEPRI, r5
}
 8001f66:	bd38      	pop	{r3, r4, r5, pc}
 8001f68:	20000904 	.word	0x20000904
 8001f6c:	20000908 	.word	0x20000908
 8001f70:	20000910 	.word	0x20000910
 8001f74:	20000948 	.word	0x20000948
 8001f78:	080052e8 	.word	0x080052e8
 8001f7c:	0800530c 	.word	0x0800530c

08001f80 <chprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8001f80:	b40e      	push	{r1, r2, r3}
 8001f82:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001f86:	b086      	sub	sp, #24
 8001f88:	ab0f      	add	r3, sp, #60	; 0x3c
 8001f8a:	f853 4b04 	ldr.w	r4, [r3], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8001f8e:	9302      	str	r3, [sp, #8]
    c = *fmt++;
 8001f90:	4625      	mov	r5, r4
 8001f92:	f815 1b01 	ldrb.w	r1, [r5], #1
    if (c == 0) {
 8001f96:	2900      	cmp	r1, #0
 8001f98:	f000 823b 	beq.w	8002412 <chprintf+0x492>
 8001f9c:	4607      	mov	r7, r0
 8001f9e:	4699      	mov	r9, r3
  int n = 0;
 8001fa0:	f04f 0800 	mov.w	r8, #0
 8001fa4:	e00c      	b.n	8001fc0 <chprintf+0x40>
      streamPut(chp, (uint8_t)c);
 8001fa6:	683b      	ldr	r3, [r7, #0]
 8001fa8:	4638      	mov	r0, r7
 8001faa:	68db      	ldr	r3, [r3, #12]
      n++;
 8001fac:	f108 0801 	add.w	r8, r8, #1
 8001fb0:	462c      	mov	r4, r5
      streamPut(chp, (uint8_t)c);
 8001fb2:	4798      	blx	r3
    c = *fmt++;
 8001fb4:	4625      	mov	r5, r4
 8001fb6:	f815 1b01 	ldrb.w	r1, [r5], #1
    if (c == 0) {
 8001fba:	2900      	cmp	r1, #0
 8001fbc:	f000 80be 	beq.w	800213c <chprintf+0x1bc>
    if (c != '%') {
 8001fc0:	2925      	cmp	r1, #37	; 0x25
 8001fc2:	d1f0      	bne.n	8001fa6 <chprintf+0x26>
    if (*fmt == '-') {
 8001fc4:	7863      	ldrb	r3, [r4, #1]
 8001fc6:	2b2d      	cmp	r3, #45	; 0x2d
      fmt++;
 8001fc8:	bf04      	itt	eq
 8001fca:	1ca5      	addeq	r5, r4, #2
      left_align = true;
 8001fcc:	2001      	moveq	r0, #1
    if (*fmt == '+') {
 8001fce:	782b      	ldrb	r3, [r5, #0]
    left_align = false;
 8001fd0:	bf18      	it	ne
 8001fd2:	2000      	movne	r0, #0
    if (*fmt == '+') {
 8001fd4:	2b2b      	cmp	r3, #43	; 0x2b
 8001fd6:	bf03      	ittte	eq
 8001fd8:	786b      	ldrbeq	r3, [r5, #1]
      do_sign = true;
 8001fda:	f04f 0e01 	moveq.w	lr, #1
      fmt++;
 8001fde:	4475      	addeq	r5, lr
    do_sign = false;
 8001fe0:	f04f 0e00 	movne.w	lr, #0
    if (*fmt == '0') {
 8001fe4:	2b30      	cmp	r3, #48	; 0x30
      filler = '0';
 8001fe6:	bf05      	ittet	eq
 8001fe8:	461e      	moveq	r6, r3
      fmt++;
 8001fea:	786b      	ldrbeq	r3, [r5, #1]
    filler = ' ';
 8001fec:	2620      	movne	r6, #32
      fmt++;
 8001fee:	3501      	addeq	r5, #1
    if ( *fmt == '*') {
 8001ff0:	2b2a      	cmp	r3, #42	; 0x2a
 8001ff2:	f040 80ac 	bne.w	800214e <chprintf+0x1ce>
      width = va_arg(ap, int);
 8001ff6:	f859 1b04 	ldr.w	r1, [r9], #4
      c = *fmt++;
 8001ffa:	786b      	ldrb	r3, [r5, #1]
 8001ffc:	1cac      	adds	r4, r5, #2
    if (c == '.') {
 8001ffe:	2b2e      	cmp	r3, #46	; 0x2e
 8002000:	f000 8130 	beq.w	8002264 <chprintf+0x2e4>
    precision = 0;
 8002004:	2200      	movs	r2, #0
    if (c == 'l' || c == 'L') {
 8002006:	f003 05df 	and.w	r5, r3, #223	; 0xdf
 800200a:	2d4c      	cmp	r5, #76	; 0x4c
 800200c:	f000 80b2 	beq.w	8002174 <chprintf+0x1f4>
      is_long = (c >= 'A') && (c <= 'Z');
 8002010:	f1a3 0c44 	sub.w	ip, r3, #68	; 0x44
    switch (c) {
 8002014:	f1bc 0f34 	cmp.w	ip, #52	; 0x34
 8002018:	f200 8198 	bhi.w	800234c <chprintf+0x3cc>
 800201c:	e8df f01c 	tbh	[pc, ip, lsl #1]
 8002020:	0196015e 	.word	0x0196015e
 8002024:	01960196 	.word	0x01960196
 8002028:	015e0196 	.word	0x015e0196
 800202c:	01960196 	.word	0x01960196
 8002030:	01960196 	.word	0x01960196
 8002034:	019a0196 	.word	0x019a0196
 8002038:	01960035 	.word	0x01960035
 800203c:	01960196 	.word	0x01960196
 8002040:	00940196 	.word	0x00940196
 8002044:	01960196 	.word	0x01960196
 8002048:	01960035 	.word	0x01960035
 800204c:	01960196 	.word	0x01960196
 8002050:	01960196 	.word	0x01960196
 8002054:	01960196 	.word	0x01960196
 8002058:	01960196 	.word	0x01960196
 800205c:	014d0196 	.word	0x014d0196
 8002060:	0196015e 	.word	0x0196015e
 8002064:	01960196 	.word	0x01960196
 8002068:	015e0196 	.word	0x015e0196
 800206c:	01960196 	.word	0x01960196
 8002070:	01960196 	.word	0x01960196
 8002074:	019a0196 	.word	0x019a0196
 8002078:	01960035 	.word	0x01960035
 800207c:	012d0196 	.word	0x012d0196
 8002080:	00940196 	.word	0x00940196
 8002084:	01960196 	.word	0x01960196
 8002088:	0035      	.short	0x0035
      if (c == 0) {
 800208a:	f04f 0e10 	mov.w	lr, #16
        l = va_arg(ap, unsigned int);
 800208e:	f859 5b04 	ldr.w	r5, [r9], #4
  q = p + MAX_FILLER;
 8002092:	f10d 0317 	add.w	r3, sp, #23
 8002096:	e000      	b.n	800209a <chprintf+0x11a>
  } while ((ll /= radix) != 0);
 8002098:	4663      	mov	r3, ip
    i = (int)(l % radix);
 800209a:	46aa      	mov	sl, r5
 800209c:	fbb5 f5fe 	udiv	r5, r5, lr
 80020a0:	fb0e ab15 	mls	fp, lr, r5, sl
    i += '0';
 80020a4:	f10b 0230 	add.w	r2, fp, #48	; 0x30
    if (i > '9') {
 80020a8:	2a39      	cmp	r2, #57	; 0x39
      i += 'A' - '0' - 10;
 80020aa:	bfc8      	it	gt
 80020ac:	f10b 0237 	addgt.w	r2, fp, #55	; 0x37
    *--q = i;
 80020b0:	b2d2      	uxtb	r2, r2
  } while ((ll /= radix) != 0);
 80020b2:	45f2      	cmp	sl, lr
    *--q = i;
 80020b4:	f103 3cff 	add.w	ip, r3, #4294967295	; 0xffffffff
 80020b8:	f803 2c01 	strb.w	r2, [r3, #-1]
  } while ((ll /= radix) != 0);
 80020bc:	d2ec      	bcs.n	8002098 <chprintf+0x118>
  i = (int)(p + MAX_FILLER - q);
 80020be:	f10d 0a0c 	add.w	sl, sp, #12
 80020c2:	f10d 0517 	add.w	r5, sp, #23
 80020c6:	eba5 050c 	sub.w	r5, r5, ip
 80020ca:	46d6      	mov	lr, sl
 80020cc:	f10d 0c17 	add.w	ip, sp, #23
 80020d0:	e001      	b.n	80020d6 <chprintf+0x156>
 80020d2:	f813 2b01 	ldrb.w	r2, [r3], #1
    *p++ = *q++;
 80020d6:	f80e 2b01 	strb.w	r2, [lr], #1
  while (--i);
 80020da:	4563      	cmp	r3, ip
 80020dc:	d1f9      	bne.n	80020d2 <chprintf+0x152>
 80020de:	1b49      	subs	r1, r1, r5
 80020e0:	3d01      	subs	r5, #1
    if ((width -= i) < 0) {
 80020e2:	ea21 7be1 	bic.w	fp, r1, r1, asr #31
    if (left_align == false) {
 80020e6:	b920      	cbnz	r0, 80020f2 <chprintf+0x172>
    if (width < 0) {
 80020e8:	2900      	cmp	r1, #0
      width = -width;
 80020ea:	f1cb 0b00 	rsb	fp, fp, #0
    if (width < 0) {
 80020ee:	f300 8145 	bgt.w	800237c <chprintf+0x3fc>
    while (--i >= 0) {
 80020f2:	2d00      	cmp	r5, #0
 80020f4:	db0f      	blt.n	8002116 <chprintf+0x196>
 80020f6:	1c6b      	adds	r3, r5, #1
 80020f8:	4453      	add	r3, sl
 80020fa:	9401      	str	r4, [sp, #4]
 80020fc:	461c      	mov	r4, r3
      streamPut(chp, (uint8_t)*s++);
 80020fe:	683a      	ldr	r2, [r7, #0]
 8002100:	f81a 1b01 	ldrb.w	r1, [sl], #1
 8002104:	68d2      	ldr	r2, [r2, #12]
 8002106:	4638      	mov	r0, r7
 8002108:	4790      	blx	r2
    while (--i >= 0) {
 800210a:	45a2      	cmp	sl, r4
 800210c:	d1f7      	bne.n	80020fe <chprintf+0x17e>
 800210e:	f108 0801 	add.w	r8, r8, #1
 8002112:	9c01      	ldr	r4, [sp, #4]
 8002114:	44a8      	add	r8, r5
    while (width) {
 8002116:	f1bb 0f00 	cmp.w	fp, #0
 800211a:	f43f af4b 	beq.w	8001fb4 <chprintf+0x34>
 800211e:	465d      	mov	r5, fp
      streamPut(chp, (uint8_t)filler);
 8002120:	683b      	ldr	r3, [r7, #0]
 8002122:	4631      	mov	r1, r6
 8002124:	68db      	ldr	r3, [r3, #12]
 8002126:	4638      	mov	r0, r7
 8002128:	4798      	blx	r3
    while (width) {
 800212a:	3d01      	subs	r5, #1
 800212c:	d1f8      	bne.n	8002120 <chprintf+0x1a0>
    c = *fmt++;
 800212e:	4625      	mov	r5, r4
 8002130:	44d8      	add	r8, fp
 8002132:	f815 1b01 	ldrb.w	r1, [r5], #1
    if (c == 0) {
 8002136:	2900      	cmp	r1, #0
 8002138:	f47f af42 	bne.w	8001fc0 <chprintf+0x40>
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 800213c:	4640      	mov	r0, r8
 800213e:	b006      	add	sp, #24
 8002140:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002144:	b003      	add	sp, #12
 8002146:	4770      	bx	lr
      if (c == 0) {
 8002148:	f04f 0e0a 	mov.w	lr, #10
 800214c:	e79f      	b.n	800208e <chprintf+0x10e>
        c = *fmt++;
 800214e:	1c6c      	adds	r4, r5, #1
        if (c == 0) {
 8002150:	2b00      	cmp	r3, #0
 8002152:	d0f3      	beq.n	800213c <chprintf+0x1bc>
      width = 0;
 8002154:	2100      	movs	r1, #0
        if (c >= '0' && c <= '9') {
 8002156:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800215a:	b2d2      	uxtb	r2, r2
 800215c:	2a09      	cmp	r2, #9
          width = width * 10 + c;
 800215e:	eb01 0581 	add.w	r5, r1, r1, lsl #2
        if (c >= '0' && c <= '9') {
 8002162:	f63f af4c 	bhi.w	8001ffe <chprintf+0x7e>
        c = *fmt++;
 8002166:	f814 3b01 	ldrb.w	r3, [r4], #1
          width = width * 10 + c;
 800216a:	eb02 0145 	add.w	r1, r2, r5, lsl #1
        if (c == 0) {
 800216e:	2b00      	cmp	r3, #0
 8002170:	d1f1      	bne.n	8002156 <chprintf+0x1d6>
 8002172:	e7e3      	b.n	800213c <chprintf+0x1bc>
      c = *fmt++;
 8002174:	f814 3b01 	ldrb.w	r3, [r4], #1
      if (c == 0) {
 8002178:	2b00      	cmp	r3, #0
 800217a:	d0df      	beq.n	800213c <chprintf+0x1bc>
    switch (c) {
 800217c:	f1a3 0544 	sub.w	r5, r3, #68	; 0x44
 8002180:	2d34      	cmp	r5, #52	; 0x34
 8002182:	f200 80e3 	bhi.w	800234c <chprintf+0x3cc>
 8002186:	f20f 0c08 	addw	ip, pc, #8
 800218a:	f85c f025 	ldr.w	pc, [ip, r5, lsl #2]
 800218e:	bf00      	nop
 8002190:	080022dd 	.word	0x080022dd
 8002194:	0800234d 	.word	0x0800234d
 8002198:	0800234d 	.word	0x0800234d
 800219c:	0800234d 	.word	0x0800234d
 80021a0:	0800234d 	.word	0x0800234d
 80021a4:	080022dd 	.word	0x080022dd
 80021a8:	0800234d 	.word	0x0800234d
 80021ac:	0800234d 	.word	0x0800234d
 80021b0:	0800234d 	.word	0x0800234d
 80021b4:	0800234d 	.word	0x0800234d
 80021b8:	0800234d 	.word	0x0800234d
 80021bc:	08002355 	.word	0x08002355
 80021c0:	0800208b 	.word	0x0800208b
 80021c4:	0800234d 	.word	0x0800234d
 80021c8:	0800234d 	.word	0x0800234d
 80021cc:	0800234d 	.word	0x0800234d
 80021d0:	0800234d 	.word	0x0800234d
 80021d4:	08002149 	.word	0x08002149
 80021d8:	0800234d 	.word	0x0800234d
 80021dc:	0800234d 	.word	0x0800234d
 80021e0:	0800208b 	.word	0x0800208b
 80021e4:	0800234d 	.word	0x0800234d
 80021e8:	0800234d 	.word	0x0800234d
 80021ec:	0800234d 	.word	0x0800234d
 80021f0:	0800234d 	.word	0x0800234d
 80021f4:	0800234d 	.word	0x0800234d
 80021f8:	0800234d 	.word	0x0800234d
 80021fc:	0800234d 	.word	0x0800234d
 8002200:	0800234d 	.word	0x0800234d
 8002204:	0800234d 	.word	0x0800234d
 8002208:	0800234d 	.word	0x0800234d
 800220c:	080022bb 	.word	0x080022bb
 8002210:	080022dd 	.word	0x080022dd
 8002214:	0800234d 	.word	0x0800234d
 8002218:	0800234d 	.word	0x0800234d
 800221c:	0800234d 	.word	0x0800234d
 8002220:	0800234d 	.word	0x0800234d
 8002224:	080022dd 	.word	0x080022dd
 8002228:	0800234d 	.word	0x0800234d
 800222c:	0800234d 	.word	0x0800234d
 8002230:	0800234d 	.word	0x0800234d
 8002234:	0800234d 	.word	0x0800234d
 8002238:	0800234d 	.word	0x0800234d
 800223c:	08002355 	.word	0x08002355
 8002240:	0800208b 	.word	0x0800208b
 8002244:	0800234d 	.word	0x0800234d
 8002248:	0800234d 	.word	0x0800234d
 800224c:	0800227b 	.word	0x0800227b
 8002250:	0800234d 	.word	0x0800234d
 8002254:	08002149 	.word	0x08002149
 8002258:	0800234d 	.word	0x0800234d
 800225c:	0800234d 	.word	0x0800234d
 8002260:	0800208b 	.word	0x0800208b
      c = *fmt++;
 8002264:	7823      	ldrb	r3, [r4, #0]
      if (c == 0) {
 8002266:	2b00      	cmp	r3, #0
 8002268:	f43f af68 	beq.w	800213c <chprintf+0x1bc>
      if (c == '*') {
 800226c:	2b2a      	cmp	r3, #42	; 0x2a
 800226e:	d174      	bne.n	800235a <chprintf+0x3da>
        c = *fmt++;
 8002270:	7863      	ldrb	r3, [r4, #1]
        precision = va_arg(ap, int);
 8002272:	f859 2b04 	ldr.w	r2, [r9], #4
        c = *fmt++;
 8002276:	3402      	adds	r4, #2
 8002278:	e6c5      	b.n	8002006 <chprintf+0x86>
      if ((s = va_arg(ap, char *)) == 0) {
 800227a:	f859 ab04 	ldr.w	sl, [r9], #4
 800227e:	f1ba 0f00 	cmp.w	sl, #0
 8002282:	f000 80bc 	beq.w	80023fe <chprintf+0x47e>
 8002286:	f89a 3000 	ldrb.w	r3, [sl]
      if (precision == 0) {
 800228a:	2a00      	cmp	r2, #0
 800228c:	f040 80aa 	bne.w	80023e4 <chprintf+0x464>
      for (p = s; *p && (--precision >= 0); p++)
 8002290:	2b00      	cmp	r3, #0
 8002292:	f000 80ab 	beq.w	80023ec <chprintf+0x46c>
 8002296:	f647 72fe 	movw	r2, #32766	; 0x7ffe
 800229a:	4655      	mov	r5, sl
 800229c:	e001      	b.n	80022a2 <chprintf+0x322>
 800229e:	42d3      	cmn	r3, r2
 80022a0:	d405      	bmi.n	80022ae <chprintf+0x32e>
 80022a2:	f815 6f01 	ldrb.w	r6, [r5, #1]!
 80022a6:	ebaa 0305 	sub.w	r3, sl, r5
 80022aa:	2e00      	cmp	r6, #0
 80022ac:	d1f7      	bne.n	800229e <chprintf+0x31e>
 80022ae:	eba5 050a 	sub.w	r5, r5, sl
 80022b2:	1b49      	subs	r1, r1, r5
      filler = ' ';
 80022b4:	2620      	movs	r6, #32
 80022b6:	3d01      	subs	r5, #1
 80022b8:	e713      	b.n	80020e2 <chprintf+0x162>
      *p++ = va_arg(ap, int);
 80022ba:	f859 3b04 	ldr.w	r3, [r9], #4
 80022be:	f88d 300c 	strb.w	r3, [sp, #12]
      break;
 80022c2:	3901      	subs	r1, #1
      filler = ' ';
 80022c4:	2620      	movs	r6, #32
    if ((width -= i) < 0) {
 80022c6:	ea21 7be1 	bic.w	fp, r1, r1, asr #31
    if (left_align == false) {
 80022ca:	b918      	cbnz	r0, 80022d4 <chprintf+0x354>
    if (width < 0) {
 80022cc:	2900      	cmp	r1, #0
      width = -width;
 80022ce:	f1cb 0b00 	rsb	fp, fp, #0
    if (width < 0) {
 80022d2:	dc72      	bgt.n	80023ba <chprintf+0x43a>
    if (left_align == false) {
 80022d4:	2500      	movs	r5, #0
 80022d6:	f10d 0a0c 	add.w	sl, sp, #12
 80022da:	e70c      	b.n	80020f6 <chprintf+0x176>
        l = va_arg(ap, int);
 80022dc:	f859 cb04 	ldr.w	ip, [r9], #4
      if (l < 0) {
 80022e0:	f1bc 0f00 	cmp.w	ip, #0
 80022e4:	db5f      	blt.n	80023a6 <chprintf+0x426>
        if (do_sign) {
 80022e6:	f1be 0f00 	cmp.w	lr, #0
 80022ea:	f000 808e 	beq.w	800240a <chprintf+0x48a>
          *p++ = '+';
 80022ee:	232b      	movs	r3, #43	; 0x2b
 80022f0:	f88d 300c 	strb.w	r3, [sp, #12]
 80022f4:	f10d 050d 	add.w	r5, sp, #13
 80022f8:	f10d 0a0c 	add.w	sl, sp, #12
  q = p + MAX_FILLER;
 80022fc:	f105 030b 	add.w	r3, r5, #11
 8002300:	9301      	str	r3, [sp, #4]
 8002302:	461a      	mov	r2, r3
    i = (int)(l % radix);
 8002304:	4b47      	ldr	r3, [pc, #284]	; (8002424 <chprintf+0x4a4>)
 8002306:	fba3 e30c 	umull	lr, r3, r3, ip
 800230a:	08db      	lsrs	r3, r3, #3
 800230c:	eb03 0b83 	add.w	fp, r3, r3, lsl #2
 8002310:	469e      	mov	lr, r3
 8002312:	ebac 034b 	sub.w	r3, ip, fp, lsl #1
    i += '0';
 8002316:	3330      	adds	r3, #48	; 0x30
    i = (int)(l % radix);
 8002318:	46e3      	mov	fp, ip
    *--q = i;
 800231a:	b2db      	uxtb	r3, r3
  } while ((ll /= radix) != 0);
 800231c:	f1bb 0f09 	cmp.w	fp, #9
    *--q = i;
 8002320:	f802 3d01 	strb.w	r3, [r2, #-1]!
    l /= radix;
 8002324:	46f4      	mov	ip, lr
  } while ((ll /= radix) != 0);
 8002326:	dced      	bgt.n	8002304 <chprintf+0x384>
 8002328:	469e      	mov	lr, r3
  i = (int)(p + MAX_FILLER - q);
 800232a:	9b01      	ldr	r3, [sp, #4]
 800232c:	eba3 0c02 	sub.w	ip, r3, r2
 8002330:	44ac      	add	ip, r5
 8002332:	4673      	mov	r3, lr
 8002334:	e001      	b.n	800233a <chprintf+0x3ba>
 8002336:	f812 3f01 	ldrb.w	r3, [r2, #1]!
    *p++ = *q++;
 800233a:	f805 3b01 	strb.w	r3, [r5], #1
  while (--i);
 800233e:	4565      	cmp	r5, ip
 8002340:	d1f9      	bne.n	8002336 <chprintf+0x3b6>
 8002342:	eba5 050a 	sub.w	r5, r5, sl
 8002346:	1b49      	subs	r1, r1, r5
 8002348:	3d01      	subs	r5, #1
 800234a:	e6ca      	b.n	80020e2 <chprintf+0x162>
      *p++ = c;
 800234c:	f88d 300c 	strb.w	r3, [sp, #12]
      break;
 8002350:	3901      	subs	r1, #1
 8002352:	e7b8      	b.n	80022c6 <chprintf+0x346>
      if (c == 0) {
 8002354:	f04f 0e08 	mov.w	lr, #8
 8002358:	e699      	b.n	800208e <chprintf+0x10e>
      c = *fmt++;
 800235a:	3401      	adds	r4, #1
    precision = 0;
 800235c:	2200      	movs	r2, #0
        while (c >= '0' && c <= '9') {
 800235e:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
 8002362:	b2ed      	uxtb	r5, r5
 8002364:	2d09      	cmp	r5, #9
          precision = precision * 10 + c;
 8002366:	eb02 0c82 	add.w	ip, r2, r2, lsl #2
        while (c >= '0' && c <= '9') {
 800236a:	f63f ae4c 	bhi.w	8002006 <chprintf+0x86>
          c = *fmt++;
 800236e:	f814 3b01 	ldrb.w	r3, [r4], #1
          precision = precision * 10 + c;
 8002372:	eb05 024c 	add.w	r2, r5, ip, lsl #1
          if (c == 0) {
 8002376:	2b00      	cmp	r3, #0
 8002378:	d1f1      	bne.n	800235e <chprintf+0x3de>
 800237a:	e6df      	b.n	800213c <chprintf+0x1bc>
      width = -width;
 800237c:	f8cd b004 	str.w	fp, [sp, #4]
      if (*s == '-' && filler == '0') {
 8002380:	f89a 1000 	ldrb.w	r1, [sl]
 8002384:	292d      	cmp	r1, #45	; 0x2d
 8002386:	d021      	beq.n	80023cc <chprintf+0x44c>
        streamPut(chp, (uint8_t)filler);
 8002388:	683b      	ldr	r3, [r7, #0]
 800238a:	4631      	mov	r1, r6
 800238c:	68db      	ldr	r3, [r3, #12]
 800238e:	4638      	mov	r0, r7
 8002390:	4798      	blx	r3
      } while (++width != 0);
 8002392:	f11b 0b01 	adds.w	fp, fp, #1
 8002396:	d1f7      	bne.n	8002388 <chprintf+0x408>
 8002398:	9b01      	ldr	r3, [sp, #4]
    while (--i >= 0) {
 800239a:	2d00      	cmp	r5, #0
 800239c:	eba8 0803 	sub.w	r8, r8, r3
 80023a0:	f6bf aea9 	bge.w	80020f6 <chprintf+0x176>
 80023a4:	e606      	b.n	8001fb4 <chprintf+0x34>
        *p++ = '-';
 80023a6:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 80023a8:	f1cc 0c00 	rsb	ip, ip, #0
        *p++ = '-';
 80023ac:	f88d 300c 	strb.w	r3, [sp, #12]
 80023b0:	f10d 050d 	add.w	r5, sp, #13
 80023b4:	f10d 0a0c 	add.w	sl, sp, #12
 80023b8:	e7a0      	b.n	80022fc <chprintf+0x37c>
      if (*s == '-' && filler == '0') {
 80023ba:	f89d 100c 	ldrb.w	r1, [sp, #12]
      width = -width;
 80023be:	f8cd b004 	str.w	fp, [sp, #4]
      if (*s == '-' && filler == '0') {
 80023c2:	292d      	cmp	r1, #45	; 0x2d
    if (width < 0) {
 80023c4:	f10d 0a0c 	add.w	sl, sp, #12
 80023c8:	4605      	mov	r5, r0
      if (*s == '-' && filler == '0') {
 80023ca:	d1dd      	bne.n	8002388 <chprintf+0x408>
 80023cc:	2e30      	cmp	r6, #48	; 0x30
 80023ce:	d1db      	bne.n	8002388 <chprintf+0x408>
        streamPut(chp, (uint8_t)*s++);
 80023d0:	683a      	ldr	r2, [r7, #0]
 80023d2:	4638      	mov	r0, r7
 80023d4:	68d2      	ldr	r2, [r2, #12]
 80023d6:	4790      	blx	r2
 80023d8:	f10a 0a01 	add.w	sl, sl, #1
        n++;
 80023dc:	f108 0801 	add.w	r8, r8, #1
        i--;
 80023e0:	3d01      	subs	r5, #1
 80023e2:	e7d1      	b.n	8002388 <chprintf+0x408>
      for (p = s; *p && (--precision >= 0); p++)
 80023e4:	b113      	cbz	r3, 80023ec <chprintf+0x46c>
 80023e6:	3a01      	subs	r2, #1
 80023e8:	f57f af57 	bpl.w	800229a <chprintf+0x31a>
    if ((width -= i) < 0) {
 80023ec:	ea21 7be1 	bic.w	fp, r1, r1, asr #31
    if (left_align == false) {
 80023f0:	b918      	cbnz	r0, 80023fa <chprintf+0x47a>
    if (width < 0) {
 80023f2:	2900      	cmp	r1, #0
      width = -width;
 80023f4:	f1cb 0b00 	rsb	fp, fp, #0
    if (width < 0) {
 80023f8:	dc0d      	bgt.n	8002416 <chprintf+0x496>
    if (left_align == false) {
 80023fa:	2620      	movs	r6, #32
 80023fc:	e68b      	b.n	8002116 <chprintf+0x196>
        s = "(null)";
 80023fe:	f8df a028 	ldr.w	sl, [pc, #40]	; 8002428 <chprintf+0x4a8>
      if (precision == 0) {
 8002402:	2a00      	cmp	r2, #0
 8002404:	f43f af47 	beq.w	8002296 <chprintf+0x316>
 8002408:	e7ed      	b.n	80023e6 <chprintf+0x466>
    p = tmpbuf;
 800240a:	f10d 0a0c 	add.w	sl, sp, #12
 800240e:	4655      	mov	r5, sl
 8002410:	e774      	b.n	80022fc <chprintf+0x37c>
  int n = 0;
 8002412:	4688      	mov	r8, r1
  return formatted_bytes;
 8002414:	e692      	b.n	800213c <chprintf+0x1bc>
      width = -width;
 8002416:	f8cd b004 	str.w	fp, [sp, #4]
    if (width < 0) {
 800241a:	2620      	movs	r6, #32
 800241c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 8002420:	e7ae      	b.n	8002380 <chprintf+0x400>
 8002422:	bf00      	nop
 8002424:	cccccccd 	.word	0xcccccccd
 8002428:	08004ce4 	.word	0x08004ce4
 800242c:	00000000 	.word	0x00000000

08002430 <_usb_ep0setup>:
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8002430:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 8002432:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8002436:	4604      	mov	r4, r0
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 8002438:	b113      	cbz	r3, 8002440 <_usb_ep0setup+0x10>
    usbp->ep0state = USB_EP0_STP_WAITING;
 800243a:	2300      	movs	r3, #0
 800243c:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 8002440:	eb04 0181 	add.w	r1, r4, r1, lsl #2
  if ((usbp->config->requests_hook_cb == NULL) ||
 8002444:	6862      	ldr	r2, [r4, #4]
 8002446:	68cb      	ldr	r3, [r1, #12]
 8002448:	6a1b      	ldr	r3, [r3, #32]
 800244a:	6819      	ldr	r1, [r3, #0]
 800244c:	685b      	ldr	r3, [r3, #4]
 800244e:	6623      	str	r3, [r4, #96]	; 0x60
 8002450:	65e1      	str	r1, [r4, #92]	; 0x5c
 8002452:	6893      	ldr	r3, [r2, #8]
 8002454:	b34b      	cbz	r3, 80024aa <_usb_ep0setup+0x7a>
      !(usbp->config->requests_hook_cb(usbp))) {
 8002456:	4620      	mov	r0, r4
 8002458:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 800245a:	b330      	cbz	r0, 80024aa <_usb_ep0setup+0x7a>
 800245c:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800245e:	f894 005c 	ldrb.w	r0, [r4, #92]	; 0x5c
  hw |= (uint16_t)*p << 8U;
 8002462:	f894 1063 	ldrb.w	r1, [r4, #99]	; 0x63
 8002466:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
  max = (size_t)get_hword(&usbp->setup[6]);
 800246a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  if (usbp->ep0n > max) {
 800246e:	429a      	cmp	r2, r3
    usbp->ep0n = max;
 8002470:	bf3c      	itt	cc
 8002472:	6562      	strcc	r2, [r4, #84]	; 0x54
 8002474:	4613      	movcc	r3, r2
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8002476:	0602      	lsls	r2, r0, #24
 8002478:	f100 80cf 	bmi.w	800261a <_usb_ep0setup+0x1ea>
    if (usbp->ep0n != 0U) {
 800247c:	2b00      	cmp	r3, #0
 800247e:	f000 808b 	beq.w	8002598 <_usb_ep0setup+0x168>
      usbp->ep0state = USB_EP0_OUT_RX;
 8002482:	2315      	movs	r3, #21
 8002484:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8002488:	2320      	movs	r3, #32
 800248a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 800248e:	f7fe faf7 	bl	8000a80 <_dbg_check_lock_from_isr>
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
 8002492:	e9d4 2314 	ldrd	r2, r3, [r4, #80]	; 0x50
 8002496:	4620      	mov	r0, r4
 8002498:	2100      	movs	r1, #0
 800249a:	f7fe ffe1 	bl	8001460 <usbStartReceiveI>
  _dbg_check_unlock_from_isr();
 800249e:	f7fe fad7 	bl	8000a50 <_dbg_check_unlock_from_isr>
 80024a2:	2300      	movs	r3, #0
 80024a4:	f383 8811 	msr	BASEPRI, r3
}
 80024a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 80024aa:	f894 005c 	ldrb.w	r0, [r4, #92]	; 0x5c
 80024ae:	f010 0560 	ands.w	r5, r0, #96	; 0x60
 80024b2:	d11c      	bne.n	80024ee <_usb_ep0setup+0xbe>
           ((uint32_t)usbp->setup[1] << 8U))) {
 80024b4:	f894 205d 	ldrb.w	r2, [r4, #93]	; 0x5d
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80024b8:	f000 037f 	and.w	r3, r0, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 80024bc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80024c0:	f240 3202 	movw	r2, #770	; 0x302
 80024c4:	4293      	cmp	r3, r2
 80024c6:	f000 80ea 	beq.w	800269e <_usb_ep0setup+0x26e>
 80024ca:	d844      	bhi.n	8002556 <_usb_ep0setup+0x126>
 80024cc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80024d0:	f000 8113 	beq.w	80026fa <_usb_ep0setup+0x2ca>
 80024d4:	d922      	bls.n	800251c <_usb_ep0setup+0xec>
 80024d6:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 80024da:	f000 80f7 	beq.w	80026cc <_usb_ep0setup+0x29c>
 80024de:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80024e2:	d104      	bne.n	80024ee <_usb_ep0setup+0xbe>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80024e4:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 80024e8:	2b01      	cmp	r3, #1
 80024ea:	f000 80b7 	beq.w	800265c <_usb_ep0setup+0x22c>
 80024ee:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 80024f0:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80024f4:	6861      	ldr	r1, [r4, #4]
 80024f6:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80024fa:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 80024fe:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8002502:	680d      	ldr	r5, [r1, #0]
 8002504:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8002508:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 800250c:	b115      	cbz	r5, 8002514 <_usb_ep0setup+0xe4>
 800250e:	2106      	movs	r1, #6
 8002510:	4620      	mov	r0, r4
 8002512:	47a8      	blx	r5
      usbp->ep0state = USB_EP0_ERROR;
 8002514:	2306      	movs	r3, #6
 8002516:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
}
 800251a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800251c:	2b01      	cmp	r3, #1
 800251e:	d055      	beq.n	80025cc <_usb_ep0setup+0x19c>
 8002520:	2b02      	cmp	r3, #2
 8002522:	d145      	bne.n	80025b0 <_usb_ep0setup+0x180>
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8002524:	f994 1060 	ldrsb.w	r1, [r4, #96]	; 0x60
 8002528:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
 800252c:	2900      	cmp	r1, #0
  ctl = usbp->otg->ie[ep].DIEPCTL;
 800252e:	f002 010f 	and.w	r1, r2, #15
 8002532:	bfb4      	ite	lt
 8002534:	3148      	addlt	r1, #72	; 0x48
  ctl = usbp->otg->oe[ep].DOEPCTL;
 8002536:	3158      	addge	r1, #88	; 0x58
 8002538:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800253a:	0149      	lsls	r1, r1, #5
 800253c:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 800253e:	040d      	lsls	r5, r1, #16
 8002540:	d5d6      	bpl.n	80024f0 <_usb_ep0setup+0xc0>
  if (ctl & DOEPCTL_STALL)
 8002542:	0289      	lsls	r1, r1, #10
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8002544:	bf4c      	ite	mi
 8002546:	4aae      	ldrmi	r2, [pc, #696]	; (8002800 <_usb_ep0setup+0x3d0>)
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8002548:	4aae      	ldrpl	r2, [pc, #696]	; (8002804 <_usb_ep0setup+0x3d4>)
 800254a:	6522      	str	r2, [r4, #80]	; 0x50
 800254c:	2102      	movs	r1, #2
 800254e:	2200      	movs	r2, #0
 8002550:	e9c4 1215 	strd	r1, r2, [r4, #84]	; 0x54
        return true;
 8002554:	e785      	b.n	8002462 <_usb_ep0setup+0x32>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8002556:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800255a:	f000 80dd 	beq.w	8002718 <_usb_ep0setup+0x2e8>
 800255e:	d93c      	bls.n	80025da <_usb_ep0setup+0x1aa>
 8002560:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 8002564:	d12e      	bne.n	80025c4 <_usb_ep0setup+0x194>
      if (usbp->state == USB_ACTIVE) {
 8002566:	7823      	ldrb	r3, [r4, #0]
 8002568:	2b04      	cmp	r3, #4
 800256a:	f000 8081 	beq.w	8002670 <_usb_ep0setup+0x240>
      if (usbp->setup[2] != 0U) {
 800256e:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 8002572:	b14b      	cbz	r3, 8002588 <_usb_ep0setup+0x158>
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8002574:	6862      	ldr	r2, [r4, #4]
        usbp->configuration = usbp->setup[2];
 8002576:	f884 3067 	strb.w	r3, [r4, #103]	; 0x67
        usbp->state = USB_ACTIVE;
 800257a:	2104      	movs	r1, #4
 800257c:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 800257e:	6813      	ldr	r3, [r2, #0]
 8002580:	b113      	cbz	r3, 8002588 <_usb_ep0setup+0x158>
 8002582:	2102      	movs	r1, #2
 8002584:	4620      	mov	r0, r4
 8002586:	4798      	blx	r3
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8002588:	2300      	movs	r3, #0
 800258a:	e9c4 3314 	strd	r3, r3, [r4, #80]	; 0x50
 800258e:	f894 005c 	ldrb.w	r0, [r4, #92]	; 0x5c
 8002592:	65a3      	str	r3, [r4, #88]	; 0x58
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8002594:	0603      	lsls	r3, r0, #24
 8002596:	d455      	bmi.n	8002644 <_usb_ep0setup+0x214>
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8002598:	230b      	movs	r3, #11
 800259a:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 800259e:	2320      	movs	r3, #32
 80025a0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 80025a4:	f7fe fa6c 	bl	8000a80 <_dbg_check_lock_from_isr>
      usbStartTransmitI(usbp, 0, NULL, 0);
 80025a8:	2300      	movs	r3, #0
 80025aa:	4620      	mov	r0, r4
 80025ac:	461a      	mov	r2, r3
 80025ae:	e040      	b.n	8002632 <_usb_ep0setup+0x202>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80025b0:	2b00      	cmp	r3, #0
 80025b2:	d19c      	bne.n	80024ee <_usb_ep0setup+0xbe>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 80025b4:	2202      	movs	r2, #2
 80025b6:	f104 0164 	add.w	r1, r4, #100	; 0x64
 80025ba:	65a3      	str	r3, [r4, #88]	; 0x58
 80025bc:	e9c4 1214 	strd	r1, r2, [r4, #80]	; 0x50
 80025c0:	4613      	mov	r3, r2
 80025c2:	e74e      	b.n	8002462 <_usb_ep0setup+0x32>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80025c4:	f640 4202 	movw	r2, #3074	; 0xc02
 80025c8:	4293      	cmp	r3, r2
 80025ca:	d190      	bne.n	80024ee <_usb_ep0setup+0xbe>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 80025cc:	4b8e      	ldr	r3, [pc, #568]	; (8002808 <_usb_ep0setup+0x3d8>)
 80025ce:	6523      	str	r3, [r4, #80]	; 0x50
 80025d0:	2200      	movs	r2, #0
 80025d2:	2302      	movs	r3, #2
 80025d4:	e9c4 3215 	strd	r3, r2, [r4, #84]	; 0x54
    return true;
 80025d8:	e743      	b.n	8002462 <_usb_ep0setup+0x32>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80025da:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80025de:	d054      	beq.n	800268a <_usb_ep0setup+0x25a>
 80025e0:	f5a3 63c0 	sub.w	r3, r3, #1536	; 0x600
 80025e4:	2b01      	cmp	r3, #1
 80025e6:	d882      	bhi.n	80024ee <_usb_ep0setup+0xbe>
  hw |= (uint16_t)*p << 8U;
 80025e8:	f894 0061 	ldrb.w	r0, [r4, #97]	; 0x61
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 80025ec:	6861      	ldr	r1, [r4, #4]
  hw |= (uint16_t)*p << 8U;
 80025ee:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 80025f2:	684e      	ldr	r6, [r1, #4]
 80025f4:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
 80025f8:	f894 105f 	ldrb.w	r1, [r4, #95]	; 0x5f
 80025fc:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8002600:	4620      	mov	r0, r4
 8002602:	47b0      	blx	r6
    if (dp == NULL) {
 8002604:	2800      	cmp	r0, #0
 8002606:	f43f af72 	beq.w	80024ee <_usb_ep0setup+0xbe>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 800260a:	e9d0 3200 	ldrd	r3, r2, [r0]
 800260e:	f894 005c 	ldrb.w	r0, [r4, #92]	; 0x5c
 8002612:	65a5      	str	r5, [r4, #88]	; 0x58
 8002614:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50
    return true;
 8002618:	e723      	b.n	8002462 <_usb_ep0setup+0x32>
    if (usbp->ep0n != 0U) {
 800261a:	b19b      	cbz	r3, 8002644 <_usb_ep0setup+0x214>
      usbp->ep0state = USB_EP0_IN_TX;
 800261c:	2309      	movs	r3, #9
 800261e:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8002622:	2320      	movs	r3, #32
 8002624:	f383 8811 	msr	BASEPRI, r3
 8002628:	f7fe fa2a 	bl	8000a80 <_dbg_check_lock_from_isr>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 800262c:	e9d4 2314 	ldrd	r2, r3, [r4, #80]	; 0x50
 8002630:	4620      	mov	r0, r4
 8002632:	2100      	movs	r1, #0
 8002634:	f7fe fea4 	bl	8001380 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
 8002638:	f7fe fa0a 	bl	8000a50 <_dbg_check_unlock_from_isr>
 800263c:	2300      	movs	r3, #0
 800263e:	f383 8811 	msr	BASEPRI, r3
}
 8002642:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8002644:	2314      	movs	r3, #20
 8002646:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 800264a:	2320      	movs	r3, #32
 800264c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8002650:	f7fe fa16 	bl	8000a80 <_dbg_check_lock_from_isr>
      usbStartReceiveI(usbp, 0, NULL, 0);
 8002654:	2300      	movs	r3, #0
 8002656:	4620      	mov	r0, r4
 8002658:	461a      	mov	r2, r3
 800265a:	e71d      	b.n	8002498 <_usb_ep0setup+0x68>
      usbp->status |= 2U;
 800265c:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8002660:	6525      	str	r5, [r4, #80]	; 0x50
      usbp->status |= 2U;
 8002662:	f043 0302 	orr.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8002666:	e9c4 5515 	strd	r5, r5, [r4, #84]	; 0x54
      usbp->status |= 2U;
 800266a:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
      return true;
 800266e:	e791      	b.n	8002594 <_usb_ep0setup+0x164>
 8002670:	2320      	movs	r3, #32
 8002672:	f383 8811 	msr	BASEPRI, r3
 8002676:	f7fe fa03 	bl	8000a80 <_dbg_check_lock_from_isr>
  osalDbgCheckClassI();
 800267a:	f7fe f8b1 	bl	80007e0 <chDbgCheckClassI>
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");
 800267e:	7823      	ldrb	r3, [r4, #0]
 8002680:	2b04      	cmp	r3, #4
 8002682:	d076      	beq.n	8002772 <_usb_ep0setup+0x342>
 8002684:	4861      	ldr	r0, [pc, #388]	; (800280c <_usb_ep0setup+0x3dc>)
 8002686:	f7fe f883 	bl	8000790 <chSysHalt>
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800268a:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
 800268e:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8002692:	d048      	beq.n	8002726 <_usb_ep0setup+0x2f6>
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8002694:	2300      	movs	r3, #0
 8002696:	e9c4 3314 	strd	r3, r3, [r4, #80]	; 0x50
 800269a:	65a3      	str	r3, [r4, #88]	; 0x58
    return true;
 800269c:	e77a      	b.n	8002594 <_usb_ep0setup+0x164>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 800269e:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 80026a2:	2b00      	cmp	r3, #0
 80026a4:	f47f af23 	bne.w	80024ee <_usb_ep0setup+0xbe>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80026a8:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
 80026ac:	f013 020f 	ands.w	r2, r3, #15
 80026b0:	d0f0      	beq.n	8002694 <_usb_ep0setup+0x264>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80026b2:	f013 0f80 	tst.w	r3, #128	; 0x80
 80026b6:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80026b8:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 80026bc:	d152      	bne.n	8002764 <_usb_ep0setup+0x334>
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 80026be:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 80026c2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80026c6:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 80026ca:	e7e3      	b.n	8002694 <_usb_ep0setup+0x264>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80026cc:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 80026d0:	2b00      	cmp	r3, #0
 80026d2:	f47f af0c 	bne.w	80024ee <_usb_ep0setup+0xbe>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80026d6:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
 80026da:	f013 020f 	ands.w	r2, r3, #15
 80026de:	d0d9      	beq.n	8002694 <_usb_ep0setup+0x264>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80026e0:	f013 0f80 	tst.w	r3, #128	; 0x80
 80026e4:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80026e6:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 80026ea:	d134      	bne.n	8002756 <_usb_ep0setup+0x326>
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 80026ec:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 80026f0:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80026f4:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80026f8:	e7cc      	b.n	8002694 <_usb_ep0setup+0x264>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80026fa:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 80026fe:	2b01      	cmp	r3, #1
 8002700:	f47f aef5 	bne.w	80024ee <_usb_ep0setup+0xbe>
      usbp->status &= ~2U;
 8002704:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8002708:	6525      	str	r5, [r4, #80]	; 0x50
      usbp->status &= ~2U;
 800270a:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800270e:	e9c4 5515 	strd	r5, r5, [r4, #84]	; 0x54
      usbp->status &= ~2U;
 8002712:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
      return true;
 8002716:	e73d      	b.n	8002594 <_usb_ep0setup+0x164>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8002718:	f104 0267 	add.w	r2, r4, #103	; 0x67
 800271c:	2301      	movs	r3, #1
 800271e:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50
 8002722:	65a5      	str	r5, [r4, #88]	; 0x58
 8002724:	e69d      	b.n	8002462 <_usb_ep0setup+0x32>
  usbp->address = usbp->setup[2];
 8002726:	f894 105e 	ldrb.w	r1, [r4, #94]	; 0x5e
  stm32_otg_t *otgp = usbp->otg;
 800272a:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800272c:	f884 1066 	strb.w	r1, [r4, #102]	; 0x66
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 8002730:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8002734:	6865      	ldr	r5, [r4, #4]
 8002736:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 800273a:	682d      	ldr	r5, [r5, #0]
 800273c:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 8002740:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
 8002744:	b125      	cbz	r5, 8002750 <_usb_ep0setup+0x320>
 8002746:	4620      	mov	r0, r4
 8002748:	2101      	movs	r1, #1
 800274a:	47a8      	blx	r5
 800274c:	f894 005c 	ldrb.w	r0, [r4, #92]	; 0x5c
  usbp->state = USB_SELECTED;
 8002750:	2303      	movs	r3, #3
 8002752:	7023      	strb	r3, [r4, #0]
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8002754:	e79e      	b.n	8002694 <_usb_ep0setup+0x264>
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 8002756:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800275a:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 800275e:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 8002762:	e797      	b.n	8002694 <_usb_ep0setup+0x264>
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8002764:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8002768:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800276c:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 8002770:	e790      	b.n	8002694 <_usb_ep0setup+0x264>
  otg_ram_reset(usbp);
 8002772:	6f22      	ldr	r2, [r4, #112]	; 0x70
  usbp->transmitting &= 1U;
 8002774:	68a3      	ldr	r3, [r4, #8]
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8002776:	6811      	ldr	r1, [r2, #0]
 8002778:	6761      	str	r1, [r4, #116]	; 0x74
 800277a:	f003 1301 	and.w	r3, r3, #65537	; 0x10001
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800277e:	6897      	ldr	r7, [r2, #8]
  otg_disable_ep(usbp);
 8002780:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
    usbp->epc[i] = NULL;
 8002782:	6225      	str	r5, [r4, #32]
 8002784:	e9c4 5504 	strd	r5, r5, [r4, #16]
 8002788:	e9c4 5506 	strd	r5, r5, [r4, #24]
  usbp->transmitting &= 1U;
 800278c:	60a3      	str	r3, [r4, #8]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800278e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8002792:	e000      	b.n	8002796 <_usb_ep0setup+0x366>
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8002794:	4615      	mov	r5, r2
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 8002796:	eb01 1245 	add.w	r2, r1, r5, lsl #5
 800279a:	016b      	lsls	r3, r5, #5
 800279c:	f8d2 6900 	ldr.w	r6, [r2, #2304]	; 0x900
 80027a0:	2e00      	cmp	r6, #0
 80027a2:	da05      	bge.n	80027b0 <_usb_ep0setup+0x380>
      otgp->ie[i].DIEPCTL |= DIEPCTL_EPDIS;
 80027a4:	f8d2 6900 	ldr.w	r6, [r2, #2304]	; 0x900
 80027a8:	f046 4680 	orr.w	r6, r6, #1073741824	; 0x40000000
 80027ac:	f8c2 6900 	str.w	r6, [r2, #2304]	; 0x900
    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
 80027b0:	f8d2 6b00 	ldr.w	r6, [r2, #2816]	; 0xb00
 80027b4:	2e00      	cmp	r6, #0
 80027b6:	da05      	bge.n	80027c4 <_usb_ep0setup+0x394>
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
 80027b8:	f8d2 6b00 	ldr.w	r6, [r2, #2816]	; 0xb00
 80027bc:	f046 4680 	orr.w	r6, r6, #1073741824	; 0x40000000
 80027c0:	f8c2 6b00 	str.w	r6, [r2, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80027c4:	440b      	add	r3, r1
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80027c6:	42af      	cmp	r7, r5
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80027c8:	f8c3 0908 	str.w	r0, [r3, #2312]	; 0x908
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80027cc:	f105 0201 	add.w	r2, r5, #1
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80027d0:	f8c3 0b08 	str.w	r0, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80027d4:	d1de      	bne.n	8002794 <_usb_ep0setup+0x364>
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80027d6:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 80027da:	f8c1 381c 	str.w	r3, [r1, #2076]	; 0x81c
  _dbg_check_unlock_from_isr();
 80027de:	f7fe f937 	bl	8000a50 <_dbg_check_unlock_from_isr>
 80027e2:	2300      	movs	r3, #0
 80027e4:	f383 8811 	msr	BASEPRI, r3
        usbp->state = USB_SELECTED;
 80027e8:	2103      	movs	r1, #3
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 80027ea:	6862      	ldr	r2, [r4, #4]
        usbp->configuration = 0U;
 80027ec:	f884 3067 	strb.w	r3, [r4, #103]	; 0x67
        usbp->state = USB_SELECTED;
 80027f0:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 80027f2:	6813      	ldr	r3, [r2, #0]
 80027f4:	2b00      	cmp	r3, #0
 80027f6:	f43f aeba 	beq.w	800256e <_usb_ep0setup+0x13e>
 80027fa:	4620      	mov	r0, r4
 80027fc:	4798      	blx	r3
 80027fe:	e6b6      	b.n	800256e <_usb_ep0setup+0x13e>
 8002800:	0800533c 	.word	0x0800533c
 8002804:	08005270 	.word	0x08005270
 8002808:	08005528 	.word	0x08005528
 800280c:	08004f7c 	.word	0x08004f7c

08002810 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002810:	f3ef 8309 	mrs	r3, PSP
    FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8002814:	4905      	ldr	r1, [pc, #20]	; (800282c <SVC_Handler+0x1c>)
 8002816:	684a      	ldr	r2, [r1, #4]
 8002818:	f022 0201 	bic.w	r2, r2, #1
    psp += sizeof (struct port_extctx);
 800281c:	3368      	adds	r3, #104	; 0x68
    FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 800281e:	604a      	str	r2, [r1, #4]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8002820:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002824:	2300      	movs	r3, #0
 8002826:	f383 8811 	msr	BASEPRI, r3
}
 800282a:	4770      	bx	lr
 800282c:	e000ef30 	.word	0xe000ef30

08002830 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8002830:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
 8002832:	4c13      	ldr	r4, [pc, #76]	; (8002880 <chSchDoReschedule+0x50>)
  thread_t *tp = tqp->next;
 8002834:	6823      	ldr	r3, [r4, #0]
 8002836:	69a0      	ldr	r0, [r4, #24]
  tqp->next             = tp->queue.next;
 8002838:	681a      	ldr	r2, [r3, #0]
 800283a:	6022      	str	r2, [r4, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800283c:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 800283e:	6054      	str	r4, [r2, #4]
 8002840:	f883 1020 	strb.w	r1, [r3, #32]
  currp = queue_fifo_remove(&ch.rlist.queue);
 8002844:	61a3      	str	r3, [r4, #24]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 8002846:	f7fe f80b 	bl	8000860 <chSchReadyAheadI>
 800284a:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800284c:	07db      	lsls	r3, r3, #31
 800284e:	4605      	mov	r5, r0
 8002850:	d50b      	bpl.n	800286a <chSchDoReschedule+0x3a>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002852:	f3ef 8309 	mrs	r3, PSP

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002856:	69ea      	ldr	r2, [r5, #28]
 8002858:	3b64      	subs	r3, #100	; 0x64
 800285a:	429a      	cmp	r2, r3
 800285c:	d80d      	bhi.n	800287a <chSchDoReschedule+0x4a>
 800285e:	69a0      	ldr	r0, [r4, #24]
 8002860:	4629      	mov	r1, r5
}
 8002862:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(currp, otp);
 8002866:	f7fd bd5f 	b.w	8000328 <_port_switch>
 800286a:	f7fd ff41 	bl	80006f0 <_trace_switch.part.0>
 800286e:	f3ef 8309 	mrs	r3, PSP
 8002872:	69ea      	ldr	r2, [r5, #28]
 8002874:	3b64      	subs	r3, #100	; 0x64
 8002876:	429a      	cmp	r2, r3
 8002878:	d9f1      	bls.n	800285e <chSchDoReschedule+0x2e>
 800287a:	4802      	ldr	r0, [pc, #8]	; (8002884 <chSchDoReschedule+0x54>)
 800287c:	f7fd ff88 	bl	8000790 <chSysHalt>
 8002880:	20000e84 	.word	0x20000e84
 8002884:	08004cd4 	.word	0x08004cd4
	...

08002890 <_dbg_check_unlock>:
void _dbg_check_unlock(void) {
 8002890:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002892:	4b05      	ldr	r3, [pc, #20]	; (80028a8 <_dbg_check_unlock+0x18>)
 8002894:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002896:	b922      	cbnz	r2, 80028a2 <_dbg_check_unlock+0x12>
 8002898:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800289a:	2900      	cmp	r1, #0
 800289c:	dd01      	ble.n	80028a2 <_dbg_check_unlock+0x12>
  _dbg_leave_lock();
 800289e:	635a      	str	r2, [r3, #52]	; 0x34
}
 80028a0:	bd08      	pop	{r3, pc}
    chSysHalt("SV#5");
 80028a2:	4802      	ldr	r0, [pc, #8]	; (80028ac <_dbg_check_unlock+0x1c>)
 80028a4:	f7fd ff74 	bl	8000790 <chSysHalt>
 80028a8:	20000e84 	.word	0x20000e84
 80028ac:	08004cec 	.word	0x08004cec

080028b0 <chSysUnlock.lto_priv.5>:
static inline void chSysUnlock(void) {
 80028b0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 80028b2:	f7ff ffed 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80028b6:	4b08      	ldr	r3, [pc, #32]	; (80028d8 <chSysUnlock.lto_priv.5+0x28>)
 80028b8:	681a      	ldr	r2, [r3, #0]
 80028ba:	429a      	cmp	r2, r3
 80028bc:	d004      	beq.n	80028c8 <chSysUnlock.lto_priv.5+0x18>
 80028be:	6999      	ldr	r1, [r3, #24]
 80028c0:	6893      	ldr	r3, [r2, #8]
 80028c2:	688a      	ldr	r2, [r1, #8]
 80028c4:	429a      	cmp	r2, r3
 80028c6:	d303      	bcc.n	80028d0 <chSysUnlock.lto_priv.5+0x20>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80028c8:	2300      	movs	r3, #0
 80028ca:	f383 8811 	msr	BASEPRI, r3
}
 80028ce:	bd08      	pop	{r3, pc}
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80028d0:	4802      	ldr	r0, [pc, #8]	; (80028dc <chSysUnlock.lto_priv.5+0x2c>)
 80028d2:	f7fd ff5d 	bl	8000790 <chSysHalt>
 80028d6:	bf00      	nop
 80028d8:	20000e84 	.word	0x20000e84
 80028dc:	08005054 	.word	0x08005054

080028e0 <_dbg_check_lock>:
void _dbg_check_lock(void) {
 80028e0:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80028e2:	4b05      	ldr	r3, [pc, #20]	; (80028f8 <_dbg_check_lock+0x18>)
 80028e4:	e9d3 120c 	ldrd	r1, r2, [r3, #48]	; 0x30
 80028e8:	430a      	orrs	r2, r1
 80028ea:	d002      	beq.n	80028f2 <_dbg_check_lock+0x12>
    chSysHalt("SV#4");
 80028ec:	4803      	ldr	r0, [pc, #12]	; (80028fc <_dbg_check_lock+0x1c>)
 80028ee:	f7fd ff4f 	bl	8000790 <chSysHalt>
  _dbg_enter_lock();
 80028f2:	2201      	movs	r2, #1
 80028f4:	635a      	str	r2, [r3, #52]	; 0x34
}
 80028f6:	bd08      	pop	{r3, pc}
 80028f8:	20000e84 	.word	0x20000e84
 80028fc:	08004cf4 	.word	0x08004cf4

08002900 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8002900:	b510      	push	{r4, lr}
 8002902:	b084      	sub	sp, #16
 8002904:	e9cd 1002 	strd	r1, r0, [sp, #8]
 8002908:	9201      	str	r2, [sp, #4]
 800290a:	2320      	movs	r3, #32
 800290c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002910:	f7ff ffe6 	bl	80028e0 <_dbg_check_lock>
  void *p;

  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
 8002914:	e9dd 2101 	ldrd	r2, r1, [sp, #4]
 8002918:	9803      	ldr	r0, [sp, #12]
 800291a:	f7fd ff71 	bl	8000800 <chCoreAllocFromTopI>
 800291e:	4604      	mov	r4, r0
  _dbg_check_unlock();
 8002920:	f7ff ffb6 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002924:	4b08      	ldr	r3, [pc, #32]	; (8002948 <chCoreAllocFromTop+0x48>)
 8002926:	681a      	ldr	r2, [r3, #0]
 8002928:	429a      	cmp	r2, r3
 800292a:	d004      	beq.n	8002936 <chCoreAllocFromTop+0x36>
 800292c:	6999      	ldr	r1, [r3, #24]
 800292e:	6893      	ldr	r3, [r2, #8]
 8002930:	688a      	ldr	r2, [r1, #8]
 8002932:	429a      	cmp	r2, r3
 8002934:	d305      	bcc.n	8002942 <chCoreAllocFromTop+0x42>
 8002936:	2300      	movs	r3, #0
 8002938:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return p;
}
 800293c:	4620      	mov	r0, r4
 800293e:	b004      	add	sp, #16
 8002940:	bd10      	pop	{r4, pc}
 8002942:	4802      	ldr	r0, [pc, #8]	; (800294c <chCoreAllocFromTop+0x4c>)
 8002944:	f7fd ff24 	bl	8000790 <chSysHalt>
 8002948:	20000e84 	.word	0x20000e84
 800294c:	0800506c 	.word	0x0800506c

08002950 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8002950:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002954:	2320      	movs	r3, #32
 8002956:	b085      	sub	sp, #20
 8002958:	4680      	mov	r8, r0
 800295a:	f383 8811 	msr	BASEPRI, r3
  tp = ch.rlist.newer;
 800295e:	4cba      	ldr	r4, [pc, #744]	; (8002c48 <chRegFindThreadByWorkingArea+0x2f8>)
  _dbg_check_lock();
 8002960:	f7ff ffbe 	bl	80028e0 <_dbg_check_lock>
 8002964:	6925      	ldr	r5, [r4, #16]
  tp->refs++;
 8002966:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
 800296a:	3301      	adds	r3, #1
 800296c:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
  _dbg_check_unlock();
 8002970:	f7ff ff8e 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002974:	6823      	ldr	r3, [r4, #0]
 8002976:	42a3      	cmp	r3, r4
 8002978:	d004      	beq.n	8002984 <chRegFindThreadByWorkingArea+0x34>
 800297a:	69a2      	ldr	r2, [r4, #24]
 800297c:	689b      	ldr	r3, [r3, #8]
 800297e:	6892      	ldr	r2, [r2, #8]
 8002980:	429a      	cmp	r2, r3
 8002982:	d341      	bcc.n	8002a08 <chRegFindThreadByWorkingArea+0xb8>
 8002984:	2700      	movs	r7, #0
 8002986:	f387 8811 	msr	BASEPRI, r7
 800298a:	f04f 0920 	mov.w	r9, #32
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 800298e:	69eb      	ldr	r3, [r5, #28]
 8002990:	4598      	cmp	r8, r3
 8002992:	f000 8085 	beq.w	8002aa0 <chRegFindThreadByWorkingArea+0x150>
 8002996:	f389 8811 	msr	BASEPRI, r9
  _dbg_check_lock();
 800299a:	f7ff ffa1 	bl	80028e0 <_dbg_check_lock>
  ntp = tp->newer;
 800299e:	692e      	ldr	r6, [r5, #16]
  if (ntp == (thread_t *)&ch.rlist) {
 80029a0:	42a6      	cmp	r6, r4
 80029a2:	d04c      	beq.n	8002a3e <chRegFindThreadByWorkingArea+0xee>
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 80029a4:	f896 3022 	ldrb.w	r3, [r6, #34]	; 0x22
 80029a8:	2bff      	cmp	r3, #255	; 0xff
 80029aa:	d045      	beq.n	8002a38 <chRegFindThreadByWorkingArea+0xe8>
    ntp->refs++;
 80029ac:	3301      	adds	r3, #1
 80029ae:	f886 3022 	strb.w	r3, [r6, #34]	; 0x22
  _dbg_check_unlock();
 80029b2:	f7ff ff6d 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80029b6:	6823      	ldr	r3, [r4, #0]
 80029b8:	42a3      	cmp	r3, r4
 80029ba:	d004      	beq.n	80029c6 <chRegFindThreadByWorkingArea+0x76>
 80029bc:	69a2      	ldr	r2, [r4, #24]
 80029be:	689b      	ldr	r3, [r3, #8]
 80029c0:	6892      	ldr	r2, [r2, #8]
 80029c2:	429a      	cmp	r2, r3
 80029c4:	d320      	bcc.n	8002a08 <chRegFindThreadByWorkingArea+0xb8>
 80029c6:	f387 8811 	msr	BASEPRI, r7
 80029ca:	f389 8811 	msr	BASEPRI, r9
  _dbg_check_lock();
 80029ce:	f7ff ff87 	bl	80028e0 <_dbg_check_lock>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 80029d2:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
 80029d6:	b1d3      	cbz	r3, 8002a0e <chRegFindThreadByWorkingArea+0xbe>
  tp->refs--;
 80029d8:	3b01      	subs	r3, #1
 80029da:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 80029de:	6a2b      	ldr	r3, [r5, #32]
 80029e0:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 80029e4:	2b0f      	cmp	r3, #15
 80029e6:	d015      	beq.n	8002a14 <chRegFindThreadByWorkingArea+0xc4>
  _dbg_check_unlock();
 80029e8:	f7ff ff52 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80029ec:	6823      	ldr	r3, [r4, #0]
 80029ee:	42a3      	cmp	r3, r4
 80029f0:	d004      	beq.n	80029fc <chRegFindThreadByWorkingArea+0xac>
 80029f2:	69a2      	ldr	r2, [r4, #24]
 80029f4:	689b      	ldr	r3, [r3, #8]
 80029f6:	6892      	ldr	r2, [r2, #8]
 80029f8:	429a      	cmp	r2, r3
 80029fa:	d31a      	bcc.n	8002a32 <chRegFindThreadByWorkingArea+0xe2>
 80029fc:	f387 8811 	msr	BASEPRI, r7
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);
 8002a00:	2e00      	cmp	r6, #0
 8002a02:	d04e      	beq.n	8002aa2 <chRegFindThreadByWorkingArea+0x152>
 8002a04:	4635      	mov	r5, r6
 8002a06:	e7c2      	b.n	800298e <chRegFindThreadByWorkingArea+0x3e>
 8002a08:	4890      	ldr	r0, [pc, #576]	; (8002c4c <chRegFindThreadByWorkingArea+0x2fc>)
 8002a0a:	f7fd fec1 	bl	8000790 <chSysHalt>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8002a0e:	4890      	ldr	r0, [pc, #576]	; (8002c50 <chRegFindThreadByWorkingArea+0x300>)
 8002a10:	f7fd febe 	bl	8000790 <chSysHalt>
    REG_REMOVE(tp);
 8002a14:	e9d5 2304 	ldrd	r2, r3, [r5, #16]
 8002a18:	611a      	str	r2, [r3, #16]
 8002a1a:	692a      	ldr	r2, [r5, #16]
 8002a1c:	6153      	str	r3, [r2, #20]
  _dbg_check_unlock();
 8002a1e:	f7ff ff37 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002a22:	6823      	ldr	r3, [r4, #0]
 8002a24:	42a3      	cmp	r3, r4
 8002a26:	d00c      	beq.n	8002a42 <chRegFindThreadByWorkingArea+0xf2>
 8002a28:	69a2      	ldr	r2, [r4, #24]
 8002a2a:	689b      	ldr	r3, [r3, #8]
 8002a2c:	6892      	ldr	r2, [r2, #8]
 8002a2e:	429a      	cmp	r2, r3
 8002a30:	d207      	bcs.n	8002a42 <chRegFindThreadByWorkingArea+0xf2>
 8002a32:	4888      	ldr	r0, [pc, #544]	; (8002c54 <chRegFindThreadByWorkingArea+0x304>)
 8002a34:	f7fd feac 	bl	8000790 <chSysHalt>
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8002a38:	4887      	ldr	r0, [pc, #540]	; (8002c58 <chRegFindThreadByWorkingArea+0x308>)
 8002a3a:	f7fd fea9 	bl	8000790 <chSysHalt>
    ntp = NULL;
 8002a3e:	2600      	movs	r6, #0
 8002a40:	e7b7      	b.n	80029b2 <chRegFindThreadByWorkingArea+0x62>
 8002a42:	f387 8811 	msr	BASEPRI, r7
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8002a46:	f895 3021 	ldrb.w	r3, [r5, #33]	; 0x21
 8002a4a:	f003 0303 	and.w	r3, r3, #3
 8002a4e:	2b01      	cmp	r3, #1
 8002a50:	d02b      	beq.n	8002aaa <chRegFindThreadByWorkingArea+0x15a>
 8002a52:	2b02      	cmp	r3, #2
 8002a54:	d1d4      	bne.n	8002a00 <chRegFindThreadByWorkingArea+0xb0>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8002a56:	f8d5 a040 	ldr.w	sl, [r5, #64]	; 0x40
 8002a5a:	69ed      	ldr	r5, [r5, #28]
 8002a5c:	f389 8811 	msr	BASEPRI, r9
  _dbg_check_lock();
 8002a60:	f7ff ff3e 	bl	80028e0 <_dbg_check_lock>
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  struct pool_header *php = objp;

  chDbgCheckClassI();
 8002a64:	f7fd febc 	bl	80007e0 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) &&
 8002a68:	f1ba 0f00 	cmp.w	sl, #0
 8002a6c:	d074      	beq.n	8002b58 <chRegFindThreadByWorkingArea+0x208>
 8002a6e:	2d00      	cmp	r5, #0
 8002a70:	d072      	beq.n	8002b58 <chRegFindThreadByWorkingArea+0x208>
 8002a72:	f8da 3008 	ldr.w	r3, [sl, #8]
 8002a76:	3b01      	subs	r3, #1
 8002a78:	421d      	tst	r5, r3
 8002a7a:	d16d      	bne.n	8002b58 <chRegFindThreadByWorkingArea+0x208>
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 8002a7c:	f8da 3000 	ldr.w	r3, [sl]
 8002a80:	602b      	str	r3, [r5, #0]
  mp->next = php;
 8002a82:	f8ca 5000 	str.w	r5, [sl]
  _dbg_check_unlock();
 8002a86:	f7ff ff03 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002a8a:	6823      	ldr	r3, [r4, #0]
 8002a8c:	42a3      	cmp	r3, r4
 8002a8e:	d0b5      	beq.n	80029fc <chRegFindThreadByWorkingArea+0xac>
 8002a90:	69a2      	ldr	r2, [r4, #24]
 8002a92:	689b      	ldr	r3, [r3, #8]
 8002a94:	6892      	ldr	r2, [r2, #8]
 8002a96:	429a      	cmp	r2, r3
 8002a98:	d2b0      	bcs.n	80029fc <chRegFindThreadByWorkingArea+0xac>
 8002a9a:	4870      	ldr	r0, [pc, #448]	; (8002c5c <chRegFindThreadByWorkingArea+0x30c>)
 8002a9c:	f7fd fe78 	bl	8000790 <chSysHalt>
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8002aa0:	462e      	mov	r6, r5

  return NULL;
}
 8002aa2:	4630      	mov	r0, r6
 8002aa4:	b005      	add	sp, #20
 8002aa6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      chHeapFree(chThdGetWorkingAreaX(tp));
 8002aaa:	69ed      	ldr	r5, [r5, #28]
 */
void chHeapFree(void *p) {
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8002aac:	2d00      	cmp	r5, #0
 8002aae:	d056      	beq.n	8002b5e <chRegFindThreadByWorkingArea+0x20e>
 8002ab0:	076b      	lsls	r3, r5, #29
 8002ab2:	d154      	bne.n	8002b5e <chRegFindThreadByWorkingArea+0x20e>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8002ab4:	e955 b302 	ldrd	fp, r3, [r5, #-8]
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8002ab8:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8002aba:	08db      	lsrs	r3, r3, #3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8002abc:	f10b 010c 	add.w	r1, fp, #12
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8002ac0:	f845 3c04 	str.w	r3, [r5, #-4]
  H_LOCK(heapp);
 8002ac4:	9101      	str	r1, [sp, #4]
 8002ac6:	f389 8811 	msr	BASEPRI, r9
  _dbg_check_lock();
 8002aca:	f7ff ff09 	bl	80028e0 <_dbg_check_lock>
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;

  chDbgCheckClassS();
 8002ace:	f7fd fe77 	bl	80007c0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8002ad2:	f8db 0014 	ldr.w	r0, [fp, #20]
  thread_t *ctp = currp;
 8002ad6:	f8d4 a018 	ldr.w	sl, [r4, #24]
  if (mp->owner != NULL) {
 8002ada:	9901      	ldr	r1, [sp, #4]
 8002adc:	2800      	cmp	r0, #0
 8002ade:	f000 80e3 	beq.w	8002ca8 <chRegFindThreadByWorkingArea+0x358>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8002ae2:	f8da 2008 	ldr.w	r2, [sl, #8]
 8002ae6:	6883      	ldr	r3, [r0, #8]
 8002ae8:	429a      	cmp	r2, r3
 8002aea:	d909      	bls.n	8002b00 <chRegFindThreadByWorkingArea+0x1b0>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8002aec:	f890 3020 	ldrb.w	r3, [r0, #32]
        tp->prio = ctp->prio;
 8002af0:	6082      	str	r2, [r0, #8]
        switch (tp->state) {
 8002af2:	2b06      	cmp	r3, #6
 8002af4:	f000 80bc 	beq.w	8002c70 <chRegFindThreadByWorkingArea+0x320>
 8002af8:	2b07      	cmp	r3, #7
 8002afa:	f000 808a 	beq.w	8002c12 <chRegFindThreadByWorkingArea+0x2c2>
 8002afe:	b1f3      	cbz	r3, 8002b3e <chRegFindThreadByWorkingArea+0x1ee>
 8002b00:	460a      	mov	r2, r1
 8002b02:	e004      	b.n	8002b0e <chRegFindThreadByWorkingArea+0x1be>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002b04:	6890      	ldr	r0, [r2, #8]
 8002b06:	f8da 3008 	ldr.w	r3, [sl, #8]
 8002b0a:	4298      	cmp	r0, r3
 8002b0c:	d302      	bcc.n	8002b14 <chRegFindThreadByWorkingArea+0x1c4>
    cp = cp->queue.next;
 8002b0e:	6812      	ldr	r2, [r2, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002b10:	4291      	cmp	r1, r2
 8002b12:	d1f7      	bne.n	8002b04 <chRegFindThreadByWorkingArea+0x1b4>
  tp->queue.prev             = cp->queue.prev;
 8002b14:	6853      	ldr	r3, [r2, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 8002b16:	9101      	str	r1, [sp, #4]
 8002b18:	e9ca 2300 	strd	r2, r3, [sl]
      chSchGoSleepS(CH_STATE_WTMTX);
 8002b1c:	2006      	movs	r0, #6
  tp->queue.prev->queue.next = tp;
 8002b1e:	f8c3 a000 	str.w	sl, [r3]
  cp->queue.prev             = tp;
 8002b22:	f8c2 a004 	str.w	sl, [r2, #4]
      ctp->u.wtmtxp = mp;
 8002b26:	f8ca 1024 	str.w	r1, [sl, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8002b2a:	f7fe ff79 	bl	8001a20 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 8002b2e:	f8db 3014 	ldr.w	r3, [fp, #20]
 8002b32:	9901      	ldr	r1, [sp, #4]
 8002b34:	459a      	cmp	sl, r3
 8002b36:	d015      	beq.n	8002b64 <chRegFindThreadByWorkingArea+0x214>
 8002b38:	4849      	ldr	r0, [pc, #292]	; (8002c60 <chRegFindThreadByWorkingArea+0x310>)
 8002b3a:	f7fd fe29 	bl	8000790 <chSysHalt>
  tp->queue.prev->queue.next = tp->queue.next;
 8002b3e:	e9d0 3200 	ldrd	r3, r2, [r0]
          tp->state = CH_STATE_CURRENT;
 8002b42:	f04f 0c01 	mov.w	ip, #1
 8002b46:	f880 c020 	strb.w	ip, [r0, #32]
 8002b4a:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8002b4c:	605a      	str	r2, [r3, #4]
 8002b4e:	9101      	str	r1, [sp, #4]
          (void) chSchReadyI(queue_dequeue(tp));
 8002b50:	f7fd feae 	bl	80008b0 <chSchReadyI>
          break;
 8002b54:	9901      	ldr	r1, [sp, #4]
 8002b56:	e7d3      	b.n	8002b00 <chRegFindThreadByWorkingArea+0x1b0>
  chDbgCheck((mp != NULL) &&
 8002b58:	4842      	ldr	r0, [pc, #264]	; (8002c64 <chRegFindThreadByWorkingArea+0x314>)
 8002b5a:	f7fd fe19 	bl	8000790 <chSysHalt>
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8002b5e:	4842      	ldr	r0, [pc, #264]	; (8002c68 <chRegFindThreadByWorkingArea+0x318>)
 8002b60:	f7fd fe16 	bl	8000790 <chSysHalt>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 8002b64:	f8da 3038 	ldr.w	r3, [sl, #56]	; 0x38
 8002b68:	4299      	cmp	r1, r3
 8002b6a:	d1e5      	bne.n	8002b38 <chRegFindThreadByWorkingArea+0x1e8>
 8002b6c:	9101      	str	r1, [sp, #4]
  _dbg_check_unlock();
 8002b6e:	f7ff fe8f 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002b72:	6822      	ldr	r2, [r4, #0]
 8002b74:	9901      	ldr	r1, [sp, #4]
 8002b76:	42a2      	cmp	r2, r4
 8002b78:	d005      	beq.n	8002b86 <chRegFindThreadByWorkingArea+0x236>
 8002b7a:	69a3      	ldr	r3, [r4, #24]
 8002b7c:	6892      	ldr	r2, [r2, #8]
 8002b7e:	689b      	ldr	r3, [r3, #8]
 8002b80:	4293      	cmp	r3, r2
 8002b82:	f0c0 80bc 	bcc.w	8002cfe <chRegFindThreadByWorkingArea+0x3ae>
  hp = (heap_header_t *)p - 1U;
 8002b86:	f1a5 0008 	sub.w	r0, r5, #8
  qp = &heapp->header;
 8002b8a:	f10b 0c04 	add.w	ip, fp, #4
 8002b8e:	f387 8811 	msr	BASEPRI, r7
 8002b92:	4662      	mov	r2, ip

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8002b94:	4290      	cmp	r0, r2
 8002b96:	d305      	bcc.n	8002ba4 <chRegFindThreadByWorkingArea+0x254>
 8002b98:	6853      	ldr	r3, [r2, #4]
 8002b9a:	3301      	adds	r3, #1
 8002b9c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8002ba0:	4298      	cmp	r0, r3
 8002ba2:	d3dc      	bcc.n	8002b5e <chRegFindThreadByWorkingArea+0x20e>

    if (((qp == &heapp->header) || (hp > qp)) &&
 8002ba4:	4594      	cmp	ip, r2
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8002ba6:	6813      	ldr	r3, [r2, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 8002ba8:	d001      	beq.n	8002bae <chRegFindThreadByWorkingArea+0x25e>
 8002baa:	4290      	cmp	r0, r2
 8002bac:	d92f      	bls.n	8002c0e <chRegFindThreadByWorkingArea+0x2be>
 8002bae:	b10b      	cbz	r3, 8002bb4 <chRegFindThreadByWorkingArea+0x264>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8002bb0:	4298      	cmp	r0, r3
 8002bb2:	d22c      	bcs.n	8002c0e <chRegFindThreadByWorkingArea+0x2be>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8002bb4:	f855 cc04 	ldr.w	ip, [r5, #-4]
      H_NEXT(hp) = H_NEXT(qp);
 8002bb8:	f845 3c08 	str.w	r3, [r5, #-8]
      H_NEXT(qp) = hp;
 8002bbc:	6010      	str	r0, [r2, #0]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8002bbe:	f855 3c08 	ldr.w	r3, [r5, #-8]
 8002bc2:	f10c 0c01 	add.w	ip, ip, #1
 8002bc6:	eb00 0ecc 	add.w	lr, r0, ip, lsl #3
 8002bca:	4573      	cmp	r3, lr
 8002bcc:	f000 80a1 	beq.w	8002d12 <chRegFindThreadByWorkingArea+0x3c2>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
 8002bd0:	f8d2 c004 	ldr.w	ip, [r2, #4]
 8002bd4:	f10c 0301 	add.w	r3, ip, #1
 8002bd8:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8002bdc:	4298      	cmp	r0, r3
 8002bde:	f000 8091 	beq.w	8002d04 <chRegFindThreadByWorkingArea+0x3b4>
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8002be2:	69a2      	ldr	r2, [r4, #24]
 8002be4:	9102      	str	r1, [sp, #8]
 8002be6:	9201      	str	r2, [sp, #4]
 8002be8:	f389 8811 	msr	BASEPRI, r9
  _dbg_check_lock();
 8002bec:	f7ff fe78 	bl	80028e0 <_dbg_check_lock>

  chDbgCheck(mp != NULL);

  chSysLock();

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8002bf0:	9a01      	ldr	r2, [sp, #4]
 8002bf2:	9902      	ldr	r1, [sp, #8]
 8002bf4:	f8d2 a038 	ldr.w	sl, [r2, #56]	; 0x38
 8002bf8:	f1ba 0f00 	cmp.w	sl, #0
 8002bfc:	d004      	beq.n	8002c08 <chRegFindThreadByWorkingArea+0x2b8>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 8002bfe:	f8da 3008 	ldr.w	r3, [sl, #8]
 8002c02:	429a      	cmp	r2, r3
 8002c04:	f000 808e 	beq.w	8002d24 <chRegFindThreadByWorkingArea+0x3d4>
  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8002c08:	4818      	ldr	r0, [pc, #96]	; (8002c6c <chRegFindThreadByWorkingArea+0x31c>)
 8002c0a:	f7fd fdc1 	bl	8000790 <chSysHalt>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
      }
      break;
    }
    qp = H_NEXT(qp);
 8002c0e:	461a      	mov	r2, r3
  while (true) {
 8002c10:	e7c0      	b.n	8002b94 <chRegFindThreadByWorkingArea+0x244>
  tp->queue.prev->queue.next = tp->queue.next;
 8002c12:	e9d0 3c00 	ldrd	r3, ip, [r0]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8002c16:	f8d0 e024 	ldr.w	lr, [r0, #36]	; 0x24
 8002c1a:	f8cc 3000 	str.w	r3, [ip]
  tp->queue.next->queue.prev = tp->queue.prev;
 8002c1e:	f8c3 c004 	str.w	ip, [r3, #4]
  thread_t *cp = (thread_t *)tqp;
 8002c22:	46f4      	mov	ip, lr
 8002c24:	e003      	b.n	8002c2e <chRegFindThreadByWorkingArea+0x2de>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002c26:	f8dc 3008 	ldr.w	r3, [ip, #8]
 8002c2a:	429a      	cmp	r2, r3
 8002c2c:	d803      	bhi.n	8002c36 <chRegFindThreadByWorkingArea+0x2e6>
    cp = cp->queue.next;
 8002c2e:	f8dc c000 	ldr.w	ip, [ip]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002c32:	45e6      	cmp	lr, ip
 8002c34:	d1f7      	bne.n	8002c26 <chRegFindThreadByWorkingArea+0x2d6>
  tp->queue.prev             = cp->queue.prev;
 8002c36:	f8dc 3004 	ldr.w	r3, [ip, #4]
 8002c3a:	e9c0 c300 	strd	ip, r3, [r0]
  tp->queue.prev->queue.next = tp;
 8002c3e:	6018      	str	r0, [r3, #0]
  cp->queue.prev             = tp;
 8002c40:	f8cc 0004 	str.w	r0, [ip, #4]
 8002c44:	e75c      	b.n	8002b00 <chRegFindThreadByWorkingArea+0x1b0>
 8002c46:	bf00      	nop
 8002c48:	20000e84 	.word	0x20000e84
 8002c4c:	080050bc 	.word	0x080050bc
 8002c50:	08005184 	.word	0x08005184
 8002c54:	08005054 	.word	0x08005054
 8002c58:	080051a0 	.word	0x080051a0
 8002c5c:	08005078 	.word	0x08005078
 8002c60:	080050d4 	.word	0x080050d4
 8002c64:	08005120 	.word	0x08005120
 8002c68:	0800512c 	.word	0x0800512c
 8002c6c:	08005138 	.word	0x08005138
  tp->queue.prev->queue.next = tp->queue.next;
 8002c70:	e9d0 3c00 	ldrd	r3, ip, [r0]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8002c74:	f8d0 e024 	ldr.w	lr, [r0, #36]	; 0x24
 8002c78:	f8cc 3000 	str.w	r3, [ip]
  tp->queue.next->queue.prev = tp->queue.prev;
 8002c7c:	f8c3 c004 	str.w	ip, [r3, #4]
  thread_t *cp = (thread_t *)tqp;
 8002c80:	46f4      	mov	ip, lr
 8002c82:	e003      	b.n	8002c8c <chRegFindThreadByWorkingArea+0x33c>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002c84:	f8dc 3008 	ldr.w	r3, [ip, #8]
 8002c88:	429a      	cmp	r2, r3
 8002c8a:	d803      	bhi.n	8002c94 <chRegFindThreadByWorkingArea+0x344>
    cp = cp->queue.next;
 8002c8c:	f8dc c000 	ldr.w	ip, [ip]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002c90:	45e6      	cmp	lr, ip
 8002c92:	d1f7      	bne.n	8002c84 <chRegFindThreadByWorkingArea+0x334>
  tp->queue.prev             = cp->queue.prev;
 8002c94:	f8dc 3004 	ldr.w	r3, [ip, #4]
 8002c98:	e9c0 c300 	strd	ip, r3, [r0]
  tp->queue.prev->queue.next = tp;
 8002c9c:	6018      	str	r0, [r3, #0]
  cp->queue.prev             = tp;
 8002c9e:	f8cc 0004 	str.w	r0, [ip, #4]
          tp = tp->u.wtmtxp->owner;
 8002ca2:	f8de 0008 	ldr.w	r0, [lr, #8]
          continue;
 8002ca6:	e71c      	b.n	8002ae2 <chRegFindThreadByWorkingArea+0x192>
    mp->next = ctp->mtxlist;
 8002ca8:	f8da 3038 	ldr.w	r3, [sl, #56]	; 0x38
 8002cac:	e9cb a305 	strd	sl, r3, [fp, #20]
    ctp->mtxlist = mp;
 8002cb0:	f8ca 1038 	str.w	r1, [sl, #56]	; 0x38
 8002cb4:	e75a      	b.n	8002b6c <chRegFindThreadByWorkingArea+0x21c>
  tqp->next             = tp->queue.next;
 8002cb6:	682b      	ldr	r3, [r5, #0]
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8002cb8:	6091      	str	r1, [r2, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8002cba:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8002cbc:	f8cb 300c 	str.w	r3, [fp, #12]

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8002cc0:	4628      	mov	r0, r5
  tqp->next->queue.prev = (thread_t *)tqp;
 8002cc2:	f8c3 a004 	str.w	sl, [r3, #4]
      mp->next = tp->mtxlist;
 8002cc6:	e9cb 5205 	strd	r5, r2, [fp, #20]
      tp->mtxlist = mp;
 8002cca:	f8c5 a038 	str.w	sl, [r5, #56]	; 0x38
      (void) chSchReadyI(tp);
 8002cce:	f7fd fdef 	bl	80008b0 <chSchReadyI>
  chDbgCheckClassS();
 8002cd2:	f7fd fd75 	bl	80007c0 <chDbgCheckClassS>
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();
 8002cd6:	f7fd fd83 	bl	80007e0 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 8002cda:	6822      	ldr	r2, [r4, #0]
 8002cdc:	69a3      	ldr	r3, [r4, #24]
  if (chSchIsRescRequiredI()) {
 8002cde:	6892      	ldr	r2, [r2, #8]
 8002ce0:	689b      	ldr	r3, [r3, #8]
 8002ce2:	429a      	cmp	r2, r3
 8002ce4:	d845      	bhi.n	8002d72 <chRegFindThreadByWorkingArea+0x422>
  _dbg_check_unlock();
 8002ce6:	f7ff fdd3 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002cea:	6823      	ldr	r3, [r4, #0]
 8002cec:	42a3      	cmp	r3, r4
 8002cee:	f43f ae85 	beq.w	80029fc <chRegFindThreadByWorkingArea+0xac>
 8002cf2:	69a2      	ldr	r2, [r4, #24]
 8002cf4:	689b      	ldr	r3, [r3, #8]
 8002cf6:	6892      	ldr	r2, [r2, #8]
 8002cf8:	429a      	cmp	r2, r3
 8002cfa:	f4bf ae7f 	bcs.w	80029fc <chRegFindThreadByWorkingArea+0xac>
 8002cfe:	481e      	ldr	r0, [pc, #120]	; (8002d78 <chRegFindThreadByWorkingArea+0x428>)
 8002d00:	f7fd fd46 	bl	8000790 <chSysHalt>
        H_NEXT(qp) = H_NEXT(hp);
 8002d04:	e955 0302 	ldrd	r0, r3, [r5, #-8]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8002d08:	3301      	adds	r3, #1
 8002d0a:	4463      	add	r3, ip
        H_NEXT(qp) = H_NEXT(hp);
 8002d0c:	6010      	str	r0, [r2, #0]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8002d0e:	6053      	str	r3, [r2, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8002d10:	e767      	b.n	8002be2 <chRegFindThreadByWorkingArea+0x292>
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8002d12:	e9d3 3e00 	ldrd	r3, lr, [r3]
 8002d16:	f845 3c08 	str.w	r3, [r5, #-8]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8002d1a:	eb0e 030c 	add.w	r3, lr, ip
 8002d1e:	f845 3c04 	str.w	r3, [r5, #-4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8002d22:	e755      	b.n	8002bd0 <chRegFindThreadByWorkingArea+0x280>
    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8002d24:	4551      	cmp	r1, sl
 8002d26:	f47f af6f 	bne.w	8002c08 <chRegFindThreadByWorkingArea+0x2b8>
    ctp->mtxlist = mp->next;
 8002d2a:	f8db 3018 	ldr.w	r3, [fp, #24]
 8002d2e:	6393      	str	r3, [r2, #56]	; 0x38
 8002d30:	e9cd 2301 	strd	r2, r3, [sp, #4]
 *
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {

  chDbgCheckClassS();
 8002d34:	f7fd fd44 	bl	80007c0 <chDbgCheckClassS>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8002d38:	f8db 500c 	ldr.w	r5, [fp, #12]
    if (chMtxQueueNotEmptyS(mp)) {
 8002d3c:	45aa      	cmp	sl, r5
 8002d3e:	d015      	beq.n	8002d6c <chRegFindThreadByWorkingArea+0x41c>
      tprio_t newprio = ctp->realprio;
 8002d40:	9a01      	ldr	r2, [sp, #4]
 8002d42:	9b02      	ldr	r3, [sp, #8]
 8002d44:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
      while (lmp != NULL) {
 8002d46:	2b00      	cmp	r3, #0
 8002d48:	d0b5      	beq.n	8002cb6 <chRegFindThreadByWorkingArea+0x366>
 8002d4a:	e9cd 3102 	strd	r3, r1, [sp, #8]
 8002d4e:	9201      	str	r2, [sp, #4]
 8002d50:	f7fd fd36 	bl	80007c0 <chDbgCheckClassS>
 8002d54:	9b02      	ldr	r3, [sp, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 8002d56:	9a01      	ldr	r2, [sp, #4]
 8002d58:	6818      	ldr	r0, [r3, #0]
 8002d5a:	9903      	ldr	r1, [sp, #12]
 8002d5c:	4283      	cmp	r3, r0
 8002d5e:	d003      	beq.n	8002d68 <chRegFindThreadByWorkingArea+0x418>
 8002d60:	6880      	ldr	r0, [r0, #8]
 8002d62:	4281      	cmp	r1, r0
 8002d64:	bf38      	it	cc
 8002d66:	4601      	movcc	r1, r0
        lmp = lmp->next;
 8002d68:	68db      	ldr	r3, [r3, #12]
 8002d6a:	e7ec      	b.n	8002d46 <chRegFindThreadByWorkingArea+0x3f6>
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
 8002d6c:	f8cb 7014 	str.w	r7, [fp, #20]
 8002d70:	e7b9      	b.n	8002ce6 <chRegFindThreadByWorkingArea+0x396>
    chSchDoRescheduleAhead();
 8002d72:	f7ff fd5d 	bl	8002830 <chSchDoReschedule>
 8002d76:	e7b6      	b.n	8002ce6 <chRegFindThreadByWorkingArea+0x396>
 8002d78:	08005060 	.word	0x08005060
 8002d7c:	00000000 	.word	0x00000000

08002d80 <chThdCreateStatic.constprop.0>:
  chDbgCheck((wsp != NULL) &&
 8002d80:	0743      	lsls	r3, r0, #29
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8002d82:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((wsp != NULL) &&
 8002d84:	d104      	bne.n	8002d90 <chThdCreateStatic.constprop.0+0x10>
 8002d86:	4604      	mov	r4, r0
 8002d88:	460d      	mov	r5, r1
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 8002d8a:	f7ff fde1 	bl	8002950 <chRegFindThreadByWorkingArea>
 8002d8e:	b110      	cbz	r0, 8002d96 <chThdCreateStatic.constprop.0+0x16>
  chDbgCheck((wsp != NULL) &&
 8002d90:	4825      	ldr	r0, [pc, #148]	; (8002e28 <chThdCreateStatic.constprop.0+0xa8>)
 8002d92:	f7fd fcfd 	bl	8000790 <chSysHalt>
  _thread_memfill((uint8_t *)wsp,
 8002d96:	f504 6015 	add.w	r0, r4, #2384	; 0x950
 8002d9a:	4623      	mov	r3, r4
    *startp++ = v;
 8002d9c:	2255      	movs	r2, #85	; 0x55
 8002d9e:	f803 2b01 	strb.w	r2, [r3], #1
  while (startp < endp) {
 8002da2:	4298      	cmp	r0, r3
 8002da4:	d1fb      	bne.n	8002d9e <chThdCreateStatic.constprop.0+0x1e>
 8002da6:	2320      	movs	r3, #32
 8002da8:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002dac:	f7ff fd98 	bl	80028e0 <_dbg_check_lock>
  REG_INSERT(tp);
 8002db0:	4b1e      	ldr	r3, [pc, #120]	; (8002e2c <chThdCreateStatic.constprop.0+0xac>)
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8002db2:	4a1f      	ldr	r2, [pc, #124]	; (8002e30 <chThdCreateStatic.constprop.0+0xb0>)
 8002db4:	f8c4 58e4 	str.w	r5, [r4, #2276]	; 0x8e4
 8002db8:	f8c4 2904 	str.w	r2, [r4, #2308]	; 0x904
 8002dbc:	f604 05a4 	addw	r5, r4, #2212	; 0x8a4
  tp->refs      = (trefs_t)1;
 8002dc0:	2201      	movs	r2, #1
  REG_INSERT(tp);
 8002dc2:	6959      	ldr	r1, [r3, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8002dc4:	f8c4 5914 	str.w	r5, [r4, #2324]	; 0x914
  tp->refs      = (trefs_t)1;
 8002dc8:	f884 292a 	strb.w	r2, [r4, #2346]	; 0x92a
  tp->name      = name;
 8002dcc:	4819      	ldr	r0, [pc, #100]	; (8002e34 <chThdCreateStatic.constprop.0+0xb4>)
 8002dce:	f8c4 0920 	str.w	r0, [r4, #2336]	; 0x920
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8002dd2:	2200      	movs	r2, #0
  tp->state     = CH_STATE_WTSTART;
 8002dd4:	2502      	movs	r5, #2
 8002dd6:	f8a4 5928 	strh.w	r5, [r4, #2344]	; 0x928
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8002dda:	f8c4 28e8 	str.w	r2, [r4, #2280]	; 0x8e8
  tp = (thread_t *)((uint8_t *)wsp + size -
 8002dde:	f604 1508 	addw	r5, r4, #2312	; 0x908
  tp->mtxlist   = NULL;
 8002de2:	f8c4 2940 	str.w	r2, [r4, #2368]	; 0x940
  tp->epending  = (eventmask_t)0;
 8002de6:	f8c4 293c 	str.w	r2, [r4, #2364]	; 0x93c
  tp->prio      = prio;
 8002dea:	2080      	movs	r0, #128	; 0x80
  queue_init(&tp->msgqueue);
 8002dec:	f604 1234 	addw	r2, r4, #2356	; 0x934
  list_init(&tp->waiting);
 8002df0:	f504 6613 	add.w	r6, r4, #2352	; 0x930
  tp->prio      = prio;
 8002df4:	f8c4 0910 	str.w	r0, [r4, #2320]	; 0x910
  tp->realprio  = prio;
 8002df8:	f8c4 0944 	str.w	r0, [r4, #2372]	; 0x944
  REG_INSERT(tp);
 8002dfc:	f8c4 3918 	str.w	r3, [r4, #2328]	; 0x918
 8002e00:	f8c4 191c 	str.w	r1, [r4, #2332]	; 0x91c
  chSchWakeupS(tp, MSG_OK);
 8002e04:	4628      	mov	r0, r5
  tp->wabase = (stkalign_t *)wsp;
 8002e06:	f8c4 4924 	str.w	r4, [r4, #2340]	; 0x924
  REG_INSERT(tp);
 8002e0a:	610d      	str	r5, [r1, #16]
  tqp->next = (thread_t *)tqp;
 8002e0c:	f8c4 2934 	str.w	r2, [r4, #2356]	; 0x934
  tqp->prev = (thread_t *)tqp;
 8002e10:	f8c4 2938 	str.w	r2, [r4, #2360]	; 0x938
  tlp->next = (thread_t *)tlp;
 8002e14:	f8c4 6930 	str.w	r6, [r4, #2352]	; 0x930
 8002e18:	615d      	str	r5, [r3, #20]
  chSchWakeupS(tp, MSG_OK);
 8002e1a:	f7fe fdc1 	bl	80019a0 <chSchWakeupS.constprop.0>
  chSysUnlock();
 8002e1e:	f7ff fd47 	bl	80028b0 <chSysUnlock.lto_priv.5>
}
 8002e22:	4628      	mov	r0, r5
 8002e24:	bd70      	pop	{r4, r5, r6, pc}
 8002e26:	bf00      	nop
 8002e28:	08005144 	.word	0x08005144
 8002e2c:	20000e84 	.word	0x20000e84
 8002e30:	08000341 	.word	0x08000341
 8002e34:	08004cfc 	.word	0x08004cfc
	...

08002e40 <chThdSleep>:
void chThdSleep(sysinterval_t time) {
 8002e40:	b500      	push	{lr}
 8002e42:	b083      	sub	sp, #12
 8002e44:	2320      	movs	r3, #32
 8002e46:	9001      	str	r0, [sp, #4]
 8002e48:	f383 8811 	msr	BASEPRI, r3
 8002e4c:	f7ff fd48 	bl	80028e0 <_dbg_check_lock>
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8002e50:	9901      	ldr	r1, [sp, #4]
 8002e52:	2008      	movs	r0, #8
 8002e54:	f7fe fe14 	bl	8001a80 <chSchGoSleepTimeoutS>
  _dbg_check_unlock();
 8002e58:	f7ff fd1a 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002e5c:	4b08      	ldr	r3, [pc, #32]	; (8002e80 <chThdSleep+0x40>)
 8002e5e:	681a      	ldr	r2, [r3, #0]
 8002e60:	429a      	cmp	r2, r3
 8002e62:	d004      	beq.n	8002e6e <chThdSleep+0x2e>
 8002e64:	6999      	ldr	r1, [r3, #24]
 8002e66:	6893      	ldr	r3, [r2, #8]
 8002e68:	688a      	ldr	r2, [r1, #8]
 8002e6a:	429a      	cmp	r2, r3
 8002e6c:	d305      	bcc.n	8002e7a <chThdSleep+0x3a>
 8002e6e:	2300      	movs	r3, #0
 8002e70:	f383 8811 	msr	BASEPRI, r3
}
 8002e74:	b003      	add	sp, #12
 8002e76:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e7a:	4802      	ldr	r0, [pc, #8]	; (8002e84 <chThdSleep+0x44>)
 8002e7c:	f7fd fc88 	bl	8000790 <chSysHalt>
 8002e80:	20000e84 	.word	0x20000e84
 8002e84:	08005054 	.word	0x08005054
	...

08002e90 <echo_thread>:
  buffer[size - 1] = 0;
  return 0; // Filled up buffer without reading a linebreak
}

static THD_WORKING_AREA(echo_thread_area, 2048);
static THD_FUNCTION(echo_thread, arg) {
 8002e90:	b508      	push	{r3, lr}
 8002e92:	4c09      	ldr	r4, [pc, #36]	; (8002eb8 <echo_thread+0x28>)
  (void) arg;

  unsigned char c; 
  while (1) {
    
    while ((c = streamGet(chp))) {
 8002e94:	6820      	ldr	r0, [r4, #0]
 8002e96:	6803      	ldr	r3, [r0, #0]
 8002e98:	691b      	ldr	r3, [r3, #16]
 8002e9a:	4798      	blx	r3
 8002e9c:	f010 01ff 	ands.w	r1, r0, #255	; 0xff
 8002ea0:	d004      	beq.n	8002eac <echo_thread+0x1c>
	streamPut(chp, c);
 8002ea2:	6820      	ldr	r0, [r4, #0]
 8002ea4:	6803      	ldr	r3, [r0, #0]
 8002ea6:	68db      	ldr	r3, [r3, #12]
 8002ea8:	4798      	blx	r3
 8002eaa:	e7f3      	b.n	8002e94 <echo_thread+0x4>
      }
     chThdSleepMilliseconds(100);
 8002eac:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002eb0:	f7ff ffc6 	bl	8002e40 <chThdSleep>
    while ((c = streamGet(chp))) {
 8002eb4:	e7ee      	b.n	8002e94 <echo_thread+0x4>
 8002eb6:	bf00      	nop
 8002eb8:	200018c0 	.word	0x200018c0
 8002ebc:	00000000 	.word	0x00000000

08002ec0 <chThdExit>:
void chThdExit(msg_t msg) {
 8002ec0:	b508      	push	{r3, lr}
 8002ec2:	4605      	mov	r5, r0
 8002ec4:	2320      	movs	r3, #32
 8002ec6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002eca:	f7ff fd09 	bl	80028e0 <_dbg_check_lock>
  thread_t *tp = currp;
 8002ece:	4b10      	ldr	r3, [pc, #64]	; (8002f10 <chThdExit+0x50>)
 8002ed0:	699c      	ldr	r4, [r3, #24]
  return (bool)(tlp->next != (thread_t *)tlp);
 8002ed2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  tp->u.exitcode = msg;
 8002ed4:	6265      	str	r5, [r4, #36]	; 0x24
  while (list_notempty(&tp->waiting)) {
 8002ed6:	f104 0528 	add.w	r5, r4, #40	; 0x28
 8002eda:	42a8      	cmp	r0, r5
 8002edc:	d006      	beq.n	8002eec <chThdExit+0x2c>
  tlp->next = tp->queue.next;
 8002ede:	6803      	ldr	r3, [r0, #0]
 8002ee0:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8002ee2:	f7fd fce5 	bl	80008b0 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
 8002ee6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 8002ee8:	42a8      	cmp	r0, r5
 8002eea:	d1f8      	bne.n	8002ede <chThdExit+0x1e>
  if ((tp->refs == (trefs_t)0) &&
 8002eec:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8002ef0:	b93b      	cbnz	r3, 8002f02 <chThdExit+0x42>
 8002ef2:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8002ef6:	079b      	lsls	r3, r3, #30
 8002ef8:	d103      	bne.n	8002f02 <chThdExit+0x42>
    REG_REMOVE(tp);
 8002efa:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8002efe:	6113      	str	r3, [r2, #16]
 8002f00:	615a      	str	r2, [r3, #20]
  chSchGoSleepS(CH_STATE_FINAL);
 8002f02:	200f      	movs	r0, #15
 8002f04:	f7fe fd8c 	bl	8001a20 <chSchGoSleepS>
  chDbgAssert(false, "zombies apocalypse");
 8002f08:	4802      	ldr	r0, [pc, #8]	; (8002f14 <chThdExit+0x54>)
 8002f0a:	f7fd fc41 	bl	8000790 <chSysHalt>
 8002f0e:	bf00      	nop
 8002f10:	20000e84 	.word	0x20000e84
 8002f14:	08005194 	.word	0x08005194
	...

08002f20 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8002f20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002f24:	b085      	sub	sp, #20
  qnotify_t nfy = oqp->q_notify;
  size_t max = n;

  osalDbgCheck(n > 0U);
 8002f26:	2a00      	cmp	r2, #0
 8002f28:	d06e      	beq.n	8003008 <oqWriteTimeout+0xe8>
 8002f2a:	4604      	mov	r4, r0
 8002f2c:	460d      	mov	r5, r1
 8002f2e:	4698      	mov	r8, r3
 8002f30:	4616      	mov	r6, r2
  qnotify_t nfy = oqp->q_notify;
 8002f32:	f8d0 a01c 	ldr.w	sl, [r0, #28]
 8002f36:	2720      	movs	r7, #32
 8002f38:	f387 8811 	msr	BASEPRI, r7
 8002f3c:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 800302c <oqWriteTimeout+0x10c>
 8002f40:	f7ff fcce 	bl	80028e0 <_dbg_check_lock>
 8002f44:	9701      	str	r7, [sp, #4]
 8002f46:	9602      	str	r6, [sp, #8]
 8002f48:	4637      	mov	r7, r6
  if (n > oqGetEmptyI(oqp)) {
 8002f4a:	68a3      	ldr	r3, [r4, #8]
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8002f4c:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
  if (n > oqGetEmptyI(oqp)) {
 8002f50:	42bb      	cmp	r3, r7
    n = oqGetEmptyI(oqp);
 8002f52:	bf34      	ite	cc
 8002f54:	68a6      	ldrcc	r6, [r4, #8]
  if (n > oqGetEmptyI(oqp)) {
 8002f56:	463e      	movcs	r6, r7
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8002f58:	1a12      	subs	r2, r2, r0
  if (n < s1) {
 8002f5a:	42b2      	cmp	r2, r6
 8002f5c:	d857      	bhi.n	800300e <oqWriteTimeout+0xee>
  else if (n > s1) {
 8002f5e:	d323      	bcc.n	8002fa8 <oqWriteTimeout+0x88>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8002f60:	4632      	mov	r2, r6
 8002f62:	4629      	mov	r1, r5
 8002f64:	f7fd fa00 	bl	8000368 <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8002f68:	68e2      	ldr	r2, [r4, #12]
 8002f6a:	6162      	str	r2, [r4, #20]
  oqp->q_counter -= n;
 8002f6c:	68a2      	ldr	r2, [r4, #8]
 8002f6e:	1b92      	subs	r2, r2, r6
 8002f70:	60a2      	str	r2, [r4, #8]

  while (n > 0U) {
    size_t done;

    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
 8002f72:	bb5e      	cbnz	r6, 8002fcc <oqWriteTimeout+0xac>
  return chThdEnqueueTimeoutS(tqp, timeout);
 8002f74:	4641      	mov	r1, r8
 8002f76:	4620      	mov	r0, r4
 8002f78:	f7fe fe4a 	bl	8001c10 <chThdEnqueueTimeoutS>
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8002f7c:	2800      	cmp	r0, #0
 8002f7e:	d0e4      	beq.n	8002f4a <oqWriteTimeout+0x2a>
 8002f80:	9e02      	ldr	r6, [sp, #8]
  _dbg_check_unlock();
 8002f82:	f7ff fc85 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002f86:	f8d9 3000 	ldr.w	r3, [r9]
 8002f8a:	454b      	cmp	r3, r9
 8002f8c:	d005      	beq.n	8002f9a <oqWriteTimeout+0x7a>
 8002f8e:	f8d9 2018 	ldr.w	r2, [r9, #24]
 8002f92:	689b      	ldr	r3, [r3, #8]
 8002f94:	6892      	ldr	r2, [r2, #8]
 8002f96:	429a      	cmp	r2, r3
 8002f98:	d341      	bcc.n	800301e <oqWriteTimeout+0xfe>
 8002f9a:	2300      	movs	r3, #0
 8002f9c:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
 8002fa0:	1bf0      	subs	r0, r6, r7
 8002fa2:	b005      	add	sp, #20
 8002fa4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8002fa8:	4629      	mov	r1, r5
    s2 = n - s1;
 8002faa:	eba6 0b02 	sub.w	fp, r6, r2
 8002fae:	9203      	str	r2, [sp, #12]
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8002fb0:	f7fd f9da 	bl	8000368 <memcpy>
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8002fb4:	9a03      	ldr	r2, [sp, #12]
 8002fb6:	68e0      	ldr	r0, [r4, #12]
 8002fb8:	18a9      	adds	r1, r5, r2
 8002fba:	465a      	mov	r2, fp
 8002fbc:	f7fd f9d4 	bl	8000368 <memcpy>
  oqp->q_counter -= n;
 8002fc0:	68a2      	ldr	r2, [r4, #8]
    oqp->q_wrptr = oqp->q_buffer + s2;
 8002fc2:	68e1      	ldr	r1, [r4, #12]
  oqp->q_counter -= n;
 8002fc4:	1b92      	subs	r2, r2, r6
    oqp->q_wrptr = oqp->q_buffer + s2;
 8002fc6:	4459      	add	r1, fp
 8002fc8:	6161      	str	r1, [r4, #20]
  oqp->q_counter -= n;
 8002fca:	60a2      	str	r2, [r4, #8]
      if (nfy != NULL) {
 8002fcc:	f1ba 0f00 	cmp.w	sl, #0
 8002fd0:	d001      	beq.n	8002fd6 <oqWriteTimeout+0xb6>
        nfy(oqp);
 8002fd2:	4620      	mov	r0, r4
 8002fd4:	47d0      	blx	sl
  _dbg_check_unlock();
 8002fd6:	f7ff fc5b 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002fda:	f8d9 2000 	ldr.w	r2, [r9]
 8002fde:	454a      	cmp	r2, r9
 8002fe0:	d005      	beq.n	8002fee <oqWriteTimeout+0xce>
 8002fe2:	f8d9 1018 	ldr.w	r1, [r9, #24]
 8002fe6:	6892      	ldr	r2, [r2, #8]
 8002fe8:	6889      	ldr	r1, [r1, #8]
 8002fea:	4291      	cmp	r1, r2
 8002fec:	d317      	bcc.n	800301e <oqWriteTimeout+0xfe>
 8002fee:	2300      	movs	r3, #0
 8002ff0:	f383 8811 	msr	BASEPRI, r3
 8002ff4:	9b01      	ldr	r3, [sp, #4]
      n  -= done;
 8002ff6:	1bbf      	subs	r7, r7, r6
      bp += done;
 8002ff8:	4435      	add	r5, r6
 8002ffa:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002ffe:	f7ff fc6f 	bl	80028e0 <_dbg_check_lock>
  while (n > 0U) {
 8003002:	2f00      	cmp	r7, #0
 8003004:	d1a1      	bne.n	8002f4a <oqWriteTimeout+0x2a>
 8003006:	e7bb      	b.n	8002f80 <oqWriteTimeout+0x60>
  osalDbgCheck(n > 0U);
 8003008:	4806      	ldr	r0, [pc, #24]	; (8003024 <oqWriteTimeout+0x104>)
 800300a:	f7fd fbc1 	bl	8000790 <chSysHalt>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 800300e:	4632      	mov	r2, r6
 8003010:	4629      	mov	r1, r5
 8003012:	f7fd f9a9 	bl	8000368 <memcpy>
    oqp->q_wrptr += n;
 8003016:	6962      	ldr	r2, [r4, #20]
 8003018:	4432      	add	r2, r6
 800301a:	6162      	str	r2, [r4, #20]
 800301c:	e7a6      	b.n	8002f6c <oqWriteTimeout+0x4c>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800301e:	4802      	ldr	r0, [pc, #8]	; (8003028 <oqWriteTimeout+0x108>)
 8003020:	f7fd fbb6 	bl	8000790 <chSysHalt>
 8003024:	08004fec 	.word	0x08004fec
 8003028:	080050a4 	.word	0x080050a4
 800302c:	20000e84 	.word	0x20000e84

08003030 <serial_write>:
      chprintf(chp,"%c", c);
    }
  }
}

void serial_write(char *data) {
 8003030:	b510      	push	{r4, lr}
 8003032:	4604      	mov	r4, r0

  sdWrite(&SD4, (uint8_t*) data, strlen(data));
 8003034:	f7fd fa44 	bl	80004c0 <strlen>
 8003038:	4621      	mov	r1, r4
 800303a:	4602      	mov	r2, r0
 800303c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003040:	4805      	ldr	r0, [pc, #20]	; (8003058 <serial_write+0x28>)
 8003042:	f7ff ff6d 	bl	8002f20 <oqWriteTimeout>
  chprintf(chp, "%s", data);
 8003046:	4b05      	ldr	r3, [pc, #20]	; (800305c <serial_write+0x2c>)
 8003048:	4905      	ldr	r1, [pc, #20]	; (8003060 <serial_write+0x30>)
 800304a:	6818      	ldr	r0, [r3, #0]
 800304c:	4622      	mov	r2, r4
}
 800304e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chprintf(chp, "%s", data);
 8003052:	f7fe bf95 	b.w	8001f80 <chprintf>
 8003056:	bf00      	nop
 8003058:	200008b8 	.word	0x200008b8
 800305c:	200018c0 	.word	0x200018c0
 8003060:	08004d04 	.word	0x08004d04
	...

08003070 <main>:

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8003070:	4b25      	ldr	r3, [pc, #148]	; (8003108 <main+0x98>)
  PWR->CR |= PWR_CR_DBP;
 8003072:	4826      	ldr	r0, [pc, #152]	; (800310c <main+0x9c>)
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8003074:	691a      	ldr	r2, [r3, #16]
 8003076:	ea6f 52c2 	mvn.w	r2, r2, lsl #23
 800307a:	ea6f 52d2 	mvn.w	r2, r2, lsr #23

int main(void) {
 800307e:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8003082:	611a      	str	r2, [r3, #16]
 8003084:	691a      	ldr	r2, [r3, #16]
 8003086:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800308a:	611a      	str	r2, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 800308c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8003090:	691a      	ldr	r2, [r3, #16]
  rccResetAHB2(~0);
 8003092:	695a      	ldr	r2, [r3, #20]
 8003094:	615c      	str	r4, [r3, #20]
 8003096:	2200      	movs	r2, #0
 8003098:	6959      	ldr	r1, [r3, #20]
 800309a:	615a      	str	r2, [r3, #20]
 800309c:	6959      	ldr	r1, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800309e:	6a19      	ldr	r1, [r3, #32]
 80030a0:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
 80030a4:	6219      	str	r1, [r3, #32]
 80030a6:	6a19      	ldr	r1, [r3, #32]
 80030a8:	f001 5180 	and.w	r1, r1, #268435456	; 0x10000000
 80030ac:	6219      	str	r1, [r3, #32]
 80030ae:	6a19      	ldr	r1, [r3, #32]
  rccResetAPB2(~0);
 80030b0:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80030b2:	625c      	str	r4, [r3, #36]	; 0x24
 80030b4:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80030b6:	625a      	str	r2, [r3, #36]	; 0x24
 80030b8:	6a59      	ldr	r1, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 80030ba:	6c19      	ldr	r1, [r3, #64]	; 0x40
 80030bc:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80030c0:	6419      	str	r1, [r3, #64]	; 0x40
 80030c2:	6e19      	ldr	r1, [r3, #96]	; 0x60
 80030c4:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80030c8:	6619      	str	r1, [r3, #96]	; 0x60
 80030ca:	6e19      	ldr	r1, [r3, #96]	; 0x60
  PWR->CR |= PWR_CR_DBP;
 80030cc:	6801      	ldr	r1, [r0, #0]
 80030ce:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 80030d2:	6001      	str	r1, [r0, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 80030d4:	6f19      	ldr	r1, [r3, #112]	; 0x70
 80030d6:	f401 7140 	and.w	r1, r1, #768	; 0x300
 80030da:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 80030de:	b087      	sub	sp, #28
 80030e0:	d003      	beq.n	80030ea <main+0x7a>
    RCC->BDCR = RCC_BDCR_BDRST;
 80030e2:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 80030e6:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 80030e8:	671a      	str	r2, [r3, #112]	; 0x70
  PWR->CSR &= ~PWR_CSR_BRE;
 80030ea:	4c08      	ldr	r4, [pc, #32]	; (800310c <main+0x9c>)
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma.allocated_mask = 0U;
 80030ec:	4808      	ldr	r0, [pc, #32]	; (8003110 <main+0xa0>)
 80030ee:	6861      	ldr	r1, [r4, #4]
 80030f0:	4a08      	ldr	r2, [pc, #32]	; (8003114 <main+0xa4>)
 80030f2:	4d09      	ldr	r5, [pc, #36]	; (8003118 <main+0xa8>)
 80030f4:	f421 7100 	bic.w	r1, r1, #512	; 0x200
 80030f8:	2300      	movs	r3, #0
 80030fa:	6061      	str	r1, [r4, #4]
 80030fc:	4601      	mov	r1, r0
 80030fe:	6003      	str	r3, [r0, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8003100:	f102 00c0 	add.w	r0, r2, #192	; 0xc0
 8003104:	e00c      	b.n	8003120 <main+0xb0>
 8003106:	bf00      	nop
 8003108:	40023800 	.word	0x40023800
 800310c:	40007000 	.word	0x40007000
 8003110:	200018e0 	.word	0x200018e0
 8003114:	080051bc 	.word	0x080051bc
 8003118:	40026010 	.word	0x40026010
 800311c:	f852 5c0c 	ldr.w	r5, [r2, #-12]
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 8003120:	602b      	str	r3, [r5, #0]
    dma.streams[i].func = NULL;
 8003122:	320c      	adds	r2, #12
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8003124:	4290      	cmp	r0, r2
    dma.streams[i].func = NULL;
 8003126:	604b      	str	r3, [r1, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8003128:	f101 0108 	add.w	r1, r1, #8
 800312c:	d1f6      	bne.n	800311c <main+0xac>

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800312e:	4ac1      	ldr	r2, [pc, #772]	; (8003434 <main+0x3c4>)
 *
 * @init
 */
void dacObjectInit(DACDriver *dacp) {

  dacp->state = DAC_STOP;
 8003130:	49c1      	ldr	r1, [pc, #772]	; (8003438 <main+0x3c8>)
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8003132:	4fc2      	ldr	r7, [pc, #776]	; (800343c <main+0x3cc>)
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
 8003134:	4cc2      	ldr	r4, [pc, #776]	; (8003440 <main+0x3d0>)
 */
void dac_lld_init(void) {

#if STM32_DAC_USE_DAC1_CH1
  dacObjectInit(&DACD1);
  DACD1.params  = &dac1_ch1_params;
 8003136:	f8df 836c 	ldr.w	r8, [pc, #876]	; 80034a4 <main+0x434>
  dacp->config = NULL;
 800313a:	610b      	str	r3, [r1, #16]
 800313c:	2060      	movs	r0, #96	; 0x60
  DMA1->LIFCR = 0xFFFFFFFFU;
 800313e:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003142:	2540      	movs	r5, #64	; 0x40
 8003144:	f8c7 c008 	str.w	ip, [r7, #8]
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8003148:	4ebe      	ldr	r6, [pc, #760]	; (8003444 <main+0x3d4>)
#if DAC_USE_WAIT
  dacp->thread = NULL;
 800314a:	614b      	str	r3, [r1, #20]
 800314c:	f04f 0e80 	mov.w	lr, #128	; 0x80
  DMA1->HIFCR = 0xFFFFFFFFU;
 8003150:	f8c7 c00c 	str.w	ip, [r7, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 8003154:	f8c4 c008 	str.w	ip, [r4, #8]
  mp->owner = NULL;
 8003158:	620b      	str	r3, [r1, #32]
  DMA2->HIFCR = 0xFFFFFFFFU;
 800315a:	f8c4 c00c 	str.w	ip, [r4, #12]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800315e:	f882 0306 	strb.w	r0, [r2, #774]	; 0x306
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003162:	f44f 7480 	mov.w	r4, #256	; 0x100
 8003166:	f8c1 8028 	str.w	r8, [r1, #40]	; 0x28
 800316a:	f8c2 5180 	str.w	r5, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800316e:	6015      	str	r5, [r2, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003170:	f44f 7500 	mov.w	r5, #512	; 0x200
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8003174:	f882 0307 	strb.w	r0, [r2, #775]	; 0x307
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003178:	f8c2 e180 	str.w	lr, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800317c:	f8c2 e000 	str.w	lr, [r2]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8003180:	f882 0308 	strb.w	r0, [r2, #776]	; 0x308
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003184:	f8c2 4180 	str.w	r4, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8003188:	6014      	str	r4, [r2, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800318a:	f882 0309 	strb.w	r0, [r2, #777]	; 0x309
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800318e:	f8c2 5180 	str.w	r5, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8003192:	6015      	str	r5, [r2, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003194:	f44f 6580 	mov.w	r5, #1024	; 0x400
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8003198:	f882 030a 	strb.w	r0, [r2, #778]	; 0x30a
 800319c:	46b0      	mov	r8, r6
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800319e:	f8c2 5180 	str.w	r5, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80031a2:	6015      	str	r5, [r2, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80031a4:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80031a8:	f882 0317 	strb.w	r0, [r2, #791]	; 0x317
  tqp->next = (thread_t *)tqp;
 80031ac:	f101 0718 	add.w	r7, r1, #24
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80031b0:	f8c2 5180 	str.w	r5, [r2, #384]	; 0x180
 80031b4:	f8df 92f0 	ldr.w	r9, [pc, #752]	; 80034a8 <main+0x438>
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80031b8:	6015      	str	r5, [r2, #0]
  dacp->state = DAC_STOP;
 80031ba:	2501      	movs	r5, #1
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80031bc:	f882 0328 	strb.w	r0, [r2, #808]	; 0x328
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80031c0:	f8c2 4184 	str.w	r4, [r2, #388]	; 0x184
 80031c4:	618f      	str	r7, [r1, #24]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80031c6:	6054      	str	r4, [r2, #4]
  tqp->prev = (thread_t *)tqp;
 80031c8:	61cf      	str	r7, [r1, #28]
 80031ca:	700d      	strb	r5, [r1, #0]
  DACD1.dma = NULL;
 80031cc:	62cb      	str	r3, [r1, #44]	; 0x2c
 80031ce:	f848 9b04 	str.w	r9, [r8], #4
 80031d2:	489d      	ldr	r0, [pc, #628]	; (8003448 <main+0x3d8>)
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 80031d4:	f8c6 8004 	str.w	r8, [r6, #4]
#endif

#if STM32_DAC_USE_DAC1_CH2
  dacObjectInit(&DACD2);
  DACD2.params  = &dac1_ch2_params;
 80031d8:	f8df 82d0 	ldr.w	r8, [pc, #720]	; 80034ac <main+0x43c>
  gptObjectInit(&GPTD5);
#endif

#if STM32_GPT_USE_TIM6
  /* Driver initialization.*/
  GPTD6.tim = STM32_TIM6;
 80031dc:	4c9b      	ldr	r4, [pc, #620]	; (800344c <main+0x3dc>)
 80031de:	6203      	str	r3, [r0, #32]
 80031e0:	e9c0 830a 	strd	r8, r3, [r0, #40]	; 0x28
  tqp->next = (thread_t *)tqp;
 80031e4:	f100 0818 	add.w	r8, r0, #24
  dacp->thread = NULL;
 80031e8:	e9c0 3304 	strd	r3, r3, [r0, #16]
  tqp->prev = (thread_t *)tqp;
 80031ec:	e9c0 8806 	strd	r8, r8, [r0, #24]
  dacp->state = DAC_STOP;
 80031f0:	7005      	strb	r5, [r0, #0]
 80031f2:	4897      	ldr	r0, [pc, #604]	; (8003450 <main+0x3e0>)
 80031f4:	60e0      	str	r0, [r4, #12]
  oqp->q_counter = size;
 80031f6:	f04f 0910 	mov.w	r9, #16
  tqp->next = (thread_t *)tqp;
 80031fa:	f106 000c 	add.w	r0, r6, #12
  usbp->state        = USB_STOP;
 80031fe:	4f95      	ldr	r7, [pc, #596]	; (8003454 <main+0x3e4>)
 8003200:	4995      	ldr	r1, [pc, #596]	; (8003458 <main+0x3e8>)
  iqp->q_counter = 0;
 8003202:	6173      	str	r3, [r6, #20]
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
  gptp->config = NULL;
 8003204:	6063      	str	r3, [r4, #4]
  tqp->prev = (thread_t *)tqp;
 8003206:	e9c6 0003 	strd	r0, r0, [r6, #12]
  oqp->q_counter = size;
 800320a:	f8c6 9038 	str.w	r9, [r6, #56]	; 0x38
  iqp->q_top     = bp + size;
 800320e:	f106 0064 	add.w	r0, r6, #100	; 0x64
  oqp->q_top     = bp + size;
 8003212:	f106 0974 	add.w	r9, r6, #116	; 0x74
  gptp->state  = GPT_STOP;
 8003216:	7025      	strb	r5, [r4, #0]
  iqp->q_buffer  = bp;
 8003218:	f106 0454 	add.w	r4, r6, #84	; 0x54
  iqp->q_wrptr   = bp;
 800321c:	e9c6 4408 	strd	r4, r4, [r6, #32]
  oqp->q_wrptr   = bp;
 8003220:	e9c6 0011 	strd	r0, r0, [r6, #68]	; 0x44
  SD3.usart = USART3;
#endif

#if STM32_SERIAL_USE_UART4
  sdObjectInit(&SD4, NULL, notify4);
  SD4.usart = UART4;
 8003224:	f8df 8288 	ldr.w	r8, [pc, #648]	; 80034b0 <main+0x440>
  oqp->q_top     = bp + size;
 8003228:	f8c6 9040 	str.w	r9, [r6, #64]	; 0x40
  iqp->q_buffer  = bp;
 800322c:	61b4      	str	r4, [r6, #24]
  iqp->q_top     = bp + size;
 800322e:	61f0      	str	r0, [r6, #28]
  tqp->next = (thread_t *)tqp;
 8003230:	f106 0430 	add.w	r4, r6, #48	; 0x30
  oqp->q_buffer  = bp;
 8003234:	63f0      	str	r0, [r6, #60]	; 0x3c
  oqp->q_notify  = onfy;
 8003236:	f8df 927c 	ldr.w	r9, [pc, #636]	; 80034b4 <main+0x444>

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 800323a:	4888      	ldr	r0, [pc, #544]	; (800345c <main+0x3ec>)
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 800323c:	7235      	strb	r5, [r6, #8]
  iqp->q_link    = link;
 800323e:	e9c6 360a 	strd	r3, r6, [r6, #40]	; 0x28
  tqp->prev = (thread_t *)tqp;
 8003242:	e9c6 440c 	strd	r4, r4, [r6, #48]	; 0x30
  oqp->q_link    = link;
 8003246:	6536      	str	r6, [r6, #80]	; 0x50
  oqp->q_notify  = onfy;
 8003248:	f8c6 904c 	str.w	r9, [r6, #76]	; 0x4c
 800324c:	f8c6 8074 	str.w	r8, [r6, #116]	; 0x74
 8003250:	703d      	strb	r5, [r7, #0]
 8003252:	700d      	strb	r5, [r1, #0]
 8003254:	6c04      	ldr	r4, [r0, #64]	; 0x40
    usbp->in_params[i]  = NULL;
 8003256:	627b      	str	r3, [r7, #36]	; 0x24
 8003258:	432c      	orrs	r4, r5
 800325a:	6404      	str	r4, [r0, #64]	; 0x40
  USBD1.otg       = OTG_FS;
 800325c:	f04f 48a0 	mov.w	r8, #1342177280	; 0x50000000
  USBD1.otgparams = &fsparams;
 8003260:	4c7f      	ldr	r4, [pc, #508]	; (8003460 <main+0x3f0>)
  USBD1.otg       = OTG_FS;
 8003262:	f8c7 806c 	str.w	r8, [r7, #108]	; 0x6c
  USBD1.otgparams = &fsparams;
 8003266:	673c      	str	r4, [r7, #112]	; 0x70
  USBD2.otg       = OTG_HS;
 8003268:	f8df 824c 	ldr.w	r8, [pc, #588]	; 80034b8 <main+0x448>
  USBD2.otgparams = &hsparams;
 800326c:	4c7d      	ldr	r4, [pc, #500]	; (8003464 <main+0x3f4>)
    usbp->out_params[i] = NULL;
 800326e:	63bb      	str	r3, [r7, #56]	; 0x38
 8003270:	e9c1 841b 	strd	r8, r4, [r1, #108]	; 0x6c
  usbp->transmitting = 0;
 8003274:	e9c7 3301 	strd	r3, r3, [r7, #4]
 8003278:	e9c1 3301 	strd	r3, r3, [r1, #4]
    usbp->in_params[i]  = NULL;
 800327c:	62bb      	str	r3, [r7, #40]	; 0x28
    usbp->out_params[i] = NULL;
 800327e:	63fb      	str	r3, [r7, #60]	; 0x3c
    usbp->in_params[i]  = NULL;
 8003280:	62fb      	str	r3, [r7, #44]	; 0x2c
    usbp->out_params[i] = NULL;
 8003282:	643b      	str	r3, [r7, #64]	; 0x40
    usbp->in_params[i]  = NULL;
 8003284:	633b      	str	r3, [r7, #48]	; 0x30
    usbp->out_params[i] = NULL;
 8003286:	647b      	str	r3, [r7, #68]	; 0x44
    usbp->in_params[i]  = NULL;
 8003288:	637b      	str	r3, [r7, #52]	; 0x34
    usbp->out_params[i] = NULL;
 800328a:	64bb      	str	r3, [r7, #72]	; 0x48
    usbp->in_params[i]  = NULL;
 800328c:	624b      	str	r3, [r1, #36]	; 0x24
    usbp->out_params[i] = NULL;
 800328e:	638b      	str	r3, [r1, #56]	; 0x38
    usbp->in_params[i]  = NULL;
 8003290:	628b      	str	r3, [r1, #40]	; 0x28
    usbp->out_params[i] = NULL;
 8003292:	63cb      	str	r3, [r1, #60]	; 0x3c
    usbp->in_params[i]  = NULL;
 8003294:	62cb      	str	r3, [r1, #44]	; 0x2c
    usbp->out_params[i] = NULL;
 8003296:	640b      	str	r3, [r1, #64]	; 0x40
    usbp->in_params[i]  = NULL;
 8003298:	630b      	str	r3, [r1, #48]	; 0x30
    usbp->out_params[i] = NULL;
 800329a:	644b      	str	r3, [r1, #68]	; 0x44
    usbp->in_params[i]  = NULL;
 800329c:	634b      	str	r3, [r1, #52]	; 0x34
    usbp->out_params[i] = NULL;
 800329e:	648b      	str	r3, [r1, #72]	; 0x48
 80032a0:	6e01      	ldr	r1, [r0, #96]	; 0x60

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80032a2:	f8df 8218 	ldr.w	r8, [pc, #536]	; 80034bc <main+0x44c>
  tqp->next = (thread_t *)tqp;
 80032a6:	4c70      	ldr	r4, [pc, #448]	; (8003468 <main+0x3f8>)
  ST_ENABLE_CLOCK();
 80032a8:	4329      	orrs	r1, r5
 80032aa:	6601      	str	r1, [r0, #96]	; 0x60
 80032ac:	6e01      	ldr	r1, [r0, #96]	; 0x60
  ST_ENABLE_STOP();
 80032ae:	f8d8 1008 	ldr.w	r1, [r8, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 80032b2:	f8c4 c024 	str.w	ip, [r4, #36]	; 0x24
 80032b6:	4329      	orrs	r1, r5
 80032b8:	f8c8 1008 	str.w	r1, [r8, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80032bc:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 80032c0:	f242 08cf 	movw	r8, #8399	; 0x20cf
 80032c4:	f8c1 8028 	str.w	r8, [r1, #40]	; 0x28
  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 80032c8:	4868      	ldr	r0, [pc, #416]	; (800346c <main+0x3fc>)
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80032ca:	f8c1 c02c 	str.w	ip, [r1, #44]	; 0x2c
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 80032ce:	f104 0840 	add.w	r8, r4, #64	; 0x40
  STM32_ST_TIM->CCMR1  = 0;
 80032d2:	618b      	str	r3, [r1, #24]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80032d4:	f04f 5c80 	mov.w	ip, #268435456	; 0x10000000
  tqp->prev = (thread_t *)tqp;
 80032d8:	6064      	str	r4, [r4, #4]
  STM32_ST_TIM->CCR[0] = 0;
 80032da:	634b      	str	r3, [r1, #52]	; 0x34
  ch.rlist.prio = NOPRIO;
 80032dc:	60a3      	str	r3, [r4, #8]
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
 80032de:	60cb      	str	r3, [r1, #12]
  ch.rlist.newer = (thread_t *)&ch.rlist;
 80032e0:	6124      	str	r4, [r4, #16]
  STM32_ST_TIM->CR2    = 0;
 80032e2:	604b      	str	r3, [r1, #4]
  ch.rlist.older = (thread_t *)&ch.rlist;
 80032e4:	6164      	str	r4, [r4, #20]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80032e6:	614d      	str	r5, [r1, #20]
  ch.vtlist.lasttime = (systime_t)0;
 80032e8:	62a3      	str	r3, [r4, #40]	; 0x28
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 80032ea:	f104 031c 	add.w	r3, r4, #28
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80032ee:	600d      	str	r5, [r1, #0]
  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 80032f0:	63a0      	str	r0, [r4, #56]	; 0x38
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80032f2:	f882 e31c 	strb.w	lr, [r2, #796]	; 0x31c
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 80032f6:	f8c4 803c 	str.w	r8, [r4, #60]	; 0x3c
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80032fa:	f8c2 c180 	str.w	ip, [r2, #384]	; 0x180
 80032fe:	61e3      	str	r3, [r4, #28]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8003300:	f8c2 c000 	str.w	ip, [r2]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8003304:	6223      	str	r3, [r4, #32]
  tqp->next = (thread_t *)tqp;
 8003306:	6024      	str	r4, [r4, #0]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8003308:	2300      	movs	r3, #0
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 800330a:	3301      	adds	r3, #1
 800330c:	eb04 1203 	add.w	r2, r4, r3, lsl #4
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8003310:	2b80      	cmp	r3, #128	; 0x80
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8003312:	f892 1030 	ldrb.w	r1, [r2, #48]	; 0x30
 8003316:	f36f 0102 	bfc	r1, #0, #3
 800331a:	f882 1030 	strb.w	r1, [r2, #48]	; 0x30
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 800331e:	d1f4      	bne.n	800330a <main+0x29a>
  default_heap.provider = chCoreAllocAlignedWithOffset;
 8003320:	4953      	ldr	r1, [pc, #332]	; (8003470 <main+0x400>)
 8003322:	4b54      	ldr	r3, [pc, #336]	; (8003474 <main+0x404>)
 8003324:	4a54      	ldr	r2, [pc, #336]	; (8003478 <main+0x408>)
 8003326:	600a      	str	r2, [r1, #0]
 8003328:	f101 020c 	add.w	r2, r1, #12
  tqp->prev = (thread_t *)tqp;
 800332c:	e9c1 2203 	strd	r2, r2, [r1, #12]
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 8003330:	f103 0210 	add.w	r2, r3, #16
 8003334:	611a      	str	r2, [r3, #16]
  mp->object_size = size;
 8003336:	2214      	movs	r2, #20
 8003338:	619a      	str	r2, [r3, #24]
 800333a:	f103 0224 	add.w	r2, r3, #36	; 0x24
 800333e:	625a      	str	r2, [r3, #36]	; 0x24
 8003340:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8003344:	629a      	str	r2, [r3, #40]	; 0x28
 8003346:	221c      	movs	r2, #28
 8003348:	631a      	str	r2, [r3, #48]	; 0x30
 800334a:	f103 023c 	add.w	r2, r3, #60	; 0x3c
 800334e:	63da      	str	r2, [r3, #60]	; 0x3c
 8003350:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8003354:	641a      	str	r2, [r3, #64]	; 0x40
 8003356:	f103 0244 	add.w	r2, r3, #68	; 0x44
 800335a:	645a      	str	r2, [r3, #68]	; 0x44
  H_NEXT(&default_heap.header) = NULL;
 800335c:	2200      	movs	r2, #0
  H_PAGES(&default_heap.header) = 0;
 800335e:	e9c1 2201 	strd	r2, r2, [r1, #4]
 8003362:	614a      	str	r2, [r1, #20]
 8003364:	609a      	str	r2, [r3, #8]
  mp->next = NULL;
 8003366:	615a      	str	r2, [r3, #20]
 8003368:	62da      	str	r2, [r3, #44]	; 0x2c
  ch.dbg.lock_cnt = (cnt_t)0;
 800336a:	e9c4 220c 	strd	r2, r2, [r4, #48]	; 0x30
  tmp->last       = (rtcnt_t)0;
 800336e:	e9cd 2201 	strd	r2, r2, [sp, #4]
  ch_memcore.basemem = __heap_base__;
 8003372:	4842      	ldr	r0, [pc, #264]	; (800347c <main+0x40c>)
  ch.tm.offset = (rtcnt_t)0;
 8003374:	f8c4 2884 	str.w	r2, [r4, #2180]	; 0x884
  mp->align = align;
 8003378:	2504      	movs	r5, #4
  tmp->n          = (ucnt_t)0;
 800337a:	9203      	str	r2, [sp, #12]
  mp->provider = provider;
 800337c:	4a40      	ldr	r2, [pc, #256]	; (8003480 <main+0x410>)
 800337e:	621a      	str	r2, [r3, #32]
 8003380:	639a      	str	r2, [r3, #56]	; 0x38
 8003382:	e9c3 3300 	strd	r3, r3, [r3]
 8003386:	4a3f      	ldr	r2, [pc, #252]	; (8003484 <main+0x414>)
  mp->align = align;
 8003388:	61dd      	str	r5, [r3, #28]
 800338a:	635d      	str	r5, [r3, #52]	; 0x34
  ch_memcore.topmem  = __heap_end__;
 800338c:	4b3e      	ldr	r3, [pc, #248]	; (8003488 <main+0x418>)
  ch_memcore.basemem = __heap_base__;
 800338e:	6002      	str	r2, [r0, #0]
  ch_memcore.topmem  = __heap_end__;
 8003390:	6043      	str	r3, [r0, #4]
  tmp->best       = (rtcnt_t)-1;
 8003392:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  tmp->cumulative = (rttime_t)0;
 8003396:	2200      	movs	r2, #0
 8003398:	2300      	movs	r3, #0
  tmp->best       = (rtcnt_t)-1;
 800339a:	9100      	str	r1, [sp, #0]
  tmp->cumulative = (rttime_t)0;
 800339c:	e9cd 2304 	strd	r2, r3, [sp, #16]
    chTMStartMeasurementX(&tm);
 80033a0:	4668      	mov	r0, sp
 80033a2:	f7fd f97d 	bl	80006a0 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 80033a6:	4668      	mov	r0, sp
 80033a8:	f7fd f952 	bl	8000650 <chTMStopMeasurementX>
  } while (i > 0U);
 80033ac:	3d01      	subs	r5, #1
 80033ae:	d1f7      	bne.n	80033a0 <main+0x330>
  ch.tm.offset = tm.best;
 80033b0:	9900      	ldr	r1, [sp, #0]
  REG_INSERT(tp);
 80033b2:	4b36      	ldr	r3, [pc, #216]	; (800348c <main+0x41c>)
 80033b4:	6962      	ldr	r2, [r4, #20]
 80033b6:	f8c4 1884 	str.w	r1, [r4, #2180]	; 0x884
  tp->prio      = prio;
 80033ba:	2180      	movs	r1, #128	; 0x80
 80033bc:	f8c4 1848 	str.w	r1, [r4, #2120]	; 0x848
  tp->realprio  = prio;
 80033c0:	f8c4 187c 	str.w	r1, [r4, #2172]	; 0x87c
  tp->name      = name;
 80033c4:	f8df c0f8 	ldr.w	ip, [pc, #248]	; 80034c0 <main+0x450>
  REG_INSERT(tp);
 80033c8:	f8c4 2854 	str.w	r2, [r4, #2132]	; 0x854
  tp->refs      = (trefs_t)1;
 80033cc:	2101      	movs	r1, #1
  tp->name      = name;
 80033ce:	f8c4 c858 	str.w	ip, [r4, #2136]	; 0x858
    currp->wabase = &__main_thread_stack_base__;
 80033d2:	482f      	ldr	r0, [pc, #188]	; (8003490 <main+0x420>)
  tp->flags     = CH_FLAG_MODE_STATIC;
 80033d4:	f884 5861 	strb.w	r5, [r4, #2145]	; 0x861
  tlp->next = (thread_t *)tlp;
 80033d8:	f103 0c28 	add.w	ip, r3, #40	; 0x28
  tp->mtxlist   = NULL;
 80033dc:	f8c4 5878 	str.w	r5, [r4, #2168]	; 0x878
  tp->epending  = (eventmask_t)0;
 80033e0:	f8c4 5874 	str.w	r5, [r4, #2164]	; 0x874
  REG_INSERT(tp);
 80033e4:	f8c4 4850 	str.w	r4, [r4, #2128]	; 0x850
  tp->refs      = (trefs_t)1;
 80033e8:	f884 1862 	strb.w	r1, [r4, #2146]	; 0x862
  REG_INSERT(tp);
 80033ec:	6113      	str	r3, [r2, #16]
  tqp->next = (thread_t *)tqp;
 80033ee:	f103 022c 	add.w	r2, r3, #44	; 0x2c
  tlp->next = (thread_t *)tlp;
 80033f2:	f8c4 c868 	str.w	ip, [r4, #2152]	; 0x868
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 80033f6:	e9c4 3305 	strd	r3, r3, [r4, #20]
  currp->state = CH_STATE_CURRENT;
 80033fa:	f884 1860 	strb.w	r1, [r4, #2144]	; 0x860
  tqp->next = (thread_t *)tqp;
 80033fe:	f8c4 286c 	str.w	r2, [r4, #2156]	; 0x86c
  tqp->prev = (thread_t *)tqp;
 8003402:	f8c4 2870 	str.w	r2, [r4, #2160]	; 0x870
    currp->wabase = &__main_thread_stack_base__;
 8003406:	f8c4 085c 	str.w	r0, [r4, #2140]	; 0x85c
 800340a:	f04f 0c20 	mov.w	ip, #32
 800340e:	f38c 8811 	msr	BASEPRI, ip
  __ASM volatile ("cpsie i" : : : "memory");
 8003412:	b662      	cpsie	i
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8003414:	4b1f      	ldr	r3, [pc, #124]	; (8003494 <main+0x424>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8003416:	4a20      	ldr	r2, [pc, #128]	; (8003498 <main+0x428>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8003418:	68d9      	ldr	r1, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800341a:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
 800341e:	4001      	ands	r1, r0
  reg_value  =  (reg_value                                   |
 8003420:	430a      	orrs	r2, r1
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8003422:	491e      	ldr	r1, [pc, #120]	; (800349c <main+0x42c>)
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
 8003424:	60da      	str	r2, [r3, #12]
 8003426:	68ca      	ldr	r2, [r1, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8003428:	481d      	ldr	r0, [pc, #116]	; (80034a0 <main+0x430>)
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800342a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800342e:	60ca      	str	r2, [r1, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8003430:	6802      	ldr	r2, [r0, #0]
 8003432:	e047      	b.n	80034c4 <main+0x454>
 8003434:	e000e100 	.word	0xe000e100
 8003438:	20000818 	.word	0x20000818
 800343c:	40026000 	.word	0x40026000
 8003440:	40026400 	.word	0x40026400
 8003444:	20000888 	.word	0x20000888
 8003448:	20000848 	.word	0x20000848
 800344c:	20000878 	.word	0x20000878
 8003450:	40001000 	.word	0x40001000
 8003454:	20000d94 	.word	0x20000d94
 8003458:	20000e0c 	.word	0x20000e0c
 800345c:	40023800 	.word	0x40023800
 8003460:	08005330 	.word	0x08005330
 8003464:	08005340 	.word	0x08005340
 8003468:	20000e84 	.word	0x20000e84
 800346c:	0080fff0 	.word	0x0080fff0
 8003470:	200018c4 	.word	0x200018c4
 8003474:	2000170c 	.word	0x2000170c
 8003478:	08002901 	.word	0x08002901
 800347c:	200018b8 	.word	0x200018b8
 8003480:	08000851 	.word	0x08000851
 8003484:	20002c50 	.word	0x20002c50
 8003488:	20020000 	.word	0x20020000
 800348c:	200016c4 	.word	0x200016c4
 8003490:	20000400 	.word	0x20000400
 8003494:	e000ed00 	.word	0xe000ed00
 8003498:	05fa0300 	.word	0x05fa0300
 800349c:	e000edf0 	.word	0xe000edf0
 80034a0:	e0001000 	.word	0xe0001000
 80034a4:	0800528c 	.word	0x0800528c
 80034a8:	080054d8 	.word	0x080054d8
 80034ac:	080052a8 	.word	0x080052a8
 80034b0:	40004c00 	.word	0x40004c00
 80034b4:	080005e1 	.word	0x080005e1
 80034b8:	40040000 	.word	0x40040000
 80034bc:	e0042000 	.word	0xe0042000
 80034c0:	08005274 	.word	0x08005274
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80034c4:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80034c6:	f042 0201 	orr.w	r2, r2, #1
 80034ca:	6002      	str	r2, [r0, #0]
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80034cc:	2210      	movs	r2, #16
 80034ce:	77da      	strb	r2, [r3, #31]
 80034d0:	f883 c022 	strb.w	ip, [r3, #34]	; 0x22
 80034d4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80034d6:	430b      	orrs	r3, r1
 80034d8:	d10b      	bne.n	80034f2 <main+0x482>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80034da:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
 80034de:	b662      	cpsie	i
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 80034e0:	f8df 801c 	ldr.w	r8, [pc, #28]	; 8003500 <main+0x490>
 80034e4:	4640      	mov	r0, r8
 80034e6:	f7ff fa33 	bl	8002950 <chRegFindThreadByWorkingArea>
 80034ea:	b158      	cbz	r0, 8003504 <main+0x494>
 80034ec:	4802      	ldr	r0, [pc, #8]	; (80034f8 <main+0x488>)
 80034ee:	f7fd f94f 	bl	8000790 <chSysHalt>
    chSysHalt("SV#3");
 80034f2:	4802      	ldr	r0, [pc, #8]	; (80034fc <main+0x48c>)
 80034f4:	f7fd f94c 	bl	8000790 <chSysHalt>
 80034f8:	08005114 	.word	0x08005114
 80034fc:	08004d08 	.word	0x08004d08
 8003500:	20001758 	.word	0x20001758
 8003504:	f44f 79b0 	mov.w	r9, #352	; 0x160
 8003508:	4643      	mov	r3, r8
    *startp++ = v;
 800350a:	2255      	movs	r2, #85	; 0x55
  while (startp < endp) {
 800350c:	f1b9 0901 	subs.w	r9, r9, #1
    *startp++ = v;
 8003510:	f803 2b01 	strb.w	r2, [r3], #1
  while (startp < endp) {
 8003514:	d1fa      	bne.n	800350c <main+0x49c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003516:	2220      	movs	r2, #32
 8003518:	f382 8811 	msr	BASEPRI, r2
  _dbg_check_lock();
 800351c:	f7ff f9e0 	bl	80028e0 <_dbg_check_lock>
  chDbgCheckClassI();
 8003520:	f7fd f95e 	bl	80007e0 <chDbgCheckClassI>
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8003524:	4bcc      	ldr	r3, [pc, #816]	; (8003858 <main+0x7e8>)
  REG_INSERT(tp);
 8003526:	6961      	ldr	r1, [r4, #20]
  tp->name      = name;
 8003528:	48cc      	ldr	r0, [pc, #816]	; (800385c <main+0x7ec>)
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800352a:	f8df e39c 	ldr.w	lr, [pc, #924]	; 80038c8 <main+0x858>
 800352e:	f8df c39c 	ldr.w	ip, [pc, #924]	; 80038cc <main+0x85c>
  tp->name      = name;
 8003532:	f8c8 0130 	str.w	r0, [r8, #304]	; 0x130
  tp->prio      = prio;
 8003536:	f04f 0a01 	mov.w	sl, #1
  REG_INSERT(tp);
 800353a:	f103 0064 	add.w	r0, r3, #100	; 0x64
  tp->state     = CH_STATE_WTSTART;
 800353e:	f04f 0b02 	mov.w	fp, #2
  sdup->vmt = &vmt;
 8003542:	4dc7      	ldr	r5, [pc, #796]	; (8003860 <main+0x7f0>)
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8003544:	f8c8 e0f4 	str.w	lr, [r8, #244]	; 0xf4
  tp->prio      = prio;
 8003548:	e9c8 a348 	strd	sl, r3, [r8, #288]	; 0x120
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800354c:	f8c8 c114 	str.w	ip, [r8, #276]	; 0x114
  tp->epending  = (eventmask_t)0;
 8003550:	e9c8 9953 	strd	r9, r9, [r8, #332]	; 0x14c
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8003554:	f8c8 90f8 	str.w	r9, [r8, #248]	; 0xf8
  REG_INSERT(tp);
 8003558:	f8c8 4128 	str.w	r4, [r8, #296]	; 0x128
 800355c:	f8c8 112c 	str.w	r1, [r8, #300]	; 0x12c
  tp->realprio  = prio;
 8003560:	f8c8 a154 	str.w	sl, [r8, #340]	; 0x154
  tp->refs      = (trefs_t)1;
 8003564:	f888 a13a 	strb.w	sl, [r8, #314]	; 0x13a
  tp->state     = CH_STATE_WTSTART;
 8003568:	f8a8 b138 	strh.w	fp, [r8, #312]	; 0x138
  tp->wabase = tdp->wbase;
 800356c:	f8c8 8134 	str.w	r8, [r8, #308]	; 0x134
  REG_INSERT(tp);
 8003570:	6108      	str	r0, [r1, #16]
  tlp->next = (thread_t *)tlp;
 8003572:	f103 018c 	add.w	r1, r3, #140	; 0x8c
  tqp->next = (thread_t *)tqp;
 8003576:	3390      	adds	r3, #144	; 0x90
 8003578:	e9c8 1350 	strd	r1, r3, [r8, #320]	; 0x140
  tqp->prev = (thread_t *)tqp;
 800357c:	f8c8 3148 	str.w	r3, [r8, #328]	; 0x148
 8003580:	6160      	str	r0, [r4, #20]
  chSchWakeupS(tp, MSG_OK);
 8003582:	f7fe fa0d 	bl	80019a0 <chSchWakeupS.constprop.0>
  chSysUnlock();
 8003586:	f7ff f993 	bl	80028b0 <chSysUnlock.lto_priv.5>
 800358a:	4628      	mov	r0, r5
 800358c:	4bb5      	ldr	r3, [pc, #724]	; (8003864 <main+0x7f4>)
 800358e:	f840 3b04 	str.w	r3, [r0], #4
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8003592:	f205 4e8c 	addw	lr, r5, #1164	; 0x48c
  ibqp->notify    = infy;
 8003596:	4bb4      	ldr	r3, [pc, #720]	; (8003868 <main+0x7f8>)
  obqp->notify    = onfy;
 8003598:	f8df c334 	ldr.w	ip, [pc, #820]	; 80038d0 <main+0x860>
  ibqp->notify    = infy;
 800359c:	63eb      	str	r3, [r5, #60]	; 0x3c
  ibqp->brdptr    = bp;
 800359e:	f105 017c 	add.w	r1, r5, #124	; 0x7c
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 80035a2:	f505 7321 	add.w	r3, r5, #644	; 0x284
  tqp->next = (thread_t *)tqp;
 80035a6:	f105 080c 	add.w	r8, r5, #12
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 80035aa:	f8c5 e05c 	str.w	lr, [r5, #92]	; 0x5c
  obqp->notify    = onfy;
 80035ae:	f8c5 c074 	str.w	ip, [r5, #116]	; 0x74
 80035b2:	f105 0e44 	add.w	lr, r5, #68	; 0x44
  ibqp->bsize     = size + sizeof (size_t);
 80035b6:	f44f 7c82 	mov.w	ip, #260	; 0x104
  ibqp->bcounter  = 0;
 80035ba:	f8c5 9018 	str.w	r9, [r5, #24]
  ibqp->top       = NULL;
 80035be:	e9c5 990d 	strd	r9, r9, [r5, #52]	; 0x34
  obqp->top       = NULL;
 80035c2:	e9c5 991b 	strd	r9, r9, [r5, #108]	; 0x6c
  tqp->prev = (thread_t *)tqp;
 80035c6:	e9c5 8803 	strd	r8, r8, [r5, #12]
  ibqp->bwrptr    = bp;
 80035ca:	e9c5 1107 	strd	r1, r1, [r5, #28]
  obqp->bwrptr    = bp;
 80035ce:	e9c5 3315 	strd	r3, r3, [r5, #84]	; 0x54
 80035d2:	e9c5 ee11 	strd	lr, lr, [r5, #68]	; 0x44
  sdup->state = SDU_STOP;
 80035d6:	f885 a008 	strb.w	sl, [r5, #8]
  ibqp->suspended = suspended;
 80035da:	f885 a014 	strb.w	sl, [r5, #20]
  ibqp->bn        = n;
 80035de:	f8c5 b02c 	str.w	fp, [r5, #44]	; 0x2c
  ibqp->link      = link;
 80035e2:	642d      	str	r5, [r5, #64]	; 0x40
  obqp->suspended = suspended;
 80035e4:	f885 a04c 	strb.w	sl, [r5, #76]	; 0x4c
  obqp->bcounter  = n;
 80035e8:	f8c5 b050 	str.w	fp, [r5, #80]	; 0x50
  obqp->bn        = n;
 80035ec:	f8c5 b064 	str.w	fp, [r5, #100]	; 0x64
  obqp->link      = link;
 80035f0:	67ad      	str	r5, [r5, #120]	; 0x78
 80035f2:	6068      	str	r0, [r5, #4]
  ibqp->buffers   = bp;
 80035f4:	6329      	str	r1, [r5, #48]	; 0x30
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 80035f6:	626b      	str	r3, [r5, #36]	; 0x24
  obqp->buffers   = bp;
 80035f8:	66ab      	str	r3, [r5, #104]	; 0x68
  ibqp->bsize     = size + sizeof (size_t);
 80035fa:	f8c5 c028 	str.w	ip, [r5, #40]	; 0x28
  obqp->bsize     = size + sizeof (size_t);
 80035fe:	f8c5 c060 	str.w	ip, [r5, #96]	; 0x60
 8003602:	2220      	movs	r2, #32
 8003604:	f382 8811 	msr	BASEPRI, r2
 8003608:	f7ff f96a 	bl	80028e0 <_dbg_check_lock>
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
 800360c:	7a2b      	ldrb	r3, [r5, #8]
 800360e:	3b01      	subs	r3, #1
 8003610:	4553      	cmp	r3, sl
 8003612:	f200 8161 	bhi.w	80038d8 <main+0x868>
  sdup->config = config;
 8003616:	4b95      	ldr	r3, [pc, #596]	; (800386c <main+0x7fc>)
 8003618:	f8c5 348c 	str.w	r3, [r5, #1164]	; 0x48c
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 800361c:	627d      	str	r5, [r7, #36]	; 0x24
  usbp->out_params[config->bulk_out - 1U] = sdup;
 800361e:	63bd      	str	r5, [r7, #56]	; 0x38
    usbp->in_params[config->int_in - 1U]  = sdup;
 8003620:	62bd      	str	r5, [r7, #40]	; 0x28
  sdup->state = SDU_READY;
 8003622:	f885 b008 	strb.w	fp, [r5, #8]
  _dbg_check_unlock();
 8003626:	f7ff f933 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800362a:	6823      	ldr	r3, [r4, #0]
 800362c:	42a3      	cmp	r3, r4
 800362e:	d005      	beq.n	800363c <main+0x5cc>
 8003630:	69a2      	ldr	r2, [r4, #24]
 8003632:	689b      	ldr	r3, [r3, #8]
 8003634:	6892      	ldr	r2, [r2, #8]
 8003636:	429a      	cmp	r2, r3
 8003638:	f0c0 8151 	bcc.w	80038de <main+0x86e>
 800363c:	f04f 0900 	mov.w	r9, #0
 8003640:	f389 8811 	msr	BASEPRI, r9
  /*
   * Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
  usbDisconnectBus(serusbcfg.usbp);
 8003644:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8003646:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8003648:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 800364c:	6393      	str	r3, [r2, #56]	; 0x38
  chThdSleepMilliseconds(1500);
 800364e:	f643 2098 	movw	r0, #15000	; 0x3a98
 8003652:	f7ff fbf5 	bl	8002e40 <chThdSleep>
 8003656:	2320      	movs	r3, #32
 8003658:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800365c:	f7ff f940 	bl	80028e0 <_dbg_check_lock>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 8003660:	783b      	ldrb	r3, [r7, #0]
 8003662:	1e5a      	subs	r2, r3, #1
 8003664:	2a01      	cmp	r2, #1
 8003666:	f200 80f1 	bhi.w	800384c <main+0x7dc>
  usbp->config = config;
 800366a:	4a81      	ldr	r2, [pc, #516]	; (8003870 <main+0x800>)
 800366c:	607a      	str	r2, [r7, #4]
  if (usbp->state == USB_STOP) {
 800366e:	2b01      	cmp	r3, #1
    usbp->epc[i] = NULL;
 8003670:	e9c7 9903 	strd	r9, r9, [r7, #12]
 8003674:	e9c7 9905 	strd	r9, r9, [r7, #20]
 8003678:	e9c7 9907 	strd	r9, r9, [r7, #28]
 800367c:	f000 8135 	beq.w	80038ea <main+0x87a>
  usbp->state = USB_READY;
 8003680:	2302      	movs	r3, #2
 8003682:	703b      	strb	r3, [r7, #0]
  _dbg_check_unlock();
 8003684:	f7ff f904 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003688:	6823      	ldr	r3, [r4, #0]
 800368a:	42a3      	cmp	r3, r4
 800368c:	d005      	beq.n	800369a <main+0x62a>
 800368e:	69a2      	ldr	r2, [r4, #24]
 8003690:	689b      	ldr	r3, [r3, #8]
 8003692:	6892      	ldr	r2, [r2, #8]
 8003694:	429a      	cmp	r2, r3
 8003696:	f0c0 80dc 	bcc.w	8003852 <main+0x7e2>
 800369a:	2300      	movs	r3, #0
 800369c:	f383 8811 	msr	BASEPRI, r3
  usbStart(serusbcfg.usbp, &usbcfg);
  usbConnectBus(serusbcfg.usbp);	
 80036a0:	6efa      	ldr	r2, [r7, #108]	; 0x6c

  chp = (BaseSequentialStream*)&SDU1;
 80036a2:	4f74      	ldr	r7, [pc, #464]	; (8003874 <main+0x804>)
  usbConnectBus(serusbcfg.usbp);	
 80036a4:	6b93      	ldr	r3, [r2, #56]	; 0x38

  /* Serial */
  palSetPadMode(GPIOC, 10, PAL_MODE_ALTERNATE(8));
 80036a6:	4874      	ldr	r0, [pc, #464]	; (8003878 <main+0x808>)
  chp = (BaseSequentialStream*)&SDU1;
 80036a8:	603d      	str	r5, [r7, #0]
  usbConnectBus(serusbcfg.usbp);	
 80036aa:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80036ae:	6393      	str	r3, [r2, #56]	; 0x38
  palSetPadMode(GPIOC, 10, PAL_MODE_ALTERNATE(8));
 80036b0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80036b4:	f240 4202 	movw	r2, #1026	; 0x402
 80036b8:	f7fd fe02 	bl	80012c0 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 11, PAL_MODE_ALTERNATE(8));
 80036bc:	486e      	ldr	r0, [pc, #440]	; (8003878 <main+0x808>)
 80036be:	f240 4202 	movw	r2, #1026	; 0x402
 80036c2:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80036c6:	f7fd fdfb 	bl	80012c0 <_pal_lld_setgroupmode>
 80036ca:	2320      	movs	r3, #32
 80036cc:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80036d0:	f7ff f906 	bl	80028e0 <_dbg_check_lock>
void sdStart(SerialDriver *sdp, const SerialConfig *config) {

  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 80036d4:	7a33      	ldrb	r3, [r6, #8]
 80036d6:	1e5a      	subs	r2, r3, #1
 80036d8:	2a01      	cmp	r2, #1
 80036da:	f200 8103 	bhi.w	80038e4 <main+0x874>
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 80036de:	2b01      	cmp	r3, #1
 80036e0:	d112      	bne.n	8003708 <main+0x698>
      nvicEnableVector(STM32_USART3_NUMBER, STM32_SERIAL_USART3_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_UART4
    if (&SD4 == sdp) {
      rccEnableUART4(true);
 80036e2:	4b66      	ldr	r3, [pc, #408]	; (800387c <main+0x80c>)
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80036e4:	4a66      	ldr	r2, [pc, #408]	; (8003880 <main+0x810>)
 80036e6:	6c19      	ldr	r1, [r3, #64]	; 0x40
 80036e8:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
 80036ec:	6419      	str	r1, [r3, #64]	; 0x40
 80036ee:	6e19      	ldr	r1, [r3, #96]	; 0x60
 80036f0:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
 80036f4:	6619      	str	r1, [r3, #96]	; 0x60
 80036f6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80036f8:	21c0      	movs	r1, #192	; 0xc0
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80036fa:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80036fe:	f882 1334 	strb.w	r1, [r2, #820]	; 0x334
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003702:	f8c2 3184 	str.w	r3, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8003706:	6053      	str	r3, [r2, #4]
  USART_TypeDef *u = sdp->usart;
 8003708:	6f72      	ldr	r2, [r6, #116]	; 0x74
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 800370a:	4b5e      	ldr	r3, [pc, #376]	; (8003884 <main+0x814>)
    fck = STM32_PCLK2 / config->speed;
 800370c:	495e      	ldr	r1, [pc, #376]	; (8003888 <main+0x818>)
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 800370e:	429a      	cmp	r2, r3
 8003710:	f000 8173 	beq.w	80039fa <main+0x98a>
 8003714:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8003718:	429a      	cmp	r2, r3
 800371a:	f000 816e 	beq.w	80039fa <main+0x98a>
    fck = STM32_PCLK1 / config->speed;
 800371e:	4b5b      	ldr	r3, [pc, #364]	; (800388c <main+0x81c>)
 8003720:	6808      	ldr	r0, [r1, #0]
 8003722:	fbb3 f3f0 	udiv	r3, r3, r0
  if (config->cr1 & USART_CR1_OVER8)
 8003726:	f9b1 5004 	ldrsh.w	r5, [r1, #4]
 800372a:	8888      	ldrh	r0, [r1, #4]
 800372c:	2d00      	cmp	r5, #0
 800372e:	da05      	bge.n	800373c <main+0x6cc>
    fck = ((fck & ~7) * 2) | (fck & 7);
 8003730:	f023 0507 	bic.w	r5, r3, #7
 8003734:	f003 0307 	and.w	r3, r3, #7
 8003738:	ea43 0345 	orr.w	r3, r3, r5, lsl #1
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800373c:	88cd      	ldrh	r5, [r1, #6]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800373e:	8909      	ldrh	r1, [r1, #8]
  u->BRR = fck;
 8003740:	6093      	str	r3, [r2, #8]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8003742:	f440 5304 	orr.w	r3, r0, #8448	; 0x2100
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
 8003746:	f400 50a0 	and.w	r0, r0, #5120	; 0x1400
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800374a:	f041 0101 	orr.w	r1, r1, #1
    sdp->rxmask = 0xFF;
 800374e:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8003752:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
  u->SR = 0;
 8003756:	f04f 0000 	mov.w	r0, #0
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800375a:	f045 0540 	orr.w	r5, r5, #64	; 0x40
 800375e:	6115      	str	r5, [r2, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8003760:	6151      	str	r1, [r2, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8003762:	60d3      	str	r3, [r2, #12]
    sdp->rxmask = 0xFF;
 8003764:	bf08      	it	eq
 8003766:	217f      	moveq	r1, #127	; 0x7f
  u->SR = 0;
 8003768:	6010      	str	r0, [r2, #0]
    sdp->rxmask = 0xFF;
 800376a:	bf18      	it	ne
 800376c:	21ff      	movne	r1, #255	; 0xff
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 800376e:	2302      	movs	r3, #2
  (void)u->SR;  /* SR reset step 1.*/
 8003770:	6810      	ldr	r0, [r2, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8003772:	6852      	ldr	r2, [r2, #4]
 8003774:	7233      	strb	r3, [r6, #8]
 8003776:	f886 1078 	strb.w	r1, [r6, #120]	; 0x78
  _dbg_check_unlock();
 800377a:	f7ff f889 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800377e:	6823      	ldr	r3, [r4, #0]
 8003780:	42a3      	cmp	r3, r4
 8003782:	d005      	beq.n	8003790 <main+0x720>
 8003784:	69a2      	ldr	r2, [r4, #24]
 8003786:	689b      	ldr	r3, [r3, #8]
 8003788:	6892      	ldr	r2, [r2, #8]
 800378a:	429a      	cmp	r2, r3
 800378c:	f0c0 813a 	bcc.w	8003a04 <main+0x994>
 8003790:	2300      	movs	r3, #0
 8003792:	f383 8811 	msr	BASEPRI, r3
  sdStart(&SD4, &serial_cfg);

  palSetPadMode(GPIOB, 4, PAL_MODE_OUTPUT_PUSHPULL);
 8003796:	4c3e      	ldr	r4, [pc, #248]	; (8003890 <main+0x820>)
  chThdSleepMilliseconds(1000);
  
  while(true) {


    chprintf(chp,"RESETTING\r\n");
 8003798:	f8df 8138 	ldr.w	r8, [pc, #312]	; 80038d4 <main+0x864>
  palSetPadMode(GPIOB, 4, PAL_MODE_OUTPUT_PUSHPULL);
 800379c:	2201      	movs	r2, #1
  palSetPad(GPIOB, 4);
 800379e:	2510      	movs	r5, #16
  palSetPadMode(GPIOB, 4, PAL_MODE_OUTPUT_PUSHPULL);
 80037a0:	4620      	mov	r0, r4
 80037a2:	2110      	movs	r1, #16
 80037a4:	f7fd fd8c 	bl	80012c0 <_pal_lld_setgroupmode>
  (void)chThdCreateStatic(rx_thread_area,
 80037a8:	493a      	ldr	r1, [pc, #232]	; (8003894 <main+0x824>)
 80037aa:	483b      	ldr	r0, [pc, #236]	; (8003898 <main+0x828>)
  palSetPad(GPIOB, 4);
 80037ac:	8325      	strh	r5, [r4, #24]
  (void)chThdCreateStatic(rx_thread_area,
 80037ae:	f7ff fae7 	bl	8002d80 <chThdCreateStatic.constprop.0>
  (void)chThdCreateStatic(echo_thread_area,
 80037b2:	493a      	ldr	r1, [pc, #232]	; (800389c <main+0x82c>)
 80037b4:	483a      	ldr	r0, [pc, #232]	; (80038a0 <main+0x830>)
 80037b6:	f7ff fae3 	bl	8002d80 <chThdCreateStatic.constprop.0>
  chThdSleepMilliseconds(1000);
 80037ba:	f242 7010 	movw	r0, #10000	; 0x2710
 80037be:	f7ff fb3f 	bl	8002e40 <chThdSleep>
  chprintf(chp,"RESETTING\r\n");
 80037c2:	4641      	mov	r1, r8
 80037c4:	6838      	ldr	r0, [r7, #0]
 80037c6:	f7fe fbdb 	bl	8001f80 <chprintf>
  chThdSleepMicroseconds(300);
 80037ca:	2003      	movs	r0, #3
  palClearPad(GPIOB,4);
 80037cc:	8365      	strh	r5, [r4, #26]
  chThdSleepMicroseconds(300);
 80037ce:	f7ff fb37 	bl	8002e40 <chThdSleep>
  chThdSleepMilliseconds(15000);
 80037d2:	4834      	ldr	r0, [pc, #208]	; (80038a4 <main+0x834>)
  palSetPad(GPIOB,4);
 80037d4:	8325      	strh	r5, [r4, #24]
    palClearPad(GPIOB,4);
    chThdSleepMicroseconds(300);
    palSetPad(GPIOB,4);
    
   
    chThdSleepMilliseconds(15000);
 80037d6:	4606      	mov	r6, r0
  chThdSleepMilliseconds(15000);
 80037d8:	f7ff fb32 	bl	8002e40 <chThdSleep>
  serial_write("AT+NBAND?\r\n");
 80037dc:	4832      	ldr	r0, [pc, #200]	; (80038a8 <main+0x838>)
 80037de:	f7ff fc27 	bl	8003030 <serial_write>
  chThdSleepMilliseconds(1000);
 80037e2:	f242 7010 	movw	r0, #10000	; 0x2710
 80037e6:	f7ff fb2b 	bl	8002e40 <chThdSleep>
  serial_write("AT+CSQ\r\n");
 80037ea:	4830      	ldr	r0, [pc, #192]	; (80038ac <main+0x83c>)
 80037ec:	f7ff fc20 	bl	8003030 <serial_write>
  chThdSleepMilliseconds(1000);
 80037f0:	f242 7010 	movw	r0, #10000	; 0x2710
 80037f4:	f7ff fb24 	bl	8002e40 <chThdSleep>
  serial_write("AT+CIMI\r\n");
 80037f8:	482d      	ldr	r0, [pc, #180]	; (80038b0 <main+0x840>)
 80037fa:	f7ff fc19 	bl	8003030 <serial_write>
  chThdSleepMilliseconds(1000);
 80037fe:	f242 7010 	movw	r0, #10000	; 0x2710
 8003802:	f7ff fb1d 	bl	8002e40 <chThdSleep>
  serial_write("AT+CGSN=1\r\n");
 8003806:	482b      	ldr	r0, [pc, #172]	; (80038b4 <main+0x844>)
 8003808:	f7ff fc12 	bl	8003030 <serial_write>
  chThdSleepMilliseconds(1000);
 800380c:	f242 7010 	movw	r0, #10000	; 0x2710
 8003810:	f7ff fb16 	bl	8002e40 <chThdSleep>
  serial_write("AT+CEREG\r\n");
 8003814:	4828      	ldr	r0, [pc, #160]	; (80038b8 <main+0x848>)
 8003816:	f7ff fc0b 	bl	8003030 <serial_write>
  chThdSleepMilliseconds(1000);
 800381a:	f242 7010 	movw	r0, #10000	; 0x2710
 800381e:	f7ff fb0f 	bl	8002e40 <chThdSleep>
  serial_write("AT+CGPADDR\r\n");
 8003822:	4826      	ldr	r0, [pc, #152]	; (80038bc <main+0x84c>)
 8003824:	f7ff fc04 	bl	8003030 <serial_write>
  chThdSleepMilliseconds(1000);
 8003828:	f242 7010 	movw	r0, #10000	; 0x2710
 800382c:	f7ff fb08 	bl	8002e40 <chThdSleep>
    chprintf(chp,"RESETTING\r\n");
 8003830:	4641      	mov	r1, r8
    palClearPad(GPIOB,4);
 8003832:	2510      	movs	r5, #16
    chprintf(chp,"RESETTING\r\n");
 8003834:	6838      	ldr	r0, [r7, #0]
 8003836:	f7fe fba3 	bl	8001f80 <chprintf>
    palClearPad(GPIOB,4);
 800383a:	8365      	strh	r5, [r4, #26]
    chThdSleepMicroseconds(300);
 800383c:	2003      	movs	r0, #3
 800383e:	f7ff faff 	bl	8002e40 <chThdSleep>
    palSetPad(GPIOB,4);
 8003842:	8325      	strh	r5, [r4, #24]
    chThdSleepMilliseconds(15000);
 8003844:	4630      	mov	r0, r6
 8003846:	f7ff fafb 	bl	8002e40 <chThdSleep>
  while(true) {
 800384a:	e7f1      	b.n	8003830 <main+0x7c0>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 800384c:	481c      	ldr	r0, [pc, #112]	; (80038c0 <main+0x850>)
 800384e:	f7fc ff9f 	bl	8000790 <chSysHalt>
 8003852:	481c      	ldr	r0, [pc, #112]	; (80038c4 <main+0x854>)
 8003854:	f7fc ff9c 	bl	8000790 <chSysHalt>
 8003858:	2000180c 	.word	0x2000180c
 800385c:	08004d10 	.word	0x08004d10
 8003860:	20000904 	.word	0x20000904
 8003864:	08005500 	.word	0x08005500
 8003868:	08001641 	.word	0x08001641
 800386c:	080053cc 	.word	0x080053cc
 8003870:	080053d4 	.word	0x080053d4
 8003874:	200018c0 	.word	0x200018c0
 8003878:	40020800 	.word	0x40020800
 800387c:	40023800 	.word	0x40023800
 8003880:	e000e100 	.word	0xe000e100
 8003884:	40011000 	.word	0x40011000
 8003888:	20000808 	.word	0x20000808
 800388c:	0280de80 	.word	0x0280de80
 8003890:	40020400 	.word	0x40020400
 8003894:	08003c31 	.word	0x08003c31
 8003898:	20002300 	.word	0x20002300
 800389c:	08002e91 	.word	0x08002e91
 80038a0:	20001968 	.word	0x20001968
 80038a4:	000249f0 	.word	0x000249f0
 80038a8:	08004d24 	.word	0x08004d24
 80038ac:	08004d30 	.word	0x08004d30
 80038b0:	08004d3c 	.word	0x08004d3c
 80038b4:	08004d48 	.word	0x08004d48
 80038b8:	08004d54 	.word	0x08004d54
 80038bc:	08004d60 	.word	0x08004d60
 80038c0:	08004f18 	.word	0x08004f18
 80038c4:	080050b0 	.word	0x080050b0
 80038c8:	08000b11 	.word	0x08000b11
 80038cc:	08000341 	.word	0x08000341
 80038d0:	08001831 	.word	0x08001831
 80038d4:	08004d18 	.word	0x08004d18
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
 80038d8:	484e      	ldr	r0, [pc, #312]	; (8003a14 <main+0x9a4>)
 80038da:	f7fc ff59 	bl	8000790 <chSysHalt>
 80038de:	484e      	ldr	r0, [pc, #312]	; (8003a18 <main+0x9a8>)
 80038e0:	f7fc ff56 	bl	8000790 <chSysHalt>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 80038e4:	484d      	ldr	r0, [pc, #308]	; (8003a1c <main+0x9ac>)
 80038e6:	f7fc ff53 	bl	8000790 <chSysHalt>
      rccEnableOTG_FS(true);
 80038ea:	4b4d      	ldr	r3, [pc, #308]	; (8003a20 <main+0x9b0>)
  stm32_otg_t *otgp = usbp->otg;
 80038ec:	f8d7 806c 	ldr.w	r8, [r7, #108]	; 0x6c
      rccEnableOTG_FS(true);
 80038f0:	6b59      	ldr	r1, [r3, #52]	; 0x34
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80038f2:	4a4c      	ldr	r2, [pc, #304]	; (8003a24 <main+0x9b4>)
 80038f4:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 80038f8:	6359      	str	r1, [r3, #52]	; 0x34
 80038fa:	6d59      	ldr	r1, [r3, #84]	; 0x54
 80038fc:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8003900:	6559      	str	r1, [r3, #84]	; 0x54
 8003902:	6d59      	ldr	r1, [r3, #84]	; 0x54
      rccResetOTG_FS();
 8003904:	6959      	ldr	r1, [r3, #20]
 8003906:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 800390a:	6159      	str	r1, [r3, #20]
 800390c:	6959      	ldr	r1, [r3, #20]
 800390e:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 8003912:	6159      	str	r1, [r3, #20]
 8003914:	695b      	ldr	r3, [r3, #20]
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8003916:	4944      	ldr	r1, [pc, #272]	; (8003a28 <main+0x9b8>)
 8003918:	23e0      	movs	r3, #224	; 0xe0
 800391a:	f882 3343 	strb.w	r3, [r2, #835]	; 0x343
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800391e:	2308      	movs	r3, #8
 8003920:	f8c2 3188 	str.w	r3, [r2, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8003924:	6093      	str	r3, [r2, #8]
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8003926:	4b41      	ldr	r3, [pc, #260]	; (8003a2c <main+0x9bc>)
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8003928:	f8c8 100c 	str.w	r1, [r8, #12]
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 800392c:	22c0      	movs	r2, #192	; 0xc0
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 800392e:	f8c8 3800 	str.w	r3, [r8, #2048]	; 0x800
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8003932:	f44f 2350 	mov.w	r3, #851968	; 0xd0000
    otgp->PCGCCTL = 0;
 8003936:	f8c8 9e00 	str.w	r9, [r8, #3584]	; 0xe00
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 800393a:	f8c8 2000 	str.w	r2, [r8]
    otgp->GCCFG = GCCFG_INIT_VALUE;
 800393e:	f8c8 3038 	str.w	r3, [r8, #56]	; 0x38
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8003942:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8003946:	2b00      	cmp	r3, #0
 8003948:	dafb      	bge.n	8003942 <main+0x8d2>
  otgp->GRSTCTL = GRSTCTL_CSRST;
 800394a:	2301      	movs	r3, #1
 800394c:	f8c8 3010 	str.w	r3, [r8, #16]
  chSysPolledDelayX(cycles);
 8003950:	200c      	movs	r0, #12
 8003952:	f7fc ff0d 	bl	8000770 <chSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 8003956:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800395a:	f013 0901 	ands.w	r9, r3, #1
 800395e:	d1fa      	bne.n	8003956 <main+0x8e6>
 8003960:	2012      	movs	r0, #18
 8003962:	f7fc ff05 	bl	8000770 <chSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8003966:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800396a:	2b00      	cmp	r3, #0
 800396c:	dafb      	bge.n	8003966 <main+0x8f6>
    otg_disable_ep(usbp);
 800396e:	e9d7 131b 	ldrd	r1, r3, [r7, #108]	; 0x6c
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003972:	f8d3 e008 	ldr.w	lr, [r3, #8]
    otgp->GAHBCFG = 0;
 8003976:	2300      	movs	r3, #0
 8003978:	f8c8 3008 	str.w	r3, [r8, #8]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800397c:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 8003980:	eb01 1349 	add.w	r3, r1, r9, lsl #5
 8003984:	ea4f 1249 	mov.w	r2, r9, lsl #5
 8003988:	f8d3 0900 	ldr.w	r0, [r3, #2304]	; 0x900
 800398c:	2800      	cmp	r0, #0
 800398e:	da05      	bge.n	800399c <main+0x92c>
      otgp->ie[i].DIEPCTL |= DIEPCTL_EPDIS;
 8003990:	f8d3 0900 	ldr.w	r0, [r3, #2304]	; 0x900
 8003994:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
 8003998:	f8c3 0900 	str.w	r0, [r3, #2304]	; 0x900
    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
 800399c:	f8d3 0b00 	ldr.w	r0, [r3, #2816]	; 0xb00
 80039a0:	2800      	cmp	r0, #0
 80039a2:	da05      	bge.n	80039b0 <main+0x940>
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
 80039a4:	f8d3 0b00 	ldr.w	r0, [r3, #2816]	; 0xb00
 80039a8:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
 80039ac:	f8c3 0b00 	str.w	r0, [r3, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80039b0:	188b      	adds	r3, r1, r2
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80039b2:	f109 0901 	add.w	r9, r9, #1
 80039b6:	45f1      	cmp	r9, lr
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80039b8:	f8c3 c908 	str.w	ip, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80039bc:	f8c3 cb08 	str.w	ip, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80039c0:	d9de      	bls.n	8003980 <main+0x910>
    if (usbp->config->sof_cb == NULL)
 80039c2:	687b      	ldr	r3, [r7, #4]
 80039c4:	68da      	ldr	r2, [r3, #12]
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80039c6:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 80039ca:	f8c1 381c 	str.w	r3, [r1, #2076]	; 0x81c
    otgp->DIEPMSK  = 0;
 80039ce:	2300      	movs	r3, #0
 80039d0:	f8c8 3810 	str.w	r3, [r8, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 80039d4:	f8c8 3814 	str.w	r3, [r8, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 80039d8:	f8c8 381c 	str.w	r3, [r8, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 80039dc:	b1aa      	cbz	r2, 8003a0a <main+0x99a>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 80039de:	4b14      	ldr	r3, [pc, #80]	; (8003a30 <main+0x9c0>)
 80039e0:	f8c8 3018 	str.w	r3, [r8, #24]
    otgp->GINTSTS  = 0xFFFFFFFF;
 80039e4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80039e8:	f8c8 3014 	str.w	r3, [r8, #20]
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 80039ec:	f8d8 3008 	ldr.w	r3, [r8, #8]
 80039f0:	f043 0301 	orr.w	r3, r3, #1
 80039f4:	f8c8 3008 	str.w	r3, [r8, #8]
 80039f8:	e642      	b.n	8003680 <main+0x610>
    fck = STM32_PCLK2 / config->speed;
 80039fa:	4b0e      	ldr	r3, [pc, #56]	; (8003a34 <main+0x9c4>)
 80039fc:	6808      	ldr	r0, [r1, #0]
 80039fe:	fbb3 f3f0 	udiv	r3, r3, r0
 8003a02:	e690      	b.n	8003726 <main+0x6b6>
 8003a04:	480c      	ldr	r0, [pc, #48]	; (8003a38 <main+0x9c8>)
 8003a06:	f7fc fec3 	bl	8000790 <chSysHalt>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8003a0a:	4b0c      	ldr	r3, [pc, #48]	; (8003a3c <main+0x9cc>)
 8003a0c:	f8c8 3018 	str.w	r3, [r8, #24]
 8003a10:	e7e8      	b.n	80039e4 <main+0x974>
 8003a12:	bf00      	nop
 8003a14:	08004e74 	.word	0x08004e74
 8003a18:	08005048 	.word	0x08005048
 8003a1c:	08004e3c 	.word	0x08004e3c
 8003a20:	40023800 	.word	0x40023800
 8003a24:	e000e100 	.word	0xe000e100
 8003a28:	40001440 	.word	0x40001440
 8003a2c:	02200003 	.word	0x02200003
 8003a30:	c0303c08 	.word	0xc0303c08
 8003a34:	0501bd00 	.word	0x0501bd00
 8003a38:	0800503c 	.word	0x0800503c
 8003a3c:	c0303c00 	.word	0xc0303c00

08003a40 <_writet.lto_priv.0>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8003a40:	3030      	adds	r0, #48	; 0x30
 8003a42:	f7ff ba6d 	b.w	8002f20 <oqWriteTimeout>
 8003a46:	bf00      	nop
	...

08003a50 <_write.lto_priv.0>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8003a50:	3030      	adds	r0, #48	; 0x30
 8003a52:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003a56:	f7ff ba63 	b.w	8002f20 <oqWriteTimeout>
 8003a5a:	bf00      	nop
 8003a5c:	0000      	movs	r0, r0
	...

08003a60 <oqPutTimeout>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8003a60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003a62:	4605      	mov	r5, r0
 8003a64:	460f      	mov	r7, r1
 8003a66:	4616      	mov	r6, r2
 8003a68:	2320      	movs	r3, #32
 8003a6a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003a6e:	f7fe ff37 	bl	80028e0 <_dbg_check_lock>
 8003a72:	e005      	b.n	8003a80 <oqPutTimeout+0x20>
  return chThdEnqueueTimeoutS(tqp, timeout);
 8003a74:	4631      	mov	r1, r6
 8003a76:	4628      	mov	r0, r5
 8003a78:	f7fe f8ca 	bl	8001c10 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8003a7c:	1e04      	subs	r4, r0, #0
 8003a7e:	db24      	blt.n	8003aca <oqPutTimeout+0x6a>
  while (oqIsFullI(oqp)) {
 8003a80:	68ab      	ldr	r3, [r5, #8]
 8003a82:	2b00      	cmp	r3, #0
 8003a84:	d0f6      	beq.n	8003a74 <oqPutTimeout+0x14>
  *oqp->q_wrptr++ = b;
 8003a86:	696a      	ldr	r2, [r5, #20]
  oqp->q_counter--;
 8003a88:	68ab      	ldr	r3, [r5, #8]
  *oqp->q_wrptr++ = b;
 8003a8a:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
 8003a8c:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8003a8e:	6169      	str	r1, [r5, #20]
  oqp->q_counter--;
 8003a90:	60ab      	str	r3, [r5, #8]
  *oqp->q_wrptr++ = b;
 8003a92:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8003a94:	e9d5 3204 	ldrd	r3, r2, [r5, #16]
 8003a98:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8003a9a:	bf24      	itt	cs
 8003a9c:	68eb      	ldrcs	r3, [r5, #12]
 8003a9e:	616b      	strcs	r3, [r5, #20]
  if (oqp->q_notify != NULL) {
 8003aa0:	69eb      	ldr	r3, [r5, #28]
 8003aa2:	b10b      	cbz	r3, 8003aa8 <oqPutTimeout+0x48>
    oqp->q_notify(oqp);
 8003aa4:	4628      	mov	r0, r5
 8003aa6:	4798      	blx	r3
  _dbg_check_unlock();
 8003aa8:	f7fe fef2 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003aac:	4b10      	ldr	r3, [pc, #64]	; (8003af0 <oqPutTimeout+0x90>)
 8003aae:	681a      	ldr	r2, [r3, #0]
 8003ab0:	429a      	cmp	r2, r3
 8003ab2:	d004      	beq.n	8003abe <oqPutTimeout+0x5e>
 8003ab4:	6999      	ldr	r1, [r3, #24]
 8003ab6:	6893      	ldr	r3, [r2, #8]
 8003ab8:	688a      	ldr	r2, [r1, #8]
 8003aba:	429a      	cmp	r2, r3
 8003abc:	d315      	bcc.n	8003aea <oqPutTimeout+0x8a>
 8003abe:	2000      	movs	r0, #0
 8003ac0:	f380 8811 	msr	BASEPRI, r0
 8003ac4:	4604      	mov	r4, r0
}
 8003ac6:	4620      	mov	r0, r4
 8003ac8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  _dbg_check_unlock();
 8003aca:	f7fe fee1 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003ace:	4b08      	ldr	r3, [pc, #32]	; (8003af0 <oqPutTimeout+0x90>)
 8003ad0:	681a      	ldr	r2, [r3, #0]
 8003ad2:	429a      	cmp	r2, r3
 8003ad4:	d004      	beq.n	8003ae0 <oqPutTimeout+0x80>
 8003ad6:	6999      	ldr	r1, [r3, #24]
 8003ad8:	6893      	ldr	r3, [r2, #8]
 8003ada:	688a      	ldr	r2, [r1, #8]
 8003adc:	429a      	cmp	r2, r3
 8003ade:	d304      	bcc.n	8003aea <oqPutTimeout+0x8a>
 8003ae0:	2300      	movs	r3, #0
 8003ae2:	f383 8811 	msr	BASEPRI, r3
 8003ae6:	4620      	mov	r0, r4
 8003ae8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003aea:	4802      	ldr	r0, [pc, #8]	; (8003af4 <oqPutTimeout+0x94>)
 8003aec:	f7fc fe50 	bl	8000790 <chSysHalt>
 8003af0:	20000e84 	.word	0x20000e84
 8003af4:	080050a4 	.word	0x080050a4
	...

08003b00 <_putt.lto_priv.0>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8003b00:	3030      	adds	r0, #48	; 0x30
 8003b02:	f7ff bfad 	b.w	8003a60 <oqPutTimeout>
 8003b06:	bf00      	nop
	...

08003b10 <_put.lto_priv.0>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8003b10:	3030      	adds	r0, #48	; 0x30
 8003b12:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003b16:	f7ff bfa3 	b.w	8003a60 <oqPutTimeout>
 8003b1a:	bf00      	nop
 8003b1c:	0000      	movs	r0, r0
	...

08003b20 <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
 8003b20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003b24:	b085      	sub	sp, #20
  osalDbgCheck(n > 0U);
 8003b26:	2a00      	cmp	r2, #0
 8003b28:	d06e      	beq.n	8003c08 <iqReadTimeout+0xe8>
 8003b2a:	4604      	mov	r4, r0
 8003b2c:	460d      	mov	r5, r1
 8003b2e:	4698      	mov	r8, r3
 8003b30:	4616      	mov	r6, r2
  qnotify_t nfy = iqp->q_notify;
 8003b32:	f8d0 a01c 	ldr.w	sl, [r0, #28]
 8003b36:	2720      	movs	r7, #32
 8003b38:	f387 8811 	msr	BASEPRI, r7
  _dbg_check_lock();
 8003b3c:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 8003c2c <iqReadTimeout+0x10c>
 8003b40:	f7fe fece 	bl	80028e0 <_dbg_check_lock>
 8003b44:	9701      	str	r7, [sp, #4]
 8003b46:	9602      	str	r6, [sp, #8]
 8003b48:	4637      	mov	r7, r6
  if (n > iqGetFullI(iqp)) {
 8003b4a:	68a3      	ldr	r3, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8003b4c:	69a1      	ldr	r1, [r4, #24]
 8003b4e:	6922      	ldr	r2, [r4, #16]
  if (n > iqGetFullI(iqp)) {
 8003b50:	42bb      	cmp	r3, r7
    n = iqGetFullI(iqp);
 8003b52:	bf34      	ite	cc
 8003b54:	68a6      	ldrcc	r6, [r4, #8]
  if (n > iqGetFullI(iqp)) {
 8003b56:	463e      	movcs	r6, r7
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8003b58:	1a52      	subs	r2, r2, r1
  if (n < s1) {
 8003b5a:	42b2      	cmp	r2, r6
 8003b5c:	d857      	bhi.n	8003c0e <iqReadTimeout+0xee>
  else if (n > s1) {
 8003b5e:	d323      	bcc.n	8003ba8 <iqReadTimeout+0x88>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8003b60:	4632      	mov	r2, r6
 8003b62:	4628      	mov	r0, r5
 8003b64:	f7fc fc00 	bl	8000368 <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 8003b68:	68e2      	ldr	r2, [r4, #12]
 8003b6a:	61a2      	str	r2, [r4, #24]
  iqp->q_counter -= n;
 8003b6c:	68a2      	ldr	r2, [r4, #8]
 8003b6e:	1b92      	subs	r2, r2, r6
 8003b70:	60a2      	str	r2, [r4, #8]
    if (done == (size_t)0) {
 8003b72:	bb5e      	cbnz	r6, 8003bcc <iqReadTimeout+0xac>
 8003b74:	4641      	mov	r1, r8
 8003b76:	4620      	mov	r0, r4
 8003b78:	f7fe f84a 	bl	8001c10 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8003b7c:	2800      	cmp	r0, #0
 8003b7e:	d0e4      	beq.n	8003b4a <iqReadTimeout+0x2a>
 8003b80:	9e02      	ldr	r6, [sp, #8]
  _dbg_check_unlock();
 8003b82:	f7fe fe85 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003b86:	f8d9 3000 	ldr.w	r3, [r9]
 8003b8a:	454b      	cmp	r3, r9
 8003b8c:	d005      	beq.n	8003b9a <iqReadTimeout+0x7a>
 8003b8e:	f8d9 2018 	ldr.w	r2, [r9, #24]
 8003b92:	689b      	ldr	r3, [r3, #8]
 8003b94:	6892      	ldr	r2, [r2, #8]
 8003b96:	429a      	cmp	r2, r3
 8003b98:	d341      	bcc.n	8003c1e <iqReadTimeout+0xfe>
 8003b9a:	2300      	movs	r3, #0
 8003b9c:	f383 8811 	msr	BASEPRI, r3
}
 8003ba0:	1bf0      	subs	r0, r6, r7
 8003ba2:	b005      	add	sp, #20
 8003ba4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8003ba8:	4628      	mov	r0, r5
    s2 = n - s1;
 8003baa:	eba6 0b02 	sub.w	fp, r6, r2
 8003bae:	9203      	str	r2, [sp, #12]
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8003bb0:	f7fc fbda 	bl	8000368 <memcpy>
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8003bb4:	9a03      	ldr	r2, [sp, #12]
 8003bb6:	68e1      	ldr	r1, [r4, #12]
 8003bb8:	18a8      	adds	r0, r5, r2
 8003bba:	465a      	mov	r2, fp
 8003bbc:	f7fc fbd4 	bl	8000368 <memcpy>
  iqp->q_counter -= n;
 8003bc0:	68a2      	ldr	r2, [r4, #8]
    iqp->q_rdptr = iqp->q_buffer + s2;
 8003bc2:	68e1      	ldr	r1, [r4, #12]
  iqp->q_counter -= n;
 8003bc4:	1b92      	subs	r2, r2, r6
    iqp->q_rdptr = iqp->q_buffer + s2;
 8003bc6:	4459      	add	r1, fp
 8003bc8:	61a1      	str	r1, [r4, #24]
  iqp->q_counter -= n;
 8003bca:	60a2      	str	r2, [r4, #8]
      if (nfy != NULL) {
 8003bcc:	f1ba 0f00 	cmp.w	sl, #0
 8003bd0:	d001      	beq.n	8003bd6 <iqReadTimeout+0xb6>
        nfy(iqp);
 8003bd2:	4620      	mov	r0, r4
 8003bd4:	47d0      	blx	sl
  _dbg_check_unlock();
 8003bd6:	f7fe fe5b 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003bda:	f8d9 2000 	ldr.w	r2, [r9]
 8003bde:	454a      	cmp	r2, r9
 8003be0:	d005      	beq.n	8003bee <iqReadTimeout+0xce>
 8003be2:	f8d9 1018 	ldr.w	r1, [r9, #24]
 8003be6:	6892      	ldr	r2, [r2, #8]
 8003be8:	6889      	ldr	r1, [r1, #8]
 8003bea:	4291      	cmp	r1, r2
 8003bec:	d317      	bcc.n	8003c1e <iqReadTimeout+0xfe>
 8003bee:	2300      	movs	r3, #0
 8003bf0:	f383 8811 	msr	BASEPRI, r3
 8003bf4:	9b01      	ldr	r3, [sp, #4]
      n  -= done;
 8003bf6:	1bbf      	subs	r7, r7, r6
      bp += done;
 8003bf8:	4435      	add	r5, r6
 8003bfa:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003bfe:	f7fe fe6f 	bl	80028e0 <_dbg_check_lock>
  while (n > 0U) {
 8003c02:	2f00      	cmp	r7, #0
 8003c04:	d1a1      	bne.n	8003b4a <iqReadTimeout+0x2a>
 8003c06:	e7bb      	b.n	8003b80 <iqReadTimeout+0x60>
  osalDbgCheck(n > 0U);
 8003c08:	4806      	ldr	r0, [pc, #24]	; (8003c24 <iqReadTimeout+0x104>)
 8003c0a:	f7fc fdc1 	bl	8000790 <chSysHalt>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8003c0e:	4632      	mov	r2, r6
 8003c10:	4628      	mov	r0, r5
 8003c12:	f7fc fba9 	bl	8000368 <memcpy>
    iqp->q_rdptr += n;
 8003c16:	69a2      	ldr	r2, [r4, #24]
 8003c18:	4432      	add	r2, r6
 8003c1a:	61a2      	str	r2, [r4, #24]
 8003c1c:	e7a6      	b.n	8003b6c <iqReadTimeout+0x4c>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003c1e:	4802      	ldr	r0, [pc, #8]	; (8003c28 <iqReadTimeout+0x108>)
 8003c20:	f7fc fdb6 	bl	8000790 <chSysHalt>
 8003c24:	08004f24 	.word	0x08004f24
 8003c28:	080050a4 	.word	0x080050a4
 8003c2c:	20000e84 	.word	0x20000e84

08003c30 <rx_thread>:
static THD_FUNCTION(rx_thread, arg) {
 8003c30:	b500      	push	{lr}
 8003c32:	4e0a      	ldr	r6, [pc, #40]	; (8003c5c <rx_thread+0x2c>)
    if (sdReadTimeout(&SD4, &c, 1, 100)) {
 8003c34:	4d0a      	ldr	r5, [pc, #40]	; (8003c60 <rx_thread+0x30>)
      chprintf(chp,"%c", c);
 8003c36:	4c0b      	ldr	r4, [pc, #44]	; (8003c64 <rx_thread+0x34>)
static THD_FUNCTION(rx_thread, arg) {
 8003c38:	b083      	sub	sp, #12
    if (sdReadTimeout(&SD4, &c, 1, 100)) {
 8003c3a:	f10d 0107 	add.w	r1, sp, #7
 8003c3e:	2364      	movs	r3, #100	; 0x64
 8003c40:	2201      	movs	r2, #1
 8003c42:	4628      	mov	r0, r5
 8003c44:	f7ff ff6c 	bl	8003b20 <iqReadTimeout>
      chprintf(chp,"%c", c);
 8003c48:	4621      	mov	r1, r4
    if (sdReadTimeout(&SD4, &c, 1, 100)) {
 8003c4a:	2800      	cmp	r0, #0
 8003c4c:	d0f5      	beq.n	8003c3a <rx_thread+0xa>
      chprintf(chp,"%c", c);
 8003c4e:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8003c52:	6830      	ldr	r0, [r6, #0]
 8003c54:	f7fe f994 	bl	8001f80 <chprintf>
  while(1) {
 8003c58:	e7ef      	b.n	8003c3a <rx_thread+0xa>
 8003c5a:	bf00      	nop
 8003c5c:	200018c0 	.word	0x200018c0
 8003c60:	20000894 	.word	0x20000894
 8003c64:	08004d70 	.word	0x08004d70
	...

08003c70 <_readt.lto_priv.0>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8003c70:	300c      	adds	r0, #12
 8003c72:	f7ff bf55 	b.w	8003b20 <iqReadTimeout>
 8003c76:	bf00      	nop
	...

08003c80 <_read.lto_priv.0>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8003c80:	300c      	adds	r0, #12
 8003c82:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003c86:	f7ff bf4b 	b.w	8003b20 <iqReadTimeout>
 8003c8a:	bf00      	nop
 8003c8c:	0000      	movs	r0, r0
	...

08003c90 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8003c90:	b570      	push	{r4, r5, r6, lr}
 8003c92:	2320      	movs	r3, #32
 8003c94:	4605      	mov	r5, r0
 8003c96:	460e      	mov	r6, r1
 8003c98:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003c9c:	f7fe fe20 	bl	80028e0 <_dbg_check_lock>
 8003ca0:	e005      	b.n	8003cae <iqGetTimeout+0x1e>
 8003ca2:	4631      	mov	r1, r6
 8003ca4:	4628      	mov	r0, r5
 8003ca6:	f7fd ffb3 	bl	8001c10 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8003caa:	1e04      	subs	r4, r0, #0
 8003cac:	db13      	blt.n	8003cd6 <iqGetTimeout+0x46>
  while (iqIsEmptyI(iqp)) {
 8003cae:	68ab      	ldr	r3, [r5, #8]
 8003cb0:	2b00      	cmp	r3, #0
 8003cb2:	d0f6      	beq.n	8003ca2 <iqGetTimeout+0x12>
  b = *iqp->q_rdptr++;
 8003cb4:	69a9      	ldr	r1, [r5, #24]
  iqp->q_counter--;
 8003cb6:	68ab      	ldr	r3, [r5, #8]
  if (iqp->q_rdptr >= iqp->q_top) {
 8003cb8:	6928      	ldr	r0, [r5, #16]
  b = *iqp->q_rdptr++;
 8003cba:	1c4a      	adds	r2, r1, #1
  iqp->q_counter--;
 8003cbc:	3b01      	subs	r3, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 8003cbe:	4282      	cmp	r2, r0
  iqp->q_counter--;
 8003cc0:	60ab      	str	r3, [r5, #8]
  b = *iqp->q_rdptr++;
 8003cc2:	61aa      	str	r2, [r5, #24]
    iqp->q_rdptr = iqp->q_buffer;
 8003cc4:	bf28      	it	cs
 8003cc6:	68eb      	ldrcs	r3, [r5, #12]
  b = *iqp->q_rdptr++;
 8003cc8:	780c      	ldrb	r4, [r1, #0]
    iqp->q_rdptr = iqp->q_buffer;
 8003cca:	bf28      	it	cs
 8003ccc:	61ab      	strcs	r3, [r5, #24]
  if (iqp->q_notify != NULL) {
 8003cce:	69eb      	ldr	r3, [r5, #28]
 8003cd0:	b10b      	cbz	r3, 8003cd6 <iqGetTimeout+0x46>
    iqp->q_notify(iqp);
 8003cd2:	4628      	mov	r0, r5
 8003cd4:	4798      	blx	r3
  _dbg_check_unlock();
 8003cd6:	f7fe fddb 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003cda:	4b08      	ldr	r3, [pc, #32]	; (8003cfc <iqGetTimeout+0x6c>)
 8003cdc:	681a      	ldr	r2, [r3, #0]
 8003cde:	429a      	cmp	r2, r3
 8003ce0:	d004      	beq.n	8003cec <iqGetTimeout+0x5c>
 8003ce2:	6999      	ldr	r1, [r3, #24]
 8003ce4:	6893      	ldr	r3, [r2, #8]
 8003ce6:	688a      	ldr	r2, [r1, #8]
 8003ce8:	429a      	cmp	r2, r3
 8003cea:	d304      	bcc.n	8003cf6 <iqGetTimeout+0x66>
 8003cec:	2300      	movs	r3, #0
 8003cee:	f383 8811 	msr	BASEPRI, r3
}
 8003cf2:	4620      	mov	r0, r4
 8003cf4:	bd70      	pop	{r4, r5, r6, pc}
 8003cf6:	4802      	ldr	r0, [pc, #8]	; (8003d00 <iqGetTimeout+0x70>)
 8003cf8:	f7fc fd4a 	bl	8000790 <chSysHalt>
 8003cfc:	20000e84 	.word	0x20000e84
 8003d00:	080050a4 	.word	0x080050a4
	...

08003d10 <_gett.lto_priv.0>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8003d10:	300c      	adds	r0, #12
 8003d12:	f7ff bfbd 	b.w	8003c90 <iqGetTimeout>
 8003d16:	bf00      	nop
	...

08003d20 <_get.lto_priv.0>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8003d20:	300c      	adds	r0, #12
 8003d22:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8003d26:	f7ff bfb3 	b.w	8003c90 <iqGetTimeout>
 8003d2a:	bf00      	nop
 8003d2c:	0000      	movs	r0, r0
	...

08003d30 <obqWriteTimeout>:
                       size_t n, sysinterval_t timeout) {
 8003d30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003d34:	b083      	sub	sp, #12
  osalDbgCheck(n > 0U);
 8003d36:	2a00      	cmp	r2, #0
 8003d38:	d06f      	beq.n	8003e1a <obqWriteTimeout+0xea>
 8003d3a:	4683      	mov	fp, r0
 8003d3c:	460c      	mov	r4, r1
 8003d3e:	4699      	mov	r9, r3
 8003d40:	4616      	mov	r6, r2
 8003d42:	f04f 0820 	mov.w	r8, #32
 8003d46:	f388 8811 	msr	BASEPRI, r8
  _dbg_check_lock();
 8003d4a:	f7fe fdc9 	bl	80028e0 <_dbg_check_lock>
    if (obqp->ptr == NULL) {
 8003d4e:	f8db 0028 	ldr.w	r0, [fp, #40]	; 0x28
 8003d52:	4f3c      	ldr	r7, [pc, #240]	; (8003e44 <obqWriteTimeout+0x114>)
  size_t w = 0;
 8003d54:	2500      	movs	r5, #0
 8003d56:	46aa      	mov	sl, r5
    if (obqp->ptr == NULL) {
 8003d58:	2800      	cmp	r0, #0
 8003d5a:	d03c      	beq.n	8003dd6 <obqWriteTimeout+0xa6>
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8003d5c:	f8db 302c 	ldr.w	r3, [fp, #44]	; 0x2c
    if (size > (n - w)) {
 8003d60:	1b72      	subs	r2, r6, r5
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8003d62:	1a1b      	subs	r3, r3, r0
    if (size > (n - w)) {
 8003d64:	429a      	cmp	r2, r3
 8003d66:	bf28      	it	cs
 8003d68:	461a      	movcs	r2, r3
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 8003d6a:	2a40      	cmp	r2, #64	; 0x40
 8003d6c:	d93b      	bls.n	8003de6 <obqWriteTimeout+0xb6>
      memcpy(obqp->ptr, bp, (size_t)BUFFERS_CHUNKS_SIZE);
 8003d6e:	4621      	mov	r1, r4
 8003d70:	f104 0e40 	add.w	lr, r4, #64	; 0x40
 8003d74:	680c      	ldr	r4, [r1, #0]
 8003d76:	684a      	ldr	r2, [r1, #4]
 8003d78:	688b      	ldr	r3, [r1, #8]
 8003d7a:	f8d1 c00c 	ldr.w	ip, [r1, #12]
 8003d7e:	f8c0 c00c 	str.w	ip, [r0, #12]
 8003d82:	3110      	adds	r1, #16
 8003d84:	4571      	cmp	r1, lr
 8003d86:	6004      	str	r4, [r0, #0]
 8003d88:	6042      	str	r2, [r0, #4]
 8003d8a:	6083      	str	r3, [r0, #8]
 8003d8c:	f100 0010 	add.w	r0, r0, #16
 8003d90:	d1f0      	bne.n	8003d74 <obqWriteTimeout+0x44>
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8003d92:	f8db 3028 	ldr.w	r3, [fp, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
 8003d96:	f8db 202c 	ldr.w	r2, [fp, #44]	; 0x2c
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8003d9a:	3340      	adds	r3, #64	; 0x40
    if (obqp->ptr >= obqp->top) {
 8003d9c:	429a      	cmp	r2, r3
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
 8003d9e:	460c      	mov	r4, r1
      w         += (size_t)BUFFERS_CHUNKS_SIZE;
 8003da0:	f105 0540 	add.w	r5, r5, #64	; 0x40
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8003da4:	f8cb 3028 	str.w	r3, [fp, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
 8003da8:	d92d      	bls.n	8003e06 <obqWriteTimeout+0xd6>
  _dbg_check_unlock();
 8003daa:	f7fe fd71 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003dae:	683b      	ldr	r3, [r7, #0]
 8003db0:	42bb      	cmp	r3, r7
 8003db2:	d004      	beq.n	8003dbe <obqWriteTimeout+0x8e>
 8003db4:	69ba      	ldr	r2, [r7, #24]
 8003db6:	689b      	ldr	r3, [r3, #8]
 8003db8:	6892      	ldr	r2, [r2, #8]
 8003dba:	429a      	cmp	r2, r3
 8003dbc:	d32a      	bcc.n	8003e14 <obqWriteTimeout+0xe4>
 8003dbe:	f38a 8811 	msr	BASEPRI, sl
    if (w >= n) {
 8003dc2:	42b5      	cmp	r5, r6
 8003dc4:	d239      	bcs.n	8003e3a <obqWriteTimeout+0x10a>
 8003dc6:	f388 8811 	msr	BASEPRI, r8
  _dbg_check_lock();
 8003dca:	f7fe fd89 	bl	80028e0 <_dbg_check_lock>
    if (obqp->ptr == NULL) {
 8003dce:	f8db 0028 	ldr.w	r0, [fp, #40]	; 0x28
 8003dd2:	2800      	cmp	r0, #0
 8003dd4:	d1c2      	bne.n	8003d5c <obqWriteTimeout+0x2c>
      msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8003dd6:	4649      	mov	r1, r9
 8003dd8:	4658      	mov	r0, fp
 8003dda:	f7fd ff31 	bl	8001c40 <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
 8003dde:	b9f8      	cbnz	r0, 8003e20 <obqWriteTimeout+0xf0>
 8003de0:	f8db 0028 	ldr.w	r0, [fp, #40]	; 0x28
 8003de4:	e7ba      	b.n	8003d5c <obqWriteTimeout+0x2c>
      memcpy(obqp->ptr, bp, size);
 8003de6:	4621      	mov	r1, r4
 8003de8:	9201      	str	r2, [sp, #4]
 8003dea:	f7fc fabd 	bl	8000368 <memcpy>
      obqp->ptr += size;
 8003dee:	9a01      	ldr	r2, [sp, #4]
 8003df0:	f8db 3028 	ldr.w	r3, [fp, #40]	; 0x28
      w         += size;
 8003df4:	4415      	add	r5, r2
      obqp->ptr += size;
 8003df6:	4413      	add	r3, r2
      bp        += size;
 8003df8:	4414      	add	r4, r2
    if (obqp->ptr >= obqp->top) {
 8003dfa:	f8db 202c 	ldr.w	r2, [fp, #44]	; 0x2c
      obqp->ptr += size;
 8003dfe:	f8cb 3028 	str.w	r3, [fp, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
 8003e02:	429a      	cmp	r2, r3
 8003e04:	d8d1      	bhi.n	8003daa <obqWriteTimeout+0x7a>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8003e06:	f8db 101c 	ldr.w	r1, [fp, #28]
 8003e0a:	4658      	mov	r0, fp
 8003e0c:	3904      	subs	r1, #4
 8003e0e:	f7fd fc77 	bl	8001700 <obqPostFullBufferS>
 8003e12:	e7ca      	b.n	8003daa <obqWriteTimeout+0x7a>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003e14:	480c      	ldr	r0, [pc, #48]	; (8003e48 <obqWriteTimeout+0x118>)
 8003e16:	f7fc fcbb 	bl	8000790 <chSysHalt>
  osalDbgCheck(n > 0U);
 8003e1a:	480c      	ldr	r0, [pc, #48]	; (8003e4c <obqWriteTimeout+0x11c>)
 8003e1c:	f7fc fcb8 	bl	8000790 <chSysHalt>
  _dbg_check_unlock();
 8003e20:	f7fe fd36 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003e24:	683b      	ldr	r3, [r7, #0]
 8003e26:	42bb      	cmp	r3, r7
 8003e28:	d004      	beq.n	8003e34 <obqWriteTimeout+0x104>
 8003e2a:	69ba      	ldr	r2, [r7, #24]
 8003e2c:	689b      	ldr	r3, [r3, #8]
 8003e2e:	6892      	ldr	r2, [r2, #8]
 8003e30:	429a      	cmp	r2, r3
 8003e32:	d3ef      	bcc.n	8003e14 <obqWriteTimeout+0xe4>
 8003e34:	2300      	movs	r3, #0
 8003e36:	f383 8811 	msr	BASEPRI, r3
}
 8003e3a:	4628      	mov	r0, r5
 8003e3c:	b003      	add	sp, #12
 8003e3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003e42:	bf00      	nop
 8003e44:	20000e84 	.word	0x20000e84
 8003e48:	08005098 	.word	0x08005098
 8003e4c:	08004ffc 	.word	0x08004ffc

08003e50 <_writet.lto_priv.1>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 8003e50:	3044      	adds	r0, #68	; 0x44
 8003e52:	f7ff bf6d 	b.w	8003d30 <obqWriteTimeout>
 8003e56:	bf00      	nop
	...

08003e60 <_write.lto_priv.1>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 8003e60:	3044      	adds	r0, #68	; 0x44
 8003e62:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003e66:	f7ff bf63 	b.w	8003d30 <obqWriteTimeout>
 8003e6a:	bf00      	nop
 8003e6c:	0000      	movs	r0, r0
	...

08003e70 <obqPutTimeout>:
                    sysinterval_t timeout) {
 8003e70:	b570      	push	{r4, r5, r6, lr}
 8003e72:	2320      	movs	r3, #32
 8003e74:	b082      	sub	sp, #8
 8003e76:	4604      	mov	r4, r0
 8003e78:	460d      	mov	r5, r1
 8003e7a:	4616      	mov	r6, r2
 8003e7c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003e80:	f7fe fd2e 	bl	80028e0 <_dbg_check_lock>
  if (obqp->ptr == NULL) {
 8003e84:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003e86:	b1fb      	cbz	r3, 8003ec8 <obqPutTimeout+0x58>
  *obqp->ptr = b;
 8003e88:	701d      	strb	r5, [r3, #0]
  if (obqp->ptr >= obqp->top) {
 8003e8a:	e9d4 320a 	ldrd	r3, r2, [r4, #40]	; 0x28
  obqp->ptr++;
 8003e8e:	3301      	adds	r3, #1
  if (obqp->ptr >= obqp->top) {
 8003e90:	4293      	cmp	r3, r2
  obqp->ptr++;
 8003e92:	62a3      	str	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
 8003e94:	d212      	bcs.n	8003ebc <obqPutTimeout+0x4c>
  _dbg_check_unlock();
 8003e96:	f7fe fcfb 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003e9a:	4b17      	ldr	r3, [pc, #92]	; (8003ef8 <obqPutTimeout+0x88>)
 8003e9c:	681a      	ldr	r2, [r3, #0]
 8003e9e:	429a      	cmp	r2, r3
 8003ea0:	d004      	beq.n	8003eac <obqPutTimeout+0x3c>
 8003ea2:	6999      	ldr	r1, [r3, #24]
 8003ea4:	6893      	ldr	r3, [r2, #8]
 8003ea6:	688a      	ldr	r2, [r1, #8]
 8003ea8:	429a      	cmp	r2, r3
 8003eaa:	d304      	bcc.n	8003eb6 <obqPutTimeout+0x46>
 8003eac:	2000      	movs	r0, #0
 8003eae:	f380 8811 	msr	BASEPRI, r0
}
 8003eb2:	b002      	add	sp, #8
 8003eb4:	bd70      	pop	{r4, r5, r6, pc}
 8003eb6:	4811      	ldr	r0, [pc, #68]	; (8003efc <obqPutTimeout+0x8c>)
 8003eb8:	f7fc fc6a 	bl	8000790 <chSysHalt>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8003ebc:	69e1      	ldr	r1, [r4, #28]
 8003ebe:	4620      	mov	r0, r4
 8003ec0:	3904      	subs	r1, #4
 8003ec2:	f7fd fc1d 	bl	8001700 <obqPostFullBufferS>
 8003ec6:	e7e6      	b.n	8003e96 <obqPutTimeout+0x26>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8003ec8:	4631      	mov	r1, r6
 8003eca:	4620      	mov	r0, r4
 8003ecc:	f7fd feb8 	bl	8001c40 <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 8003ed0:	b908      	cbnz	r0, 8003ed6 <obqPutTimeout+0x66>
 8003ed2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003ed4:	e7d8      	b.n	8003e88 <obqPutTimeout+0x18>
 8003ed6:	9001      	str	r0, [sp, #4]
  _dbg_check_unlock();
 8003ed8:	f7fe fcda 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003edc:	4b06      	ldr	r3, [pc, #24]	; (8003ef8 <obqPutTimeout+0x88>)
 8003ede:	9801      	ldr	r0, [sp, #4]
 8003ee0:	681a      	ldr	r2, [r3, #0]
 8003ee2:	429a      	cmp	r2, r3
 8003ee4:	d004      	beq.n	8003ef0 <obqPutTimeout+0x80>
 8003ee6:	6999      	ldr	r1, [r3, #24]
 8003ee8:	6893      	ldr	r3, [r2, #8]
 8003eea:	688a      	ldr	r2, [r1, #8]
 8003eec:	429a      	cmp	r2, r3
 8003eee:	d3e2      	bcc.n	8003eb6 <obqPutTimeout+0x46>
 8003ef0:	2300      	movs	r3, #0
 8003ef2:	f383 8811 	msr	BASEPRI, r3
 8003ef6:	e7dc      	b.n	8003eb2 <obqPutTimeout+0x42>
 8003ef8:	20000e84 	.word	0x20000e84
 8003efc:	08005098 	.word	0x08005098

08003f00 <_putt.lto_priv.1>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 8003f00:	3044      	adds	r0, #68	; 0x44
 8003f02:	f7ff bfb5 	b.w	8003e70 <obqPutTimeout>
 8003f06:	bf00      	nop
	...

08003f10 <_put.lto_priv.1>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 8003f10:	3044      	adds	r0, #68	; 0x44
 8003f12:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003f16:	f7ff bfab 	b.w	8003e70 <obqPutTimeout>
 8003f1a:	bf00      	nop
 8003f1c:	0000      	movs	r0, r0
	...

08003f20 <ibqReadTimeout>:
                      size_t n, sysinterval_t timeout) {
 8003f20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003f24:	b083      	sub	sp, #12
 8003f26:	9301      	str	r3, [sp, #4]
  osalDbgCheck(n > 0U);
 8003f28:	2a00      	cmp	r2, #0
 8003f2a:	d06e      	beq.n	800400a <ibqReadTimeout+0xea>
 8003f2c:	4683      	mov	fp, r0
 8003f2e:	460e      	mov	r6, r1
 8003f30:	4617      	mov	r7, r2
 8003f32:	f04f 0920 	mov.w	r9, #32
 8003f36:	f389 8811 	msr	BASEPRI, r9
  _dbg_check_lock();
 8003f3a:	f7fe fcd1 	bl	80028e0 <_dbg_check_lock>
    if (ibqp->ptr == NULL) {
 8003f3e:	f8db 1028 	ldr.w	r1, [fp, #40]	; 0x28
 8003f42:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 8004040 <ibqReadTimeout+0x120>
  size_t r = 0;
 8003f46:	2500      	movs	r5, #0
 8003f48:	46aa      	mov	sl, r5
    if (ibqp->ptr == NULL) {
 8003f4a:	2900      	cmp	r1, #0
 8003f4c:	d03f      	beq.n	8003fce <ibqReadTimeout+0xae>
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8003f4e:	f8db 302c 	ldr.w	r3, [fp, #44]	; 0x2c
    if (size > (n - r)) {
 8003f52:	1b7c      	subs	r4, r7, r5
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8003f54:	1a5a      	subs	r2, r3, r1
    if (size > (n - r)) {
 8003f56:	4294      	cmp	r4, r2
 8003f58:	bf28      	it	cs
 8003f5a:	4614      	movcs	r4, r2
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 8003f5c:	2c40      	cmp	r4, #64	; 0x40
 8003f5e:	d93e      	bls.n	8003fde <ibqReadTimeout+0xbe>
      memcpy(bp, ibqp->ptr, BUFFERS_CHUNKS_SIZE);
 8003f60:	f101 0e40 	add.w	lr, r1, #64	; 0x40
 8003f64:	4633      	mov	r3, r6
 8003f66:	680c      	ldr	r4, [r1, #0]
 8003f68:	6848      	ldr	r0, [r1, #4]
 8003f6a:	688a      	ldr	r2, [r1, #8]
 8003f6c:	f8d1 c00c 	ldr.w	ip, [r1, #12]
 8003f70:	f8c3 c00c 	str.w	ip, [r3, #12]
 8003f74:	3110      	adds	r1, #16
 8003f76:	4571      	cmp	r1, lr
 8003f78:	601c      	str	r4, [r3, #0]
 8003f7a:	6058      	str	r0, [r3, #4]
 8003f7c:	609a      	str	r2, [r3, #8]
 8003f7e:	f103 0310 	add.w	r3, r3, #16
 8003f82:	d1f0      	bne.n	8003f66 <ibqReadTimeout+0x46>
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8003f84:	f8db 3028 	ldr.w	r3, [fp, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
 8003f88:	f8db 202c 	ldr.w	r2, [fp, #44]	; 0x2c
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8003f8c:	3340      	adds	r3, #64	; 0x40
    if (ibqp->ptr >= ibqp->top) {
 8003f8e:	429a      	cmp	r2, r3
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
 8003f90:	f106 0640 	add.w	r6, r6, #64	; 0x40
      r         += (size_t)BUFFERS_CHUNKS_SIZE;
 8003f94:	f105 0540 	add.w	r5, r5, #64	; 0x40
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8003f98:	f8cb 3028 	str.w	r3, [fp, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
 8003f9c:	d92e      	bls.n	8003ffc <ibqReadTimeout+0xdc>
  _dbg_check_unlock();
 8003f9e:	f7fe fc77 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003fa2:	f8d8 3000 	ldr.w	r3, [r8]
 8003fa6:	4543      	cmp	r3, r8
 8003fa8:	d005      	beq.n	8003fb6 <ibqReadTimeout+0x96>
 8003faa:	f8d8 2018 	ldr.w	r2, [r8, #24]
 8003fae:	689b      	ldr	r3, [r3, #8]
 8003fb0:	6892      	ldr	r2, [r2, #8]
 8003fb2:	429a      	cmp	r2, r3
 8003fb4:	d326      	bcc.n	8004004 <ibqReadTimeout+0xe4>
 8003fb6:	f38a 8811 	msr	BASEPRI, sl
    if (r >= n) {
 8003fba:	42bd      	cmp	r5, r7
 8003fbc:	d237      	bcs.n	800402e <ibqReadTimeout+0x10e>
 8003fbe:	f389 8811 	msr	BASEPRI, r9
  _dbg_check_lock();
 8003fc2:	f7fe fc8d 	bl	80028e0 <_dbg_check_lock>
    if (ibqp->ptr == NULL) {
 8003fc6:	f8db 1028 	ldr.w	r1, [fp, #40]	; 0x28
 8003fca:	2900      	cmp	r1, #0
 8003fcc:	d1bf      	bne.n	8003f4e <ibqReadTimeout+0x2e>
      msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8003fce:	9901      	ldr	r1, [sp, #4]
 8003fd0:	4658      	mov	r0, fp
 8003fd2:	f7fd fe5d 	bl	8001c90 <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
 8003fd6:	b9d8      	cbnz	r0, 8004010 <ibqReadTimeout+0xf0>
 8003fd8:	f8db 1028 	ldr.w	r1, [fp, #40]	; 0x28
 8003fdc:	e7b7      	b.n	8003f4e <ibqReadTimeout+0x2e>
      memcpy(bp, ibqp->ptr, size);
 8003fde:	4622      	mov	r2, r4
 8003fe0:	4630      	mov	r0, r6
 8003fe2:	f7fc f9c1 	bl	8000368 <memcpy>
      ibqp->ptr += size;
 8003fe6:	f8db 3028 	ldr.w	r3, [fp, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
 8003fea:	f8db 202c 	ldr.w	r2, [fp, #44]	; 0x2c
      ibqp->ptr += size;
 8003fee:	4423      	add	r3, r4
    if (ibqp->ptr >= ibqp->top) {
 8003ff0:	429a      	cmp	r2, r3
      r         += size;
 8003ff2:	4425      	add	r5, r4
      bp        += size;
 8003ff4:	4426      	add	r6, r4
      ibqp->ptr += size;
 8003ff6:	f8cb 3028 	str.w	r3, [fp, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
 8003ffa:	d8d0      	bhi.n	8003f9e <ibqReadTimeout+0x7e>
      ibqReleaseEmptyBufferS(ibqp);
 8003ffc:	4658      	mov	r0, fp
 8003ffe:	f7fd fc9f 	bl	8001940 <ibqReleaseEmptyBufferS>
 8004002:	e7cc      	b.n	8003f9e <ibqReadTimeout+0x7e>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004004:	480c      	ldr	r0, [pc, #48]	; (8004038 <ibqReadTimeout+0x118>)
 8004006:	f7fc fbc3 	bl	8000790 <chSysHalt>
  osalDbgCheck(n > 0U);
 800400a:	480c      	ldr	r0, [pc, #48]	; (800403c <ibqReadTimeout+0x11c>)
 800400c:	f7fc fbc0 	bl	8000790 <chSysHalt>
  _dbg_check_unlock();
 8004010:	f7fe fc3e 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004014:	f8d8 3000 	ldr.w	r3, [r8]
 8004018:	4543      	cmp	r3, r8
 800401a:	d005      	beq.n	8004028 <ibqReadTimeout+0x108>
 800401c:	f8d8 2018 	ldr.w	r2, [r8, #24]
 8004020:	689b      	ldr	r3, [r3, #8]
 8004022:	6892      	ldr	r2, [r2, #8]
 8004024:	429a      	cmp	r2, r3
 8004026:	d3ed      	bcc.n	8004004 <ibqReadTimeout+0xe4>
 8004028:	2300      	movs	r3, #0
 800402a:	f383 8811 	msr	BASEPRI, r3
}
 800402e:	4628      	mov	r0, r5
 8004030:	b003      	add	sp, #12
 8004032:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004036:	bf00      	nop
 8004038:	08005098 	.word	0x08005098
 800403c:	08004ef8 	.word	0x08004ef8
 8004040:	20000e84 	.word	0x20000e84
	...

08004050 <_readt.lto_priv.1>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 8004050:	300c      	adds	r0, #12
 8004052:	f7ff bf65 	b.w	8003f20 <ibqReadTimeout>
 8004056:	bf00      	nop
	...

08004060 <_read.lto_priv.1>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 8004060:	300c      	adds	r0, #12
 8004062:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004066:	f7ff bf5b 	b.w	8003f20 <ibqReadTimeout>
 800406a:	bf00      	nop
 800406c:	0000      	movs	r0, r0
	...

08004070 <ibqGetTimeout>:
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, sysinterval_t timeout) {
 8004070:	b538      	push	{r3, r4, r5, lr}
 8004072:	4604      	mov	r4, r0
 8004074:	460d      	mov	r5, r1
 8004076:	2320      	movs	r3, #32
 8004078:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800407c:	f7fe fc30 	bl	80028e0 <_dbg_check_lock>
  if (ibqp->ptr == NULL) {
 8004080:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004082:	b1e3      	cbz	r3, 80040be <ibqGetTimeout+0x4e>
  msg = (msg_t)*ibqp->ptr;
 8004084:	f813 5b01 	ldrb.w	r5, [r3], #1
  if (ibqp->ptr >= ibqp->top) {
 8004088:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  ibqp->ptr++;
 800408a:	62a3      	str	r3, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
 800408c:	4293      	cmp	r3, r2
 800408e:	d212      	bcs.n	80040b6 <ibqGetTimeout+0x46>
  _dbg_check_unlock();
 8004090:	f7fe fbfe 	bl	8002890 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004094:	4b0e      	ldr	r3, [pc, #56]	; (80040d0 <ibqGetTimeout+0x60>)
 8004096:	681a      	ldr	r2, [r3, #0]
 8004098:	429a      	cmp	r2, r3
 800409a:	d004      	beq.n	80040a6 <ibqGetTimeout+0x36>
 800409c:	6999      	ldr	r1, [r3, #24]
 800409e:	6893      	ldr	r3, [r2, #8]
 80040a0:	688a      	ldr	r2, [r1, #8]
 80040a2:	429a      	cmp	r2, r3
 80040a4:	d304      	bcc.n	80040b0 <ibqGetTimeout+0x40>
 80040a6:	2300      	movs	r3, #0
 80040a8:	f383 8811 	msr	BASEPRI, r3
}
 80040ac:	4628      	mov	r0, r5
 80040ae:	bd38      	pop	{r3, r4, r5, pc}
 80040b0:	4808      	ldr	r0, [pc, #32]	; (80040d4 <ibqGetTimeout+0x64>)
 80040b2:	f7fc fb6d 	bl	8000790 <chSysHalt>
    ibqReleaseEmptyBufferS(ibqp);
 80040b6:	4620      	mov	r0, r4
 80040b8:	f7fd fc42 	bl	8001940 <ibqReleaseEmptyBufferS>
  _dbg_check_unlock();
 80040bc:	e7e8      	b.n	8004090 <ibqGetTimeout+0x20>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 80040be:	4629      	mov	r1, r5
 80040c0:	4620      	mov	r0, r4
 80040c2:	f7fd fde5 	bl	8001c90 <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
 80040c6:	4605      	mov	r5, r0
 80040c8:	2800      	cmp	r0, #0
 80040ca:	d1e1      	bne.n	8004090 <ibqGetTimeout+0x20>
 80040cc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80040ce:	e7d9      	b.n	8004084 <ibqGetTimeout+0x14>
 80040d0:	20000e84 	.word	0x20000e84
 80040d4:	08005098 	.word	0x08005098
	...

080040e0 <_gett.lto_priv.1>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 80040e0:	300c      	adds	r0, #12
 80040e2:	f7ff bfc5 	b.w	8004070 <ibqGetTimeout>
 80040e6:	bf00      	nop
	...

080040f0 <_get.lto_priv.1>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 80040f0:	300c      	adds	r0, #12
 80040f2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80040f6:	f7ff bfbb 	b.w	8004070 <ibqGetTimeout>
 80040fa:	bf00      	nop
 80040fc:	0000      	movs	r0, r0
	...

08004100 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8004100:	4a84      	ldr	r2, [pc, #528]	; (8004314 <__early_init+0x214>)
  gpiop->OTYPER  = config->otyper;
 8004102:	4885      	ldr	r0, [pc, #532]	; (8004318 <__early_init+0x218>)
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8004104:	6913      	ldr	r3, [r2, #16]
  gpiop->OTYPER  = config->otyper;
 8004106:	f8df c268 	ldr.w	ip, [pc, #616]	; 8004370 <__early_init+0x270>
  rccResetAHB1(STM32_GPIO_EN_MASK);
 800410a:	f240 11ff 	movw	r1, #511	; 0x1ff
 800410e:	430b      	orrs	r3, r1
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8004110:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8004114:	6113      	str	r3, [r2, #16]
 8004116:	6913      	ldr	r3, [r2, #16]
  gpiop->OTYPER  = config->otyper;
 8004118:	4e80      	ldr	r6, [pc, #512]	; (800431c <__early_init+0x21c>)
  gpiop->PUPDR   = config->pupdr;
 800411a:	f8df e258 	ldr.w	lr, [pc, #600]	; 8004374 <__early_init+0x274>
  gpiop->AFRL    = config->afrl;
 800411e:	4f80      	ldr	r7, [pc, #512]	; (8004320 <__early_init+0x220>)
  gpiop->OTYPER  = config->otyper;
 8004120:	4d80      	ldr	r5, [pc, #512]	; (8004324 <__early_init+0x224>)
 8004122:	4c81      	ldr	r4, [pc, #516]	; (8004328 <__early_init+0x228>)
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8004124:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 8004128:	f023 0301 	bic.w	r3, r3, #1
 800412c:	6113      	str	r3, [r2, #16]
 800412e:	6913      	ldr	r3, [r2, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 8004130:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8004132:	430b      	orrs	r3, r1
 8004134:	6313      	str	r3, [r2, #48]	; 0x30
 8004136:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8004138:	430b      	orrs	r3, r1
 800413a:	6513      	str	r3, [r2, #80]	; 0x50
  gpiop->OSPEEDR = config->ospeedr;
 800413c:	f46f 41a8 	mvn.w	r1, #21504	; 0x5400
  gpiop->OTYPER  = config->otyper;
 8004140:	2300      	movs	r3, #0
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 8004142:	f8d2 8050 	ldr.w	r8, [r2, #80]	; 0x50
  gpiop->OTYPER  = config->otyper;
 8004146:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004148:	6081      	str	r1, [r0, #8]
  gpiop->ODR     = config->odr;
 800414a:	f64f 71ff 	movw	r1, #65535	; 0xffff
  gpiop->PUPDR   = config->pupdr;
 800414e:	f8c0 e00c 	str.w	lr, [r0, #12]
  gpiop->AFRH    = config->afrh;
 8004152:	f8df 8224 	ldr.w	r8, [pc, #548]	; 8004378 <__early_init+0x278>
  gpiop->ODR     = config->odr;
 8004156:	6141      	str	r1, [r0, #20]
  gpiop->MODER   = config->moder;
 8004158:	f8df e220 	ldr.w	lr, [pc, #544]	; 800437c <__early_init+0x27c>
  gpiop->AFRL    = config->afrl;
 800415c:	6207      	str	r7, [r0, #32]
  gpiop->OTYPER  = config->otyper;
 800415e:	f44f 7710 	mov.w	r7, #576	; 0x240
  gpiop->AFRH    = config->afrh;
 8004162:	f8c0 8024 	str.w	r8, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8004166:	f8c0 e000 	str.w	lr, [r0]
  gpiop->OTYPER  = config->otyper;
 800416a:	6077      	str	r7, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800416c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  gpiop->PUPDR   = config->pupdr;
 8004170:	f8df e20c 	ldr.w	lr, [pc, #524]	; 8004380 <__early_init+0x280>
  gpiop->OSPEEDR = config->ospeedr;
 8004174:	60b0      	str	r0, [r6, #8]
  gpiop->AFRL    = config->afrl;
 8004176:	f04f 6780 	mov.w	r7, #67108864	; 0x4000000
  gpiop->PUPDR   = config->pupdr;
 800417a:	f8c6 e00c 	str.w	lr, [r6, #12]
  gpiop->ODR     = config->odr;
 800417e:	6171      	str	r1, [r6, #20]
  gpiop->AFRH    = config->afrh;
 8004180:	f04f 0e40 	mov.w	lr, #64	; 0x40
  gpiop->AFRL    = config->afrl;
 8004184:	6237      	str	r7, [r6, #32]
  gpiop->MODER   = config->moder;
 8004186:	4f69      	ldr	r7, [pc, #420]	; (800432c <__early_init+0x22c>)
  gpiop->AFRH    = config->afrh;
 8004188:	f8c6 e024 	str.w	lr, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800418c:	6037      	str	r7, [r6, #0]
  gpiop->PUPDR   = config->pupdr;
 800418e:	f106 56a2 	add.w	r6, r6, #339738624	; 0x14400000
 8004192:	f506 3644 	add.w	r6, r6, #200704	; 0x31000
 8004196:	f506 76aa 	add.w	r6, r6, #340	; 0x154
  gpiop->OTYPER  = config->otyper;
 800419a:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800419c:	60a8      	str	r0, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 800419e:	60ee      	str	r6, [r5, #12]
  gpiop->AFRL    = config->afrl;
 80041a0:	f04f 46c0 	mov.w	r6, #1610612736	; 0x60000000
  gpiop->ODR     = config->odr;
 80041a4:	6169      	str	r1, [r5, #20]
  gpiop->AFRL    = config->afrl;
 80041a6:	622e      	str	r6, [r5, #32]
  gpiop->AFRH    = config->afrh;
 80041a8:	4e61      	ldr	r6, [pc, #388]	; (8004330 <__early_init+0x230>)
 80041aa:	626e      	str	r6, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80041ac:	4e61      	ldr	r6, [pc, #388]	; (8004334 <__early_init+0x234>)
 80041ae:	602e      	str	r6, [r5, #0]
  gpiop->PUPDR   = config->pupdr;
 80041b0:	4d61      	ldr	r5, [pc, #388]	; (8004338 <__early_init+0x238>)
  gpiop->OTYPER  = config->otyper;
 80041b2:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80041b4:	60a0      	str	r0, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 80041b6:	60e5      	str	r5, [r4, #12]
  gpiop->ODR     = config->odr;
 80041b8:	f640 75ff 	movw	r5, #4095	; 0xfff
 80041bc:	6165      	str	r5, [r4, #20]
  gpiop->OTYPER  = config->otyper;
 80041be:	4f5f      	ldr	r7, [pc, #380]	; (800433c <__early_init+0x23c>)
 80041c0:	4e5f      	ldr	r6, [pc, #380]	; (8004340 <__early_init+0x240>)
  gpiop->MODER   = config->moder;
 80041c2:	4d60      	ldr	r5, [pc, #384]	; (8004344 <__early_init+0x244>)
  gpiop->AFRL    = config->afrl;
 80041c4:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
 80041c6:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80041c8:	6025      	str	r5, [r4, #0]
  gpiop->OTYPER  = config->otyper;
 80041ca:	f8cc 3004 	str.w	r3, [ip, #4]
 80041ce:	4d5e      	ldr	r5, [pc, #376]	; (8004348 <__early_init+0x248>)
  gpiop->OSPEEDR = config->ospeedr;
 80041d0:	f8cc 0008 	str.w	r0, [ip, #8]
  gpiop->OTYPER  = config->otyper;
 80041d4:	f504 54a0 	add.w	r4, r4, #5120	; 0x1400
  gpiop->PUPDR   = config->pupdr;
 80041d8:	f8cc 300c 	str.w	r3, [ip, #12]
  gpiop->ODR     = config->odr;
 80041dc:	f8cc 1014 	str.w	r1, [ip, #20]
  gpiop->AFRL    = config->afrl;
 80041e0:	f8cc 3020 	str.w	r3, [ip, #32]
  gpiop->AFRH    = config->afrh;
 80041e4:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80041e8:	f8cc e000 	str.w	lr, [ip]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 80041ec:	f5ac 3cd0 	sub.w	ip, ip, #106496	; 0x1a000
  gpiop->OTYPER  = config->otyper;
 80041f0:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80041f2:	60b8      	str	r0, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 80041f4:	60fb      	str	r3, [r7, #12]
  gpiop->ODR     = config->odr;
 80041f6:	6179      	str	r1, [r7, #20]
  gpiop->AFRL    = config->afrl;
 80041f8:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 80041fa:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80041fc:	603b      	str	r3, [r7, #0]
  gpiop->OTYPER  = config->otyper;
 80041fe:	6073      	str	r3, [r6, #4]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8004200:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
  gpiop->OSPEEDR = config->ospeedr;
 8004204:	60b0      	str	r0, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8004206:	60f3      	str	r3, [r6, #12]
  gpiop->ODR     = config->odr;
 8004208:	6171      	str	r1, [r6, #20]
  gpiop->AFRL    = config->afrl;
 800420a:	6233      	str	r3, [r6, #32]
  gpiop->AFRH    = config->afrh;
 800420c:	6273      	str	r3, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800420e:	6033      	str	r3, [r6, #0]
  PWR->CR = STM32_VOS;
 8004210:	f44f 4640 	mov.w	r6, #49152	; 0xc000
  gpiop->OTYPER  = config->otyper;
 8004214:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004216:	60a8      	str	r0, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 8004218:	60eb      	str	r3, [r5, #12]
  gpiop->ODR     = config->odr;
 800421a:	6169      	str	r1, [r5, #20]
  gpiop->AFRL    = config->afrl;
 800421c:	622b      	str	r3, [r5, #32]
  gpiop->AFRH    = config->afrh;
 800421e:	626b      	str	r3, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8004220:	602b      	str	r3, [r5, #0]
  gpiop->OTYPER  = config->otyper;
 8004222:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004224:	60a0      	str	r0, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8004226:	60e3      	str	r3, [r4, #12]
  gpiop->ODR     = config->odr;
 8004228:	6161      	str	r1, [r4, #20]
  gpiop->AFRL    = config->afrl;
 800422a:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
 800422c:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800422e:	6023      	str	r3, [r4, #0]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8004230:	6417      	str	r7, [r2, #64]	; 0x40
  PWR->CR = STM32_VOS;
 8004232:	f8cc 6000 	str.w	r6, [ip]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8004236:	6813      	ldr	r3, [r2, #0]
 8004238:	f043 0301 	orr.w	r3, r3, #1
 800423c:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800423e:	6813      	ldr	r3, [r2, #0]
 8004240:	079e      	lsls	r6, r3, #30
 8004242:	d5fc      	bpl.n	800423e <__early_init+0x13e>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8004244:	6891      	ldr	r1, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8004246:	4b33      	ldr	r3, [pc, #204]	; (8004314 <__early_init+0x214>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8004248:	f021 0103 	bic.w	r1, r1, #3
 800424c:	6091      	str	r1, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800424e:	689a      	ldr	r2, [r3, #8]
 8004250:	f012 020c 	ands.w	r2, r2, #12
 8004254:	d1fb      	bne.n	800424e <__early_init+0x14e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8004256:	6818      	ldr	r0, [r3, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8004258:	492e      	ldr	r1, [pc, #184]	; (8004314 <__early_init+0x214>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800425a:	f000 00f9 	and.w	r0, r0, #249	; 0xf9
 800425e:	6018      	str	r0, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8004260:	609a      	str	r2, [r3, #8]
  RCC->CR |= RCC_CR_HSEON;
 8004262:	681a      	ldr	r2, [r3, #0]
 8004264:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8004268:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800426a:	680b      	ldr	r3, [r1, #0]
 800426c:	039d      	lsls	r5, r3, #14
 800426e:	d5fc      	bpl.n	800426a <__early_init+0x16a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8004270:	6f4a      	ldr	r2, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8004272:	4b28      	ldr	r3, [pc, #160]	; (8004314 <__early_init+0x214>)
  RCC->CSR |= RCC_CSR_LSION;
 8004274:	f042 0201 	orr.w	r2, r2, #1
 8004278:	674a      	str	r2, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800427a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800427c:	0794      	lsls	r4, r2, #30
 800427e:	d5fc      	bpl.n	800427a <__early_init+0x17a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8004280:	4a32      	ldr	r2, [pc, #200]	; (800434c <__early_init+0x24c>)
 8004282:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8004284:	681a      	ldr	r2, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8004286:	4932      	ldr	r1, [pc, #200]	; (8004350 <__early_init+0x250>)
  RCC->CR |= RCC_CR_PLLON;
 8004288:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800428c:	601a      	str	r2, [r3, #0]
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 800428e:	684b      	ldr	r3, [r1, #4]
 8004290:	0458      	lsls	r0, r3, #17
 8004292:	d5fc      	bpl.n	800428e <__early_init+0x18e>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8004294:	4b1f      	ldr	r3, [pc, #124]	; (8004314 <__early_init+0x214>)
 8004296:	681a      	ldr	r2, [r3, #0]
 8004298:	0192      	lsls	r2, r2, #6
 800429a:	d5fc      	bpl.n	8004296 <__early_init+0x196>
    ;
#endif /* STM32_ACTIVATE_PLL */

#if STM32_ACTIVATE_PLLI2S
  /* PLLI2S activation.*/
  RCC->PLLI2SCFGR = STM32_PLLI2SR | STM32_PLLI2SN | STM32_PLLI2SP |
 800429c:	4a2d      	ldr	r2, [pc, #180]	; (8004354 <__early_init+0x254>)
 800429e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                    STM32_PLLI2SSRC | STM32_PLLI2SQ | STM32_PLLI2SM;
  RCC->CR |= RCC_CR_PLLI2SON;
 80042a2:	681a      	ldr	r2, [r3, #0]

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLI2SRDY))
 80042a4:	491b      	ldr	r1, [pc, #108]	; (8004314 <__early_init+0x214>)
  RCC->CR |= RCC_CR_PLLI2SON;
 80042a6:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 80042aa:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLI2SRDY))
 80042ac:	680b      	ldr	r3, [r1, #0]
 80042ae:	011b      	lsls	r3, r3, #4
 80042b0:	d5fc      	bpl.n	80042ac <__early_init+0x1ac>
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
#if !defined(STM32F413xx)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 80042b2:	4a29      	ldr	r2, [pc, #164]	; (8004358 <__early_init+0x258>)

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80042b4:	4b29      	ldr	r3, [pc, #164]	; (800435c <__early_init+0x25c>)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 80042b6:	608a      	str	r2, [r1, #8]
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80042b8:	681a      	ldr	r2, [r3, #0]
 80042ba:	4b29      	ldr	r3, [pc, #164]	; (8004360 <__early_init+0x260>)
 80042bc:	429a      	cmp	r2, r3
 80042be:	d01e      	beq.n	80042fe <__early_init+0x1fe>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 80042c0:	4b28      	ldr	r3, [pc, #160]	; (8004364 <__early_init+0x264>)
 80042c2:	f240 7205 	movw	r2, #1797	; 0x705
 80042c6:	601a      	str	r2, [r3, #0]
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 80042c8:	4a26      	ldr	r2, [pc, #152]	; (8004364 <__early_init+0x264>)
 80042ca:	6813      	ldr	r3, [r2, #0]
 80042cc:	f003 030f 	and.w	r3, r3, #15
 80042d0:	2b05      	cmp	r3, #5
 80042d2:	d1fa      	bne.n	80042ca <__early_init+0x1ca>
         (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80042d4:	4b0f      	ldr	r3, [pc, #60]	; (8004314 <__early_init+0x214>)
 80042d6:	689a      	ldr	r2, [r3, #8]
 80042d8:	f042 0202 	orr.w	r2, r2, #2
 80042dc:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80042de:	689a      	ldr	r2, [r3, #8]
 80042e0:	f002 020c 	and.w	r2, r2, #12
 80042e4:	2a08      	cmp	r2, #8
 80042e6:	d1fa      	bne.n	80042de <__early_init+0x1de>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 80042e8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80042ea:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80042ee:	645a      	str	r2, [r3, #68]	; 0x44
 80042f0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 80042f2:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80042f6:	665a      	str	r2, [r3, #100]	; 0x64
 80042f8:	6e5b      	ldr	r3, [r3, #100]	; 0x64

  stm32_gpio_init();
  stm32_clock_init();
}
 80042fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80042fe:	4a1a      	ldr	r2, [pc, #104]	; (8004368 <__early_init+0x268>)
 8004300:	4b1a      	ldr	r3, [pc, #104]	; (800436c <__early_init+0x26c>)
 8004302:	6812      	ldr	r2, [r2, #0]
 8004304:	429a      	cmp	r2, r3
 8004306:	d1db      	bne.n	80042c0 <__early_init+0x1c0>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 8004308:	4b16      	ldr	r3, [pc, #88]	; (8004364 <__early_init+0x264>)
 800430a:	f240 1205 	movw	r2, #261	; 0x105
 800430e:	601a      	str	r2, [r3, #0]
 8004310:	e7da      	b.n	80042c8 <__early_init+0x1c8>
 8004312:	bf00      	nop
 8004314:	40023800 	.word	0x40023800
 8004318:	40020000 	.word	0x40020000
 800431c:	40020400 	.word	0x40020400
 8004320:	55560000 	.word	0x55560000
 8004324:	40020800 	.word	0x40020800
 8004328:	40020c00 	.word	0x40020c00
 800432c:	00082080 	.word	0x00082080
 8004330:	00060600 	.word	0x00060600
 8004334:	02208001 	.word	0x02208001
 8004338:	00555055 	.word	0x00555055
 800433c:	40021400 	.word	0x40021400
 8004340:	40021800 	.word	0x40021800
 8004344:	55000100 	.word	0x55000100
 8004348:	40021c00 	.word	0x40021c00
 800434c:	07405408 	.word	0x07405408
 8004350:	40007000 	.word	0x40007000
 8004354:	54413004 	.word	0x54413004
 8004358:	38089400 	.word	0x38089400
 800435c:	e0042000 	.word	0xe0042000
 8004360:	20006411 	.word	0x20006411
 8004364:	40023c00 	.word	0x40023c00
 8004368:	e000ed00 	.word	0xe000ed00
 800436c:	410fc241 	.word	0x410fc241
 8004370:	40021000 	.word	0x40021000
 8004374:	40010054 	.word	0x40010054
 8004378:	000aaa00 	.word	0x000aaa00
 800437c:	2aa0aa00 	.word	0x2aa0aa00
 8004380:	55514515 	.word	0x55514515
	...

08004390 <Vector110>:
OSAL_IRQ_HANDLER(STM32_UART4_HANDLER) {
 8004390:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  USART_TypeDef *u = sdp->usart;
 8004394:	4c74      	ldr	r4, [pc, #464]	; (8004568 <Vector110+0x1d8>)
  OSAL_IRQ_PROLOGUE();
 8004396:	4875      	ldr	r0, [pc, #468]	; (800456c <Vector110+0x1dc>)
 8004398:	f7fc f9d2 	bl	8000740 <_trace_isr_enter>
 800439c:	f7fc fb40 	bl	8000a20 <_dbg_check_enter_isr>
  USART_TypeDef *u = sdp->usart;
 80043a0:	6f66      	ldr	r6, [r4, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 80043a2:	f8d6 800c 	ldr.w	r8, [r6, #12]
  uint16_t sr = u->SR;
 80043a6:	6833      	ldr	r3, [r6, #0]
  if (sr & USART_SR_LBD) {
 80043a8:	05da      	lsls	r2, r3, #23
  uint16_t sr = u->SR;
 80043aa:	b29d      	uxth	r5, r3
  if (sr & USART_SR_LBD) {
 80043ac:	d47c      	bmi.n	80044a8 <Vector110+0x118>
 80043ae:	2320      	movs	r3, #32
 80043b0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 80043b4:	f7fc fb64 	bl	8000a80 <_dbg_check_lock_from_isr>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80043b8:	f015 0f2f 	tst.w	r5, #47	; 0x2f
 80043bc:	d049      	beq.n	8004452 <Vector110+0xc2>
  chEvtBroadcastFlagsI(esp, flags);
 80043be:	4f6c      	ldr	r7, [pc, #432]	; (8004570 <Vector110+0x1e0>)
  chThdDequeueNextI(tqp, msg);
 80043c0:	f107 0908 	add.w	r9, r7, #8
 80043c4:	e008      	b.n	80043d8 <Vector110+0x48>
    if (sr & USART_SR_RXNE)
 80043c6:	06a8      	lsls	r0, r5, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 80043c8:	f8d6 a004 	ldr.w	sl, [r6, #4]
    if (sr & USART_SR_RXNE)
 80043cc:	d41e      	bmi.n	800440c <Vector110+0x7c>
    sr = u->SR;
 80043ce:	6833      	ldr	r3, [r6, #0]
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80043d0:	f013 0f2f 	tst.w	r3, #47	; 0x2f
    sr = u->SR;
 80043d4:	b29d      	uxth	r5, r3
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80043d6:	d03c      	beq.n	8004452 <Vector110+0xc2>
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 80043d8:	072b      	lsls	r3, r5, #28
 80043da:	d0f4      	beq.n	80043c6 <Vector110+0x36>
    sts |= SD_OVERRUN_ERROR;
 80043dc:	f015 0f08 	tst.w	r5, #8
 80043e0:	bf0c      	ite	eq
 80043e2:	2100      	moveq	r1, #0
 80043e4:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 80043e6:	07e8      	lsls	r0, r5, #31
    sts |= SD_PARITY_ERROR;
 80043e8:	bf48      	it	mi
 80043ea:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 80043ee:	07aa      	lsls	r2, r5, #30
    sts |= SD_FRAMING_ERROR;
 80043f0:	bf48      	it	mi
 80043f2:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 80043f6:	076b      	lsls	r3, r5, #29
    sts |= SD_NOISE_ERROR;
 80043f8:	bf48      	it	mi
 80043fa:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
  chEvtBroadcastFlagsI(esp, flags);
 80043fe:	4638      	mov	r0, r7
 8004400:	f7fc fab6 	bl	8000970 <chEvtBroadcastFlagsI>
    if (sr & USART_SR_RXNE)
 8004404:	06a8      	lsls	r0, r5, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 8004406:	f8d6 a004 	ldr.w	sl, [r6, #4]
    if (sr & USART_SR_RXNE)
 800440a:	d5e0      	bpl.n	80043ce <Vector110+0x3e>
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
 800440c:	f7fc f9e8 	bl	80007e0 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8004410:	6963      	ldr	r3, [r4, #20]
    b = (uint8_t)u->DR & sdp->rxmask;
 8004412:	f894 5078 	ldrb.w	r5, [r4, #120]	; 0x78
 8004416:	b3a3      	cbz	r3, 8004482 <Vector110+0xf2>
  osalDbgCheckClassI();
 8004418:	f7fc f9e2 	bl	80007e0 <chDbgCheckClassI>
  if (!iqIsFullI(iqp)) {
 800441c:	e9d4 3208 	ldrd	r3, r2, [r4, #32]
 8004420:	4293      	cmp	r3, r2
 8004422:	d038      	beq.n	8004496 <Vector110+0x106>
    iqp->q_counter++;
 8004424:	6962      	ldr	r2, [r4, #20]
    *iqp->q_wrptr++ = b;
 8004426:	1c59      	adds	r1, r3, #1
    iqp->q_counter++;
 8004428:	3201      	adds	r2, #1
 800442a:	ea05 0a0a 	and.w	sl, r5, sl
 800442e:	6162      	str	r2, [r4, #20]
    *iqp->q_wrptr++ = b;
 8004430:	6221      	str	r1, [r4, #32]
 8004432:	f883 a000 	strb.w	sl, [r3]
    if (iqp->q_wrptr >= iqp->q_top) {
 8004436:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
 800443a:	429a      	cmp	r2, r3
 800443c:	d301      	bcc.n	8004442 <Vector110+0xb2>
      iqp->q_wrptr = iqp->q_buffer;
 800443e:	69a3      	ldr	r3, [r4, #24]
 8004440:	6223      	str	r3, [r4, #32]
  chThdDequeueNextI(tqp, msg);
 8004442:	4648      	mov	r0, r9
 8004444:	f7fc fa5c 	bl	8000900 <chThdDequeueNextI.constprop.0>
    sr = u->SR;
 8004448:	6833      	ldr	r3, [r6, #0]
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800444a:	f013 0f2f 	tst.w	r3, #47	; 0x2f
    sr = u->SR;
 800444e:	b29d      	uxth	r5, r3
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8004450:	d1c2      	bne.n	80043d8 <Vector110+0x48>
  _dbg_check_unlock_from_isr();
 8004452:	f7fc fafd 	bl	8000a50 <_dbg_check_unlock_from_isr>
 8004456:	2300      	movs	r3, #0
 8004458:	f383 8811 	msr	BASEPRI, r3
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 800445c:	f018 0f80 	tst.w	r8, #128	; 0x80
 8004460:	d001      	beq.n	8004466 <Vector110+0xd6>
 8004462:	062a      	lsls	r2, r5, #24
 8004464:	d433      	bmi.n	80044ce <Vector110+0x13e>
  if ((cr1 & USART_CR1_TCIE) && (sr & USART_SR_TC)) {
 8004466:	f018 0f40 	tst.w	r8, #64	; 0x40
 800446a:	d001      	beq.n	8004470 <Vector110+0xe0>
 800446c:	066b      	lsls	r3, r5, #25
 800446e:	d451      	bmi.n	8004514 <Vector110+0x184>
  OSAL_IRQ_EPILOGUE();
 8004470:	f7fc fabe 	bl	80009f0 <_dbg_check_leave_isr>
 8004474:	483d      	ldr	r0, [pc, #244]	; (800456c <Vector110+0x1dc>)
 8004476:	f7fc f94b 	bl	8000710 <_trace_isr_leave>
}
 800447a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 800447e:	f7fc b8b7 	b.w	80005f0 <_port_irq_epilogue>
  chEvtBroadcastFlagsI(esp, flags);
 8004482:	2104      	movs	r1, #4
 8004484:	4638      	mov	r0, r7
 8004486:	f7fc fa73 	bl	8000970 <chEvtBroadcastFlagsI>
  osalDbgCheckClassI();
 800448a:	f7fc f9a9 	bl	80007e0 <chDbgCheckClassI>
  if (!iqIsFullI(iqp)) {
 800448e:	e9d4 3208 	ldrd	r3, r2, [r4, #32]
 8004492:	4293      	cmp	r3, r2
 8004494:	d1c6      	bne.n	8004424 <Vector110+0x94>
 8004496:	6962      	ldr	r2, [r4, #20]
 8004498:	2a00      	cmp	r2, #0
 800449a:	d0c3      	beq.n	8004424 <Vector110+0x94>
 800449c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80044a0:	4638      	mov	r0, r7
 80044a2:	f7fc fa65 	bl	8000970 <chEvtBroadcastFlagsI>
 80044a6:	e792      	b.n	80043ce <Vector110+0x3e>
 80044a8:	2320      	movs	r3, #32
 80044aa:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 80044ae:	f7fc fae7 	bl	8000a80 <_dbg_check_lock_from_isr>
 80044b2:	1d20      	adds	r0, r4, #4
 80044b4:	f44f 7100 	mov.w	r1, #512	; 0x200
 80044b8:	f7fc fa5a 	bl	8000970 <chEvtBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
 80044bc:	f46f 7380 	mvn.w	r3, #256	; 0x100
 80044c0:	6033      	str	r3, [r6, #0]
  _dbg_check_unlock_from_isr();
 80044c2:	f7fc fac5 	bl	8000a50 <_dbg_check_unlock_from_isr>
 80044c6:	2300      	movs	r3, #0
 80044c8:	f383 8811 	msr	BASEPRI, r3
 80044cc:	e76f      	b.n	80043ae <Vector110+0x1e>
 80044ce:	2320      	movs	r3, #32
 80044d0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 80044d4:	f7fc fad4 	bl	8000a80 <_dbg_check_lock_from_isr>
  osalDbgCheckClassI();
 80044d8:	f7fc f982 	bl	80007e0 <chDbgCheckClassI>
  if (!oqIsEmptyI(oqp)) {
 80044dc:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	; 0x44
 80044e0:	429a      	cmp	r2, r3
 80044e2:	d026      	beq.n	8004532 <Vector110+0x1a2>
    oqp->q_counter++;
 80044e4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    if (oqp->q_rdptr >= oqp->q_top) {
 80044e6:	6c21      	ldr	r1, [r4, #64]	; 0x40
    b = *oqp->q_rdptr++;
 80044e8:	1c58      	adds	r0, r3, #1
    oqp->q_counter++;
 80044ea:	3201      	adds	r2, #1
 80044ec:	63a2      	str	r2, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
 80044ee:	64a0      	str	r0, [r4, #72]	; 0x48
    if (oqp->q_rdptr >= oqp->q_top) {
 80044f0:	4288      	cmp	r0, r1
    b = *oqp->q_rdptr++;
 80044f2:	781f      	ldrb	r7, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
 80044f4:	d301      	bcc.n	80044fa <Vector110+0x16a>
      oqp->q_rdptr = oqp->q_buffer;
 80044f6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80044f8:	64a3      	str	r3, [r4, #72]	; 0x48
  chThdDequeueNextI(tqp, msg);
 80044fa:	481e      	ldr	r0, [pc, #120]	; (8004574 <Vector110+0x1e4>)
 80044fc:	f7fc fa00 	bl	8000900 <chThdDequeueNextI.constprop.0>
      u->DR = b;
 8004500:	6077      	str	r7, [r6, #4]
  _dbg_check_unlock_from_isr();
 8004502:	f7fc faa5 	bl	8000a50 <_dbg_check_unlock_from_isr>
 8004506:	2300      	movs	r3, #0
 8004508:	f383 8811 	msr	BASEPRI, r3
  if ((cr1 & USART_CR1_TCIE) && (sr & USART_SR_TC)) {
 800450c:	f018 0f40 	tst.w	r8, #64	; 0x40
 8004510:	d0ae      	beq.n	8004470 <Vector110+0xe0>
 8004512:	e7ab      	b.n	800446c <Vector110+0xdc>
 8004514:	2320      	movs	r3, #32
 8004516:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 800451a:	f7fc fab1 	bl	8000a80 <_dbg_check_lock_from_isr>
    if (oqIsEmptyI(&sdp->oqueue)) {
 800451e:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	; 0x44
 8004522:	429a      	cmp	r2, r3
 8004524:	d012      	beq.n	800454c <Vector110+0x1bc>
  _dbg_check_unlock_from_isr();
 8004526:	f7fc fa93 	bl	8000a50 <_dbg_check_unlock_from_isr>
 800452a:	2300      	movs	r3, #0
 800452c:	f383 8811 	msr	BASEPRI, r3
 8004530:	e79e      	b.n	8004470 <Vector110+0xe0>
  if (!oqIsEmptyI(oqp)) {
 8004532:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8004534:	2a00      	cmp	r2, #0
 8004536:	d0d5      	beq.n	80044e4 <Vector110+0x154>
  chEvtBroadcastFlagsI(esp, flags);
 8004538:	480d      	ldr	r0, [pc, #52]	; (8004570 <Vector110+0x1e0>)
 800453a:	2108      	movs	r1, #8
 800453c:	f7fc fa18 	bl	8000970 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TXEIE;
 8004540:	f64f 737f 	movw	r3, #65407	; 0xff7f
 8004544:	ea08 0303 	and.w	r3, r8, r3
 8004548:	60f3      	str	r3, [r6, #12]
 800454a:	e7da      	b.n	8004502 <Vector110+0x172>
    if (oqIsEmptyI(&sdp->oqueue)) {
 800454c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800454e:	2b00      	cmp	r3, #0
 8004550:	d0e9      	beq.n	8004526 <Vector110+0x196>
 8004552:	4807      	ldr	r0, [pc, #28]	; (8004570 <Vector110+0x1e0>)
 8004554:	2110      	movs	r1, #16
 8004556:	f7fc fa0b 	bl	8000970 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 800455a:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 800455e:	ea08 0303 	and.w	r3, r8, r3
 8004562:	60f3      	str	r3, [r6, #12]
 8004564:	e7df      	b.n	8004526 <Vector110+0x196>
 8004566:	bf00      	nop
 8004568:	20000888 	.word	0x20000888
 800456c:	08004de4 	.word	0x08004de4
 8004570:	2000088c 	.word	0x2000088c
 8004574:	200008b8 	.word	0x200008b8
	...

08004580 <Vector118>:
OSAL_IRQ_HANDLER(STM32_TIM6_HANDLER) {
 8004580:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8004582:	4817      	ldr	r0, [pc, #92]	; (80045e0 <Vector118+0x60>)
 8004584:	f7fc f8dc 	bl	8000740 <_trace_isr_enter>
 8004588:	f7fc fa4a 	bl	8000a20 <_dbg_check_enter_isr>
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {
  uint32_t sr;

  sr  = gptp->tim->SR;
 800458c:	4815      	ldr	r0, [pc, #84]	; (80045e4 <Vector118+0x64>)
 800458e:	68c2      	ldr	r2, [r0, #12]
 8004590:	6913      	ldr	r3, [r2, #16]
  sr &= gptp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8004592:	68d1      	ldr	r1, [r2, #12]
 8004594:	400b      	ands	r3, r1
 8004596:	b2d9      	uxtb	r1, r3
  gptp->tim->SR = ~sr;
 8004598:	43c9      	mvns	r1, r1
  if ((sr & STM32_TIM_SR_UIF) != 0) {
 800459a:	07db      	lsls	r3, r3, #31
  gptp->tim->SR = ~sr;
 800459c:	6111      	str	r1, [r2, #16]
  if ((sr & STM32_TIM_SR_UIF) != 0) {
 800459e:	d507      	bpl.n	80045b0 <Vector118+0x30>
    _gpt_isr_invoke_cb(gptp);
 80045a0:	7803      	ldrb	r3, [r0, #0]
 80045a2:	2b04      	cmp	r3, #4
 80045a4:	d00d      	beq.n	80045c2 <Vector118+0x42>
 80045a6:	6843      	ldr	r3, [r0, #4]
 80045a8:	685b      	ldr	r3, [r3, #4]
 80045aa:	b10b      	cbz	r3, 80045b0 <Vector118+0x30>
 80045ac:	480d      	ldr	r0, [pc, #52]	; (80045e4 <Vector118+0x64>)
 80045ae:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 80045b0:	f7fc fa1e 	bl	80009f0 <_dbg_check_leave_isr>
 80045b4:	480a      	ldr	r0, [pc, #40]	; (80045e0 <Vector118+0x60>)
 80045b6:	f7fc f8ab 	bl	8000710 <_trace_isr_leave>
}
 80045ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 80045be:	f7fc b817 	b.w	80005f0 <_port_irq_epilogue>
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
 80045c2:	2300      	movs	r3, #0
    _gpt_isr_invoke_cb(gptp);
 80045c4:	2102      	movs	r1, #2
 80045c6:	7001      	strb	r1, [r0, #0]
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
 80045c8:	6013      	str	r3, [r2, #0]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
 80045ca:	6113      	str	r3, [r2, #16]
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 80045cc:	68d3      	ldr	r3, [r2, #12]
 80045ce:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80045d2:	60d3      	str	r3, [r2, #12]
    _gpt_isr_invoke_cb(gptp);
 80045d4:	6843      	ldr	r3, [r0, #4]
 80045d6:	685b      	ldr	r3, [r3, #4]
 80045d8:	2b00      	cmp	r3, #0
 80045da:	d1e7      	bne.n	80045ac <Vector118+0x2c>
 80045dc:	e7e8      	b.n	80045b0 <Vector118+0x30>
 80045de:	bf00      	nop
 80045e0:	08004d80 	.word	0x08004d80
 80045e4:	20000878 	.word	0x20000878
	...

080045f0 <VectorB0>:
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80045f0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 80045f4:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
  OSAL_IRQ_PROLOGUE();
 80045f8:	4838      	ldr	r0, [pc, #224]	; (80046dc <VectorB0+0xec>)
 80045fa:	f7fc f8a1 	bl	8000740 <_trace_isr_enter>
 80045fe:	f7fc fa0f 	bl	8000a20 <_dbg_check_enter_isr>
  sr  = timp->SR;
 8004602:	692b      	ldr	r3, [r5, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8004604:	68ea      	ldr	r2, [r5, #12]
 8004606:	4013      	ands	r3, r2
 8004608:	b2da      	uxtb	r2, r3
  timp->SR = ~sr;
 800460a:	43d2      	mvns	r2, r2

  if ((sr & TIM_SR_CC1IF) != 0U)
 800460c:	079b      	lsls	r3, r3, #30
  timp->SR = ~sr;
 800460e:	612a      	str	r2, [r5, #16]
  if ((sr & TIM_SR_CC1IF) != 0U)
 8004610:	d408      	bmi.n	8004624 <VectorB0+0x34>
  OSAL_IRQ_EPILOGUE();
 8004612:	f7fc f9ed 	bl	80009f0 <_dbg_check_leave_isr>
 8004616:	4831      	ldr	r0, [pc, #196]	; (80046dc <VectorB0+0xec>)
 8004618:	f7fc f87a 	bl	8000710 <_trace_isr_leave>
}
 800461c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 8004620:	f7fb bfe6 	b.w	80005f0 <_port_irq_epilogue>
 8004624:	2320      	movs	r3, #32
 8004626:	f383 8811 	msr	BASEPRI, r3
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = vtlp->next;
 800462a:	4e2d      	ldr	r6, [pc, #180]	; (80046e0 <VectorB0+0xf0>)
  _dbg_check_lock_from_isr();
 800462c:	f7fc fa28 	bl	8000a80 <_dbg_check_lock_from_isr>
  chDbgCheckClassI();
 8004630:	f7fc f8d6 	bl	80007e0 <chDbgCheckClassI>
  chDbgCheckClassI();
 8004634:	f7fc f8d4 	bl	80007e0 <chDbgCheckClassI>
  vtp = vtlp->next;
 8004638:	69f4      	ldr	r4, [r6, #28]
  return (systime_t)STM32_ST_TIM->CNT;
 800463a:	6a68      	ldr	r0, [r5, #36]	; 0x24
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 800463c:	6ab3      	ldr	r3, [r6, #40]	; 0x28

    /* The list scan is limited by the timers header having
       "vtlp->vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 800463e:	68a2      	ldr	r2, [r4, #8]
  return (sysinterval_t)((systime_t)(end - start));
 8004640:	eba0 0903 	sub.w	r9, r0, r3
 8004644:	454a      	cmp	r2, r9
 8004646:	f106 0a1c 	add.w	sl, r6, #28
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)vtlp;
      vtlp->next = vtp->next;
      fn = vtp->func;
      vtp->func = NULL;
 800464a:	bf98      	it	ls
 800464c:	2700      	movls	r7, #0
    if (nowdelta < vtp->delta) {
 800464e:	d825      	bhi.n	800469c <VectorB0+0xac>
 8004650:	f04f 0820 	mov.w	r8, #32
 8004654:	e000      	b.n	8004658 <VectorB0+0x68>
 8004656:	6ab3      	ldr	r3, [r6, #40]	; 0x28
      vtp->next->prev = (virtual_timer_t *)vtlp;
 8004658:	6821      	ldr	r1, [r4, #0]
      fn = vtp->func;
 800465a:	f8d4 b00c 	ldr.w	fp, [r4, #12]
      vtlp->lasttime += vtp->delta;
 800465e:	4413      	add	r3, r2

      /* If the list becomes empty then the timer is stopped.*/
      if (is_vtlist_empty(vtlp)) {
 8004660:	4551      	cmp	r1, sl
      vtlp->lasttime += vtp->delta;
 8004662:	62b3      	str	r3, [r6, #40]	; 0x28
      vtp->next->prev = (virtual_timer_t *)vtlp;
 8004664:	f8c1 a004 	str.w	sl, [r1, #4]
      vtlp->next = vtp->next;
 8004668:	61f1      	str	r1, [r6, #28]
      vtp->func = NULL;
 800466a:	60e7      	str	r7, [r4, #12]
  STM32_ST_TIM->DIER = 0U;
 800466c:	bf08      	it	eq
 800466e:	60ef      	streq	r7, [r5, #12]
      nowdelta -= vtp->delta;
 8004670:	eba9 0902 	sub.w	r9, r9, r2
  _dbg_check_unlock_from_isr();
 8004674:	f7fc f9ec 	bl	8000a50 <_dbg_check_unlock_from_isr>
 8004678:	f387 8811 	msr	BASEPRI, r7
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 800467c:	6920      	ldr	r0, [r4, #16]
 800467e:	47d8      	blx	fp
 8004680:	f388 8811 	msr	BASEPRI, r8
  _dbg_check_lock_from_isr();
 8004684:	f7fc f9fc 	bl	8000a80 <_dbg_check_lock_from_isr>
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = vtlp->next;
 8004688:	69f4      	ldr	r4, [r6, #28]
    }
    while (vtp->delta <= nowdelta);
 800468a:	68a2      	ldr	r2, [r4, #8]
 800468c:	4591      	cmp	r9, r2
 800468e:	d2e2      	bcs.n	8004656 <VectorB0+0x66>
  return (systime_t)STM32_ST_TIM->CNT;
 8004690:	6a68      	ldr	r0, [r5, #36]	; 0x24
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8004692:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8004694:	eba0 0903 	sub.w	r9, r0, r3
    if (nowdelta < vtp->delta) {
 8004698:	4591      	cmp	r9, r2
 800469a:	d2d9      	bcs.n	8004650 <VectorB0+0x60>
  }

  /* If the list is empty, nothing else to do.*/
  if (is_vtlist_empty(vtlp)) {
 800469c:	4554      	cmp	r4, sl
 800469e:	d013      	beq.n	80046c8 <VectorB0+0xd8>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
  vtlp->next->delta -= nowdelta;
 80046a0:	68a2      	ldr	r2, [r4, #8]
  vtlp->lasttime += nowdelta;
 80046a2:	62b0      	str	r0, [r6, #40]	; 0x28
  vtlp->next->delta -= nowdelta;
 80046a4:	1a12      	subs	r2, r2, r0
 80046a6:	4413      	add	r3, r2
  return systime + (systime_t)interval;
 80046a8:	2b02      	cmp	r3, #2
 80046aa:	bf2c      	ite	cs
 80046ac:	18c5      	addcs	r5, r0, r3
 80046ae:	1c85      	addcc	r5, r0, #2
 80046b0:	60a3      	str	r3, [r4, #8]
 80046b2:	4628      	mov	r0, r5
 80046b4:	f7fd f964 	bl	8001980 <stSetAlarm>
 80046b8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    delta = (sysinterval_t)TIME_MAX_SYSTIME;
  }
#endif
  port_timer_set_alarm(chTimeAddX(now, delta));

  chDbgAssert(chTimeDiffX(vtlp->lasttime, chVTGetSystemTimeX()) <=
 80046bc:	6ab2      	ldr	r2, [r6, #40]	; 0x28
 80046be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 80046c0:	1aa8      	subs	r0, r5, r2
 80046c2:	1a9b      	subs	r3, r3, r2
 80046c4:	4283      	cmp	r3, r0
 80046c6:	d805      	bhi.n	80046d4 <VectorB0+0xe4>
  _dbg_check_unlock_from_isr();
 80046c8:	f7fc f9c2 	bl	8000a50 <_dbg_check_unlock_from_isr>
 80046cc:	2300      	movs	r3, #0
 80046ce:	f383 8811 	msr	BASEPRI, r3
 80046d2:	e79e      	b.n	8004612 <VectorB0+0x22>
 80046d4:	4803      	ldr	r0, [pc, #12]	; (80046e4 <VectorB0+0xf4>)
 80046d6:	f7fc f85b 	bl	8000790 <chSysHalt>
 80046da:	bf00      	nop
 80046dc:	08004d74 	.word	0x08004d74
 80046e0:	20000e84 	.word	0x20000e84
 80046e4:	08005168 	.word	0x08005168
	...

080046f0 <Vector174>:
OSAL_IRQ_HANDLER(STM32_OTG2_HANDLER) {
 80046f0:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80046f2:	4c09      	ldr	r4, [pc, #36]	; (8004718 <Vector174+0x28>)
 80046f4:	4620      	mov	r0, r4
 80046f6:	f7fc f823 	bl	8000740 <_trace_isr_enter>
 80046fa:	f7fc f991 	bl	8000a20 <_dbg_check_enter_isr>
  usb_lld_serve_interrupt(&USBD2);
 80046fe:	4807      	ldr	r0, [pc, #28]	; (800471c <Vector174+0x2c>)
 8004700:	f7fc fb8e 	bl	8000e20 <usb_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 8004704:	f7fc f974 	bl	80009f0 <_dbg_check_leave_isr>
 8004708:	4620      	mov	r0, r4
 800470a:	f7fc f801 	bl	8000710 <_trace_isr_leave>
}
 800470e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004712:	f7fb bf6d 	b.w	80005f0 <_port_irq_epilogue>
 8004716:	bf00      	nop
 8004718:	08005018 	.word	0x08005018
 800471c:	20000e0c 	.word	0x20000e0c

08004720 <Vector14C>:
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8004720:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8004722:	4c09      	ldr	r4, [pc, #36]	; (8004748 <Vector14C+0x28>)
 8004724:	4620      	mov	r0, r4
 8004726:	f7fc f80b 	bl	8000740 <_trace_isr_enter>
 800472a:	f7fc f979 	bl	8000a20 <_dbg_check_enter_isr>
  usb_lld_serve_interrupt(&USBD1);
 800472e:	4807      	ldr	r0, [pc, #28]	; (800474c <Vector14C+0x2c>)
 8004730:	f7fc fb76 	bl	8000e20 <usb_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 8004734:	f7fc f95c 	bl	80009f0 <_dbg_check_leave_isr>
 8004738:	4620      	mov	r0, r4
 800473a:	f7fb ffe9 	bl	8000710 <_trace_isr_leave>
}
 800473e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004742:	f7fb bf55 	b.w	80005f0 <_port_irq_epilogue>
 8004746:	bf00      	nop
 8004748:	0800500c 	.word	0x0800500c
 800474c:	20000d94 	.word	0x20000d94

08004750 <Vector158>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8004750:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8004752:	480d      	ldr	r0, [pc, #52]	; (8004788 <Vector158+0x38>)
 8004754:	f7fb fff4 	bl	8000740 <_trace_isr_enter>
 8004758:	f7fc f962 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800475c:	4b0b      	ldr	r3, [pc, #44]	; (800478c <Vector158+0x3c>)
  if (dma.streams[15].func)
 800475e:	480c      	ldr	r0, [pc, #48]	; (8004790 <Vector158+0x40>)
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8004760:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[15].func)
 8004762:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8004764:	0d89      	lsrs	r1, r1, #22
 8004766:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 22U;
 800476a:	058c      	lsls	r4, r1, #22
 800476c:	60dc      	str	r4, [r3, #12]
  if (dma.streams[15].func)
 800476e:	b112      	cbz	r2, 8004776 <Vector158+0x26>
    dma.streams[15].func(dma.streams[15].param, flags);
 8004770:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 8004774:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8004776:	f7fc f93b 	bl	80009f0 <_dbg_check_leave_isr>
 800477a:	4803      	ldr	r0, [pc, #12]	; (8004788 <Vector158+0x38>)
 800477c:	f7fb ffc8 	bl	8000710 <_trace_isr_leave>
}
 8004780:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004784:	f7fb bf34 	b.w	80005f0 <_port_irq_epilogue>
 8004788:	08004e98 	.word	0x08004e98
 800478c:	40026400 	.word	0x40026400
 8004790:	200018e0 	.word	0x200018e0
	...

080047a0 <Vector154>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 80047a0:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80047a2:	480d      	ldr	r0, [pc, #52]	; (80047d8 <Vector154+0x38>)
 80047a4:	f7fb ffcc 	bl	8000740 <_trace_isr_enter>
 80047a8:	f7fc f93a 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80047ac:	4b0b      	ldr	r3, [pc, #44]	; (80047dc <Vector154+0x3c>)
  if (dma.streams[14].func)
 80047ae:	480c      	ldr	r0, [pc, #48]	; (80047e0 <Vector154+0x40>)
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80047b0:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[14].func)
 80047b2:	6f42      	ldr	r2, [r0, #116]	; 0x74
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80047b4:	0c09      	lsrs	r1, r1, #16
 80047b6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 16U;
 80047ba:	040c      	lsls	r4, r1, #16
 80047bc:	60dc      	str	r4, [r3, #12]
  if (dma.streams[14].func)
 80047be:	b10a      	cbz	r2, 80047c4 <Vector154+0x24>
    dma.streams[14].func(dma.streams[14].param, flags);
 80047c0:	6f80      	ldr	r0, [r0, #120]	; 0x78
 80047c2:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 80047c4:	f7fc f914 	bl	80009f0 <_dbg_check_leave_isr>
 80047c8:	4803      	ldr	r0, [pc, #12]	; (80047d8 <Vector154+0x38>)
 80047ca:	f7fb ffa1 	bl	8000710 <_trace_isr_leave>
}
 80047ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80047d2:	f7fb bf0d 	b.w	80005f0 <_port_irq_epilogue>
 80047d6:	bf00      	nop
 80047d8:	08004e8c 	.word	0x08004e8c
 80047dc:	40026400 	.word	0x40026400
 80047e0:	200018e0 	.word	0x200018e0
	...

080047f0 <Vector150>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 80047f0:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80047f2:	480d      	ldr	r0, [pc, #52]	; (8004828 <Vector150+0x38>)
 80047f4:	f7fb ffa4 	bl	8000740 <_trace_isr_enter>
 80047f8:	f7fc f912 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80047fc:	4b0b      	ldr	r3, [pc, #44]	; (800482c <Vector150+0x3c>)
  if (dma.streams[13].func)
 80047fe:	480c      	ldr	r0, [pc, #48]	; (8004830 <Vector150+0x40>)
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8004800:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[13].func)
 8004802:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8004804:	0989      	lsrs	r1, r1, #6
 8004806:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 6U;
 800480a:	018c      	lsls	r4, r1, #6
 800480c:	60dc      	str	r4, [r3, #12]
  if (dma.streams[13].func)
 800480e:	b10a      	cbz	r2, 8004814 <Vector150+0x24>
    dma.streams[13].func(dma.streams[13].param, flags);
 8004810:	6f00      	ldr	r0, [r0, #112]	; 0x70
 8004812:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8004814:	f7fc f8ec 	bl	80009f0 <_dbg_check_leave_isr>
 8004818:	4803      	ldr	r0, [pc, #12]	; (8004828 <Vector150+0x38>)
 800481a:	f7fb ff79 	bl	8000710 <_trace_isr_leave>
}
 800481e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004822:	f7fb bee5 	b.w	80005f0 <_port_irq_epilogue>
 8004826:	bf00      	nop
 8004828:	08004e80 	.word	0x08004e80
 800482c:	40026400 	.word	0x40026400
 8004830:	200018e0 	.word	0x200018e0
	...

08004840 <Vector130>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8004840:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8004842:	480c      	ldr	r0, [pc, #48]	; (8004874 <Vector130+0x34>)
 8004844:	f7fb ff7c 	bl	8000740 <_trace_isr_enter>
 8004848:	f7fc f8ea 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800484c:	4b0a      	ldr	r3, [pc, #40]	; (8004878 <Vector130+0x38>)
  if (dma.streams[12].func)
 800484e:	480b      	ldr	r0, [pc, #44]	; (800487c <Vector130+0x3c>)
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8004850:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[12].func)
 8004852:	6e42      	ldr	r2, [r0, #100]	; 0x64
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8004854:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 8004858:	60d9      	str	r1, [r3, #12]
  if (dma.streams[12].func)
 800485a:	b10a      	cbz	r2, 8004860 <Vector130+0x20>
    dma.streams[12].func(dma.streams[12].param, flags);
 800485c:	6e80      	ldr	r0, [r0, #104]	; 0x68
 800485e:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8004860:	f7fc f8c6 	bl	80009f0 <_dbg_check_leave_isr>
 8004864:	4803      	ldr	r0, [pc, #12]	; (8004874 <Vector130+0x34>)
 8004866:	f7fb ff53 	bl	8000710 <_trace_isr_leave>
}
 800486a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800486e:	f7fb bebf 	b.w	80005f0 <_port_irq_epilogue>
 8004872:	bf00      	nop
 8004874:	08004e68 	.word	0x08004e68
 8004878:	40026400 	.word	0x40026400
 800487c:	200018e0 	.word	0x200018e0

08004880 <Vector12C>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8004880:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8004882:	480d      	ldr	r0, [pc, #52]	; (80048b8 <Vector12C+0x38>)
 8004884:	f7fb ff5c 	bl	8000740 <_trace_isr_enter>
 8004888:	f7fc f8ca 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 800488c:	4b0b      	ldr	r3, [pc, #44]	; (80048bc <Vector12C+0x3c>)
  if (dma.streams[11].func)
 800488e:	480c      	ldr	r0, [pc, #48]	; (80048c0 <Vector12C+0x40>)
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8004890:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[11].func)
 8004892:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8004894:	0d89      	lsrs	r1, r1, #22
 8004896:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 22U;
 800489a:	058c      	lsls	r4, r1, #22
 800489c:	609c      	str	r4, [r3, #8]
  if (dma.streams[11].func)
 800489e:	b10a      	cbz	r2, 80048a4 <Vector12C+0x24>
    dma.streams[11].func(dma.streams[11].param, flags);
 80048a0:	6e00      	ldr	r0, [r0, #96]	; 0x60
 80048a2:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 80048a4:	f7fc f8a4 	bl	80009f0 <_dbg_check_leave_isr>
 80048a8:	4803      	ldr	r0, [pc, #12]	; (80048b8 <Vector12C+0x38>)
 80048aa:	f7fb ff31 	bl	8000710 <_trace_isr_leave>
}
 80048ae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80048b2:	f7fb be9d 	b.w	80005f0 <_port_irq_epilogue>
 80048b6:	bf00      	nop
 80048b8:	08004e5c 	.word	0x08004e5c
 80048bc:	40026400 	.word	0x40026400
 80048c0:	200018e0 	.word	0x200018e0
	...

080048d0 <Vector128>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 80048d0:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80048d2:	480d      	ldr	r0, [pc, #52]	; (8004908 <Vector128+0x38>)
 80048d4:	f7fb ff34 	bl	8000740 <_trace_isr_enter>
 80048d8:	f7fc f8a2 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80048dc:	4b0b      	ldr	r3, [pc, #44]	; (800490c <Vector128+0x3c>)
  if (dma.streams[10].func)
 80048de:	480c      	ldr	r0, [pc, #48]	; (8004910 <Vector128+0x40>)
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80048e0:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[10].func)
 80048e2:	6d42      	ldr	r2, [r0, #84]	; 0x54
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80048e4:	0c09      	lsrs	r1, r1, #16
 80048e6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 16U;
 80048ea:	040c      	lsls	r4, r1, #16
 80048ec:	609c      	str	r4, [r3, #8]
  if (dma.streams[10].func)
 80048ee:	b10a      	cbz	r2, 80048f4 <Vector128+0x24>
    dma.streams[10].func(dma.streams[10].param, flags);
 80048f0:	6d80      	ldr	r0, [r0, #88]	; 0x58
 80048f2:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 80048f4:	f7fc f87c 	bl	80009f0 <_dbg_check_leave_isr>
 80048f8:	4803      	ldr	r0, [pc, #12]	; (8004908 <Vector128+0x38>)
 80048fa:	f7fb ff09 	bl	8000710 <_trace_isr_leave>
}
 80048fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004902:	f7fb be75 	b.w	80005f0 <_port_irq_epilogue>
 8004906:	bf00      	nop
 8004908:	08004e44 	.word	0x08004e44
 800490c:	40026400 	.word	0x40026400
 8004910:	200018e0 	.word	0x200018e0
	...

08004920 <Vector124>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8004920:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8004922:	480d      	ldr	r0, [pc, #52]	; (8004958 <Vector124+0x38>)
 8004924:	f7fb ff0c 	bl	8000740 <_trace_isr_enter>
 8004928:	f7fc f87a 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800492c:	4b0b      	ldr	r3, [pc, #44]	; (800495c <Vector124+0x3c>)
  if (dma.streams[9].func)
 800492e:	480c      	ldr	r0, [pc, #48]	; (8004960 <Vector124+0x40>)
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8004930:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[9].func)
 8004932:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8004934:	0989      	lsrs	r1, r1, #6
 8004936:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 6U;
 800493a:	018c      	lsls	r4, r1, #6
 800493c:	609c      	str	r4, [r3, #8]
  if (dma.streams[9].func)
 800493e:	b10a      	cbz	r2, 8004944 <Vector124+0x24>
    dma.streams[9].func(dma.streams[9].param, flags);
 8004940:	6d00      	ldr	r0, [r0, #80]	; 0x50
 8004942:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8004944:	f7fc f854 	bl	80009f0 <_dbg_check_leave_isr>
 8004948:	4803      	ldr	r0, [pc, #12]	; (8004958 <Vector124+0x38>)
 800494a:	f7fb fee1 	bl	8000710 <_trace_isr_leave>
}
 800494e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004952:	f7fb be4d 	b.w	80005f0 <_port_irq_epilogue>
 8004956:	bf00      	nop
 8004958:	08004e30 	.word	0x08004e30
 800495c:	40026400 	.word	0x40026400
 8004960:	200018e0 	.word	0x200018e0
	...

08004970 <Vector120>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8004970:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8004972:	480c      	ldr	r0, [pc, #48]	; (80049a4 <Vector120+0x34>)
 8004974:	f7fb fee4 	bl	8000740 <_trace_isr_enter>
 8004978:	f7fc f852 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800497c:	4b0a      	ldr	r3, [pc, #40]	; (80049a8 <Vector120+0x38>)
  if (dma.streams[8].func)
 800497e:	480b      	ldr	r0, [pc, #44]	; (80049ac <Vector120+0x3c>)
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8004980:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[8].func)
 8004982:	6c42      	ldr	r2, [r0, #68]	; 0x44
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8004984:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 8004988:	6099      	str	r1, [r3, #8]
  if (dma.streams[8].func)
 800498a:	b10a      	cbz	r2, 8004990 <Vector120+0x20>
    dma.streams[8].func(dma.streams[8].param, flags);
 800498c:	6c80      	ldr	r0, [r0, #72]	; 0x48
 800498e:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8004990:	f7fc f82e 	bl	80009f0 <_dbg_check_leave_isr>
 8004994:	4803      	ldr	r0, [pc, #12]	; (80049a4 <Vector120+0x34>)
 8004996:	f7fb febb 	bl	8000710 <_trace_isr_leave>
}
 800499a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800499e:	f7fb be27 	b.w	80005f0 <_port_irq_epilogue>
 80049a2:	bf00      	nop
 80049a4:	08004e24 	.word	0x08004e24
 80049a8:	40026400 	.word	0x40026400
 80049ac:	200018e0 	.word	0x200018e0

080049b0 <VectorFC>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 80049b0:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80049b2:	480d      	ldr	r0, [pc, #52]	; (80049e8 <VectorFC+0x38>)
 80049b4:	f7fb fec4 	bl	8000740 <_trace_isr_enter>
 80049b8:	f7fc f832 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80049bc:	4b0b      	ldr	r3, [pc, #44]	; (80049ec <VectorFC+0x3c>)
  if (dma.streams[7].func)
 80049be:	480c      	ldr	r0, [pc, #48]	; (80049f0 <VectorFC+0x40>)
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80049c0:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[7].func)
 80049c2:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80049c4:	0d89      	lsrs	r1, r1, #22
 80049c6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 22U;
 80049ca:	058c      	lsls	r4, r1, #22
 80049cc:	60dc      	str	r4, [r3, #12]
  if (dma.streams[7].func)
 80049ce:	b10a      	cbz	r2, 80049d4 <VectorFC+0x24>
    dma.streams[7].func(dma.streams[7].param, flags);
 80049d0:	6c00      	ldr	r0, [r0, #64]	; 0x40
 80049d2:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 80049d4:	f7fc f80c 	bl	80009f0 <_dbg_check_leave_isr>
 80049d8:	4803      	ldr	r0, [pc, #12]	; (80049e8 <VectorFC+0x38>)
 80049da:	f7fb fe99 	bl	8000710 <_trace_isr_leave>
}
 80049de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80049e2:	f7fb be05 	b.w	80005f0 <_port_irq_epilogue>
 80049e6:	bf00      	nop
 80049e8:	08004e10 	.word	0x08004e10
 80049ec:	40026000 	.word	0x40026000
 80049f0:	200018e0 	.word	0x200018e0
	...

08004a00 <Vector84>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8004a00:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8004a02:	480d      	ldr	r0, [pc, #52]	; (8004a38 <Vector84+0x38>)
 8004a04:	f7fb fe9c 	bl	8000740 <_trace_isr_enter>
 8004a08:	f7fc f80a 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8004a0c:	4b0b      	ldr	r3, [pc, #44]	; (8004a3c <Vector84+0x3c>)
  if (dma.streams[6].func)
 8004a0e:	480c      	ldr	r0, [pc, #48]	; (8004a40 <Vector84+0x40>)
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8004a10:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[6].func)
 8004a12:	6b42      	ldr	r2, [r0, #52]	; 0x34
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8004a14:	0c09      	lsrs	r1, r1, #16
 8004a16:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 16U;
 8004a1a:	040c      	lsls	r4, r1, #16
 8004a1c:	60dc      	str	r4, [r3, #12]
  if (dma.streams[6].func)
 8004a1e:	b10a      	cbz	r2, 8004a24 <Vector84+0x24>
    dma.streams[6].func(dma.streams[6].param, flags);
 8004a20:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8004a22:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8004a24:	f7fb ffe4 	bl	80009f0 <_dbg_check_leave_isr>
 8004a28:	4803      	ldr	r0, [pc, #12]	; (8004a38 <Vector84+0x38>)
 8004a2a:	f7fb fe71 	bl	8000710 <_trace_isr_leave>
}
 8004a2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004a32:	f7fb bddd 	b.w	80005f0 <_port_irq_epilogue>
 8004a36:	bf00      	nop
 8004a38:	08004dfc 	.word	0x08004dfc
 8004a3c:	40026000 	.word	0x40026000
 8004a40:	200018e0 	.word	0x200018e0
	...

08004a50 <Vector80>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8004a50:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8004a52:	480d      	ldr	r0, [pc, #52]	; (8004a88 <Vector80+0x38>)
 8004a54:	f7fb fe74 	bl	8000740 <_trace_isr_enter>
 8004a58:	f7fb ffe2 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8004a5c:	4b0b      	ldr	r3, [pc, #44]	; (8004a8c <Vector80+0x3c>)
  if (dma.streams[5].func)
 8004a5e:	480c      	ldr	r0, [pc, #48]	; (8004a90 <Vector80+0x40>)
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8004a60:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[5].func)
 8004a62:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8004a64:	0989      	lsrs	r1, r1, #6
 8004a66:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 6U;
 8004a6a:	018c      	lsls	r4, r1, #6
 8004a6c:	60dc      	str	r4, [r3, #12]
  if (dma.streams[5].func)
 8004a6e:	b10a      	cbz	r2, 8004a74 <Vector80+0x24>
    dma.streams[5].func(dma.streams[5].param, flags);
 8004a70:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8004a72:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8004a74:	f7fb ffbc 	bl	80009f0 <_dbg_check_leave_isr>
 8004a78:	4803      	ldr	r0, [pc, #12]	; (8004a88 <Vector80+0x38>)
 8004a7a:	f7fb fe49 	bl	8000710 <_trace_isr_leave>
}
 8004a7e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004a82:	f7fb bdb5 	b.w	80005f0 <_port_irq_epilogue>
 8004a86:	bf00      	nop
 8004a88:	08004df0 	.word	0x08004df0
 8004a8c:	40026000 	.word	0x40026000
 8004a90:	200018e0 	.word	0x200018e0
	...

08004aa0 <Vector7C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8004aa0:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8004aa2:	480c      	ldr	r0, [pc, #48]	; (8004ad4 <Vector7C+0x34>)
 8004aa4:	f7fb fe4c 	bl	8000740 <_trace_isr_enter>
 8004aa8:	f7fb ffba 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8004aac:	4b0a      	ldr	r3, [pc, #40]	; (8004ad8 <Vector7C+0x38>)
  if (dma.streams[4].func)
 8004aae:	480b      	ldr	r0, [pc, #44]	; (8004adc <Vector7C+0x3c>)
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8004ab0:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[4].func)
 8004ab2:	6a42      	ldr	r2, [r0, #36]	; 0x24
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8004ab4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 8004ab8:	60d9      	str	r1, [r3, #12]
  if (dma.streams[4].func)
 8004aba:	b10a      	cbz	r2, 8004ac0 <Vector7C+0x20>
    dma.streams[4].func(dma.streams[4].param, flags);
 8004abc:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8004abe:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8004ac0:	f7fb ff96 	bl	80009f0 <_dbg_check_leave_isr>
 8004ac4:	4803      	ldr	r0, [pc, #12]	; (8004ad4 <Vector7C+0x34>)
 8004ac6:	f7fb fe23 	bl	8000710 <_trace_isr_leave>
}
 8004aca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8004ace:	f7fb bd8f 	b.w	80005f0 <_port_irq_epilogue>
 8004ad2:	bf00      	nop
 8004ad4:	08004dd8 	.word	0x08004dd8
 8004ad8:	40026000 	.word	0x40026000
 8004adc:	200018e0 	.word	0x200018e0

08004ae0 <Vector78>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8004ae0:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8004ae2:	480d      	ldr	r0, [pc, #52]	; (8004b18 <Vector78+0x38>)
 8004ae4:	f7fb fe2c 	bl	8000740 <_trace_isr_enter>
 8004ae8:	f7fb ff9a 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8004aec:	4b0b      	ldr	r3, [pc, #44]	; (8004b1c <Vector78+0x3c>)
  if (dma.streams[3].func)
 8004aee:	480c      	ldr	r0, [pc, #48]	; (8004b20 <Vector78+0x40>)
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8004af0:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[3].func)
 8004af2:	69c2      	ldr	r2, [r0, #28]
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8004af4:	0d89      	lsrs	r1, r1, #22
 8004af6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 22U;
 8004afa:	058c      	lsls	r4, r1, #22
 8004afc:	609c      	str	r4, [r3, #8]
  if (dma.streams[3].func)
 8004afe:	b10a      	cbz	r2, 8004b04 <Vector78+0x24>
    dma.streams[3].func(dma.streams[3].param, flags);
 8004b00:	6a00      	ldr	r0, [r0, #32]
 8004b02:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8004b04:	f7fb ff74 	bl	80009f0 <_dbg_check_leave_isr>
 8004b08:	4803      	ldr	r0, [pc, #12]	; (8004b18 <Vector78+0x38>)
 8004b0a:	f7fb fe01 	bl	8000710 <_trace_isr_leave>
}
 8004b0e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004b12:	f7fb bd6d 	b.w	80005f0 <_port_irq_epilogue>
 8004b16:	bf00      	nop
 8004b18:	08004dcc 	.word	0x08004dcc
 8004b1c:	40026000 	.word	0x40026000
 8004b20:	200018e0 	.word	0x200018e0
	...

08004b30 <Vector74>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8004b30:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8004b32:	480d      	ldr	r0, [pc, #52]	; (8004b68 <Vector74+0x38>)
 8004b34:	f7fb fe04 	bl	8000740 <_trace_isr_enter>
 8004b38:	f7fb ff72 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8004b3c:	4b0b      	ldr	r3, [pc, #44]	; (8004b6c <Vector74+0x3c>)
  if (dma.streams[2].func)
 8004b3e:	480c      	ldr	r0, [pc, #48]	; (8004b70 <Vector74+0x40>)
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8004b40:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[2].func)
 8004b42:	6942      	ldr	r2, [r0, #20]
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8004b44:	0c09      	lsrs	r1, r1, #16
 8004b46:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 16U;
 8004b4a:	040c      	lsls	r4, r1, #16
 8004b4c:	609c      	str	r4, [r3, #8]
  if (dma.streams[2].func)
 8004b4e:	b10a      	cbz	r2, 8004b54 <Vector74+0x24>
    dma.streams[2].func(dma.streams[2].param, flags);
 8004b50:	6980      	ldr	r0, [r0, #24]
 8004b52:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8004b54:	f7fb ff4c 	bl	80009f0 <_dbg_check_leave_isr>
 8004b58:	4803      	ldr	r0, [pc, #12]	; (8004b68 <Vector74+0x38>)
 8004b5a:	f7fb fdd9 	bl	8000710 <_trace_isr_leave>
}
 8004b5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004b62:	f7fb bd45 	b.w	80005f0 <_port_irq_epilogue>
 8004b66:	bf00      	nop
 8004b68:	08004dc0 	.word	0x08004dc0
 8004b6c:	40026000 	.word	0x40026000
 8004b70:	200018e0 	.word	0x200018e0
	...

08004b80 <Vector70>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8004b80:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8004b82:	480d      	ldr	r0, [pc, #52]	; (8004bb8 <Vector70+0x38>)
 8004b84:	f7fb fddc 	bl	8000740 <_trace_isr_enter>
 8004b88:	f7fb ff4a 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8004b8c:	4b0b      	ldr	r3, [pc, #44]	; (8004bbc <Vector70+0x3c>)
  if (dma.streams[1].func)
 8004b8e:	480c      	ldr	r0, [pc, #48]	; (8004bc0 <Vector70+0x40>)
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8004b90:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[1].func)
 8004b92:	68c2      	ldr	r2, [r0, #12]
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8004b94:	0989      	lsrs	r1, r1, #6
 8004b96:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 6U;
 8004b9a:	018c      	lsls	r4, r1, #6
 8004b9c:	609c      	str	r4, [r3, #8]
  if (dma.streams[1].func)
 8004b9e:	b10a      	cbz	r2, 8004ba4 <Vector70+0x24>
    dma.streams[1].func(dma.streams[1].param, flags);
 8004ba0:	6900      	ldr	r0, [r0, #16]
 8004ba2:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8004ba4:	f7fb ff24 	bl	80009f0 <_dbg_check_leave_isr>
 8004ba8:	4803      	ldr	r0, [pc, #12]	; (8004bb8 <Vector70+0x38>)
 8004baa:	f7fb fdb1 	bl	8000710 <_trace_isr_leave>
}
 8004bae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8004bb2:	f7fb bd1d 	b.w	80005f0 <_port_irq_epilogue>
 8004bb6:	bf00      	nop
 8004bb8:	08004db4 	.word	0x08004db4
 8004bbc:	40026000 	.word	0x40026000
 8004bc0:	200018e0 	.word	0x200018e0
	...

08004bd0 <Vector6C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8004bd0:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
 8004bd2:	480c      	ldr	r0, [pc, #48]	; (8004c04 <Vector6C+0x34>)
 8004bd4:	f7fb fdb4 	bl	8000740 <_trace_isr_enter>
 8004bd8:	f7fb ff22 	bl	8000a20 <_dbg_check_enter_isr>
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8004bdc:	4b0a      	ldr	r3, [pc, #40]	; (8004c08 <Vector6C+0x38>)
  if (dma.streams[0].func)
 8004bde:	480b      	ldr	r0, [pc, #44]	; (8004c0c <Vector6C+0x3c>)
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8004be0:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[0].func)
 8004be2:	6842      	ldr	r2, [r0, #4]
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8004be4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 8004be8:	6099      	str	r1, [r3, #8]
  if (dma.streams[0].func)
 8004bea:	b10a      	cbz	r2, 8004bf0 <Vector6C+0x20>
    dma.streams[0].func(dma.streams[0].param, flags);
 8004bec:	6880      	ldr	r0, [r0, #8]
 8004bee:	4790      	blx	r2
  OSAL_IRQ_EPILOGUE();
 8004bf0:	f7fb fefe 	bl	80009f0 <_dbg_check_leave_isr>
 8004bf4:	4803      	ldr	r0, [pc, #12]	; (8004c04 <Vector6C+0x34>)
 8004bf6:	f7fb fd8b 	bl	8000710 <_trace_isr_leave>
}
 8004bfa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8004bfe:	f7fb bcf7 	b.w	80005f0 <_port_irq_epilogue>
 8004c02:	bf00      	nop
 8004c04:	08004d9c 	.word	0x08004d9c
 8004c08:	40026000 	.word	0x40026000
 8004c0c:	200018e0 	.word	0x200018e0

08004c10 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8004c10:	b4f0      	push	{r4, r5, r6, r7}
 8004c12:	4f14      	ldr	r7, [pc, #80]	; (8004c64 <__init_ram_areas+0x54>)
 8004c14:	4d14      	ldr	r5, [pc, #80]	; (8004c68 <__init_ram_areas+0x58>)
 8004c16:	4815      	ldr	r0, [pc, #84]	; (8004c6c <__init_ram_areas+0x5c>)
 8004c18:	4b15      	ldr	r3, [pc, #84]	; (8004c70 <__init_ram_areas+0x60>)
 8004c1a:	4916      	ldr	r1, [pc, #88]	; (8004c74 <__init_ram_areas+0x64>)
 8004c1c:	f107 0c70 	add.w	ip, r7, #112	; 0x70
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8004c20:	2600      	movs	r6, #0
    while (p < rap->clear_area) {
 8004c22:	4298      	cmp	r0, r3
 8004c24:	d911      	bls.n	8004c4a <__init_ram_areas+0x3a>
 8004c26:	3904      	subs	r1, #4
 8004c28:	461a      	mov	r2, r3
      *p = *tp;
 8004c2a:	f851 4f04 	ldr.w	r4, [r1, #4]!
 8004c2e:	f842 4b04 	str.w	r4, [r2], #4
    while (p < rap->clear_area) {
 8004c32:	4290      	cmp	r0, r2
 8004c34:	d8f9      	bhi.n	8004c2a <__init_ram_areas+0x1a>
 8004c36:	1e42      	subs	r2, r0, #1
 8004c38:	1ad2      	subs	r2, r2, r3
 8004c3a:	f022 0203 	bic.w	r2, r2, #3
 8004c3e:	3204      	adds	r2, #4
 8004c40:	4413      	add	r3, r2
    while (p < rap->no_init_area) {
 8004c42:	429d      	cmp	r5, r3
 8004c44:	d903      	bls.n	8004c4e <__init_ram_areas+0x3e>
      *p = 0;
 8004c46:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->no_init_area) {
 8004c4a:	429d      	cmp	r5, r3
 8004c4c:	d8fb      	bhi.n	8004c46 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8004c4e:	4567      	cmp	r7, ip
 8004c50:	d005      	beq.n	8004c5e <__init_ram_areas+0x4e>
 8004c52:	e9d7 1304 	ldrd	r1, r3, [r7, #16]
 8004c56:	e9d7 0506 	ldrd	r0, r5, [r7, #24]
 8004c5a:	3710      	adds	r7, #16
 8004c5c:	e7e1      	b.n	8004c22 <__init_ram_areas+0x12>
#endif
}
 8004c5e:	bcf0      	pop	{r4, r5, r6, r7}
 8004c60:	4770      	bx	lr
 8004c62:	bf00      	nop
 8004c64:	0800534c 	.word	0x0800534c
 8004c68:	20002c50 	.word	0x20002c50
 8004c6c:	20002c50 	.word	0x20002c50
 8004c70:	20002c50 	.word	0x20002c50
 8004c74:	08005540 	.word	0x08005540
	...

08004c80 <__default_exit>:
  while (true) {
 8004c80:	e7fe      	b.n	8004c80 <__default_exit>
 8004c82:	bf00      	nop
	...

08004c90 <__late_init>:
 8004c90:	4770      	bx	lr
 8004c92:	bf00      	nop
	...

08004ca0 <__core_init>:
}
 8004ca0:	4770      	bx	lr
 8004ca2:	bf00      	nop
